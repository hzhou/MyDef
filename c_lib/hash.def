#---------------------------------------- 
#- Let's limit max table size 64k
#-     #1 expectation from user: linear insertion/search time
#-     assumption, 20% extra space is not of concern
#- Special needs such as extremely large hash, complete hashing: seek special implementation

subcode: hash_common
    $struct(str_hash) n_size, n_fill 
    $struct(str_hash) i_slot 
    $struct(str_hash) n_rec_size, void * rec_table

#-- string keys, use str_pool to manage storages
#--     refer to Knuth's TeX (38. string handling)
subcode: str_hash
    $call hash_common
    $struct(str_hash) i_key, i_pool, n_pool, pn_keystart, pc_pool
    $struct(str_hash) uint16_t * key_table 

#-- integer keys are much simpler
subcode: int_hash
    $call hash_common
    $struct(str_hash) int * key_table, char * flag_table 

#----------------------------------------------- 
fncode: int_hash_exit(struct int_hash * h)
    $if h->n_size>0
        free(key_table)
        free(flag_table)
        $if h->n_rec_size>0
            free(rec_table)
    free(h)

fncode: str_hash_exit(struct str_hash * h)
    $if h->n_size>0
        free(key_table)
        free(pc_pool)
        $if h->n_rec_size>0
            free(rec_table)
    free(h)
#---------------------------------------- 
#-- Use open addressing: Knuth, ch6, Algorithm L 
#--    simple table, no links, good performance until 80%
#--    straight algorithm, allows deletion (albeit slow)
page: hash
    subcode: main
        $include stdint

        $call str_hash
        #---------------------------------------- 
        $list hash_prime_size

fncode: hash_prime_size(n)
    #-- 2*3*5*7*...
    #-- 210, 2310, ...

    $map small_prime, 11, 23, 47, 101, 211
    $elif n<2309
        return 211 + n/210*210
    $elif n<65535
        return 2309 + n/2310*2310
    $else
        $call die, "hash table limit (65535) exceeded\n"

subcode: small_prime(n)
    $case n<=$(n)
        return $(n)

#---- hash_lookup ------------------------------------ 
subcode: hash_lookup(key, type)
    $if h->key_table[tn_h]==0
        $call hash_found_empty
    $else
        $call hash_check_key, $(type)
        $while 1
            $if tn_h==0
                tn_h=$(M)-1
            $else
                tn_h--
            $if h->key_table[tn_h]==0
                $call hash_found_empty
            $else
                $call hash_check_key, $(type)

fncode: hash_lookup_int(struct int_hash * h, int key)
    $return_type bool
    $(set:M=h->n_size)
    $call get_str_hash
    $call hash_lookup, int

fncode: hash_lookup_str(struct int_hash * h, unsigned char * key, int key_len)
    $return_type bool
    $(set:M=h->n_size)
    $call get_str_hash
    $call hash_lookup, str

#----
subcode: get_str_hash
    tn_h=0
    i=0
    #-- generate keys that are large enough compared to M (<64k)
    $if key_len % 2
        tn_h = key[i]
        i++

    $while i<key_len
        tn_h += *((uint16_t *)(key+i))
        i+=2

    tn_h= tn_h % $(M)

#----
subcode: hash_check_key(type)
    $(if:type=int)
        $if h->key_table[tn_h]==$(key)
            h->i_slot=tn_h
            return true
    $(elif:type=str)
        tn_s=h->key_table[tn_h]
        tn_slen=h->pn_keystart[tn_s+1]-pn_keystart[tn_s]
        $if tn_slen==key_len && memcmp(h->pc_pool[pn_keystart[tn_s]], key, key_len)==0
            h->i_slot=tn_h
            return true

subcode: hash_found_empty
    h->i_slot=tn_h
    return false

#---- hash_set ------------------------------------------------

