include: macros_util/ogdl.def
include: macros_util/debug.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    subcode: main
	package MyDef::parseutil;
	$call parse_main
	$call support_subs
	$call support_eachfile
	$call support_ogdl
	1;

subcode: parse_main
    $sub import_data
	my ($plines, $var)=@_;
	my $def={"resource"=>{}, 
		"pages"=>{}, 
		"codes"=>{}, 
		"macros"=>{},
		};

	# -------- global macros from config ---------
	$while my ($k, $v)=each %$var
	    $if $k=~/macro_(\w+)/
		$macros->{$1}=$v;
	# -------- include files ---------
	my @includes;
	my %includes;
	$call load_standard_includes

	# -----------------------------------------------
	import_file($plines, $var, $def, \@includes,\%includes)
	$while 1
	    $if my $file=shift(@includes)
		$plines=get_lines($file, $var);
		import_file($plines, $var, $def, \@includes,\%includes)
	    $elif my $file=shift(@standard_includes)
		$plines=get_lines($file, $var);
		import_file($plines, $var, $def, \@includes,\%includes)
	    $else
		last
	# ---- End of Parsing ---------------------------
	post_foreachfile($def);
	post_matchblock($def);
	#$call dump_hash, $def
	return $def;

    $sub import_file
	my ($plines, $var, $def, $include_list, $include_hash)=@_
	my $pages=$def->{pages}
	my $codes=$def->{codes}
	my $macros=$def->{macros}
	# ---------------------
	$call perfile_variables
	# Insert an END to flush all the indentations
	# Empty "END" stage gets ignored by default
	push @$plines, "END"
	$foreach my $line in @$plines
	    $call get_indentation
	    $call grab_block

	    $if $curindent < $codeindent
		# ---- End Code Block
		$call get_source_dedent, codeindent
		$codeindent=0;
	    # -------------------------------
	    $if $codeindent>0
		# ---- In Code Block ---------------------------
		$call get_source_indent, curindent
		$call get_source_dedent, curindent
		push @$source, $line;
	    $elif $line=~/^(\w+)code:(:?)\s+(\w+)(.*)/
		my ($type, $dblcolon, $name, $t)=($1, $2, $3, $4)
		$call start_subcode
	    $elif $curindent==0
		$if $line=~/^include:? (.*)/
		    $if !$include_hash->{$1}
			push @$include_list, $1;
			$include_hash->{$1}=1;
			#print STDERR "    include $1\n";
		$elif $line=~/^(sub)?page: (.*)/
		    my ($subpage, $t)=($1, $2)
		    $call start_page
		$elif $line=~/^resource:\s+(\w+)/
		    $grab="ogdl"
		    $grab_indent=$curindent
		    $grab_key=$1
		    $grab_hash=$def->{resource}
		$elif $line=~/^(\w+)/
		    # fields, macros,
		    $stage=$1;
		    $if !$def->{$stage}
			$def->{$stage}={};
	    $else
		$if $stage =~ /^(fields)$/
		    $call process_fields
		$elsif $stage =~/^macros$/
		    $call process_macros
		$elsif $stage =~/^(page)$/
		    $call process_page_macros
	    # -------------------------------
	    # -- PreInsert Indent so empty switch cases work
	    $if $line=~/^\$(if|elif)/
		$curindent++
		$lastindent++
		push @$source, "SOURCE_INDENT";

subcode: perfile_variables
    my $stage="";
    # -- 
    my $item
    my $page
    my $source

    my $curindent;
    my $codeindent = 0
    my $lastindent;

    # --- grab ogdl
    my $grab=undef
    my $grab_hash
    my $grab_key
    my $grab_indent
    my @grab

subcode: get_indentation
    $if $line=~/^\s*$/
	# Skip empty lines
	next;
    $elif $line=~/^\s*#/
	# Skip comment lines
	next;
    $elif $line=~/^(\s*)(.*)/
	# get current indentation and stripping starting spaces
	$curindent=getindent($1);
	$line=$2
	$line=~s/\s+$//
	$line=~s/\s+#\s+.*$//

subcode: grab_block
    $if $grab
	$if $curindent>$grab_indent
	    my $i=$curindent-$grab_indent-1;
	    push @grab, "$i:$line";
	    next;
	$else
	    $if $grab eq "ogdl"
		my $ogdl=grab_ogdl($grab_key, \@grab)
		$if !$grab_hash->{$grab_key}
		    $grab_hash->{$grab_key}=$ogdl;
		$else
		    my $t=$grab_hash->{$grab_key}
		    $while my ($k, $v)=each %$ogdl
			$if !defined $t->{$k}
			    $t->{$k}=$v
		#print_ogdl($ogdl, 0)
	    undef $grab;
	    @grab=();

subcode: get_source_indent(curindent)
    $while $$(curindent)>$lastindent
	$lastindent++;
	push @$source, "SOURCE_INDENT";
subcode: get_source_dedent(curindent)
    $while $$(curindent)<$lastindent
	$lastindent--;
	push @$source, "SOURCE_DEDENT";

subcode: start_subcode
    ### htmlcode, jscode, subcode, phpcode, fncode
    $source=[];
    $codeindent=$curindent+1;
    $lastindent=$codeindent;
    # -------------------
    $if $curindent==0 and $codes->{$name}
	$if $dblcolon
	    $source=$codes->{$name}->{source}
	$elif $debug>1
	    print STDERR "overwiritten $type code: $name\n"
    $else
	my @params;
	$if $t=~/\((.*)\)/
	    $t=$1;
	    @params=split /,\s*/, $t;
	my $t_code={'type'=>$type, 'source'=>$source, 'params'=>\@params};
	$if $curindent == 0
	    $codes->{$name}=$t_code;
	    $stage='code';
	$elif $stage eq 'page'
	    $page->{codes}->{$name}=$t_code;

subcode: start_page
    my ($pagename, $maincode)
    # ---- name
    $if $t=~/([a-zA-Z0-9_\-\$]+),\s*(\w.*)/
	$pagename=$1;
	$maincode=$2;
    $elif $t=~/([a-zA-Z0-9_\-\$]+)/
	$pagename=$1;
    # ---- code
    my $code={};
    $if $maincode
	$code->{main}={'type'=>'sub', 'source'=>["\$call $maincode"], 'params'=>[]};

    $page={pagename=>$pagename, codes=>$code};
    $if $subpage
	$page->{subpage}=1;
    # ---- insert into pages
    $if $pages->{$pagename}
	my $t=$pagename;
	my $j=0;
	$while $pages->{$pagename}
	    $j++;
	    $pagename=$t.$j;
    $pages->{$pagename}=$page;
    $stage='page';

subcode: process_fields
    if($line=~/^optional:(.*)/){
	my @tlist=split(/,/, $1);
	foreach my $t (@tlist){
	    if($t=~/(\w+)/){
		if($def->{$stage}->{$1}){
		    $def->{$stage}->{$1}->{optional}=1;
		}
		else{
		    $def->{$stage}->{$1}={optional=>1};
		}
	    }
	}
    }
    elsif($curindent==1){
	if($line=~/^([a-zA-Z0-9-_]+):\s*(.*)$/){
	    if($def->{$stage}->{$1}){
		$item=$def->{$stage}->{$1};
	    }
	    else{
		$item={};
		$def->{$stage}->{$1}=$item;
	    }
	    if($2){
		$item->{type}=$2;
		$item->{value}=$2;
		$item->{title}=$2;
	    }
	}
    }
    elsif($line=~/^(\w+): (.*)/){
	my $k=$1;
	my $v=$2;
	expand_macro(\$v, $macros);
	if($item->{$k}){
	    print STDERR " Denied overwriting $k with $v\n" if $debug>1;
	}
	else{
	    $item->{$k}=$v;
	}
    }
subcode: process_macros
    $if $line=~/^(\w+): (.*\S)/
	my $k=$1;
	my $v=$2;
	$if $macros->{$k}
	    print STDERR " Overriden macro $k\n" if $debug>1;
	$else
	    my $t=$v;
	    expand_macro(\$t, $macros);
	    $macros->{$k}=$t;

subcode: process_page_macros
    $if $line=~/^source: (.*)/
	$page->{codes}->{main}={'type'=>"sub", 'source'=>["\$call $1"], 'params'=>[]};
    $elsif $line=~/^(\w+): (.*)/
	my $k=$1;
	my $v=$2;
	expand_macro(\$v, $macros);
	$page->{$k}=$v;

subcode: support_subs
    our @indent_stack=(0);
    $sub getindent
	use integer;
	my $s=shift;
	1 while $s=~s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
	my $i=length($s);
	if($i==$indent_stack[-1]){
	}
	elsif($i>$indent_stack[-1]){
	    push @indent_stack, $i;
	}
	else{
	    while($i<$indent_stack[-1]){
		pop @indent_stack;
	    }
	}
	
	return $#indent_stack;

    $sub expand_macro
	my ($lref, $macros)=@_;
	$while  $$lref=~/\$\(\w+\)/
	    my @segs=split /(\$\(\w+\))/, $$lref;
	    my $j=0;
	    my $flag=0;
	    $foreach my $s in @segs
		$if $s=~/\$\((\w+)\)/
		    my $t=$macros->{$1};
		    $if $t eq $s
			die "Looping macro $1 in \"$$lref\"!\n";
		    $if $t
			$segs[$j]=$t;
			$flag++;
		$j++;
	    $if $flag
		$$lref=join '', @segs;
	    $else
		last;

    $sub get_lines
	my ($file, $var)=@_;

	my $filename="";
	$if -f $file
	    $filename=$file;
	$if !$filename and $var->{'include_path'}
	    my @dirs=split /:/, $var->{'include_path'};
	    $foreach my $dir in @dirs
		$if -f "$dir/$file"
		    $filename="$dir/$file";
		    last;
	$if !-f $filename
	    print "include_path: $var->{include_path}\n";
	    die "$file not found\n";
	#print STDERR "Parsing Definition File: $filename\n";
	open In, $filename or die "Can't open $file.\n";
	my @lines=<In>;
	close In;
	return \@lines;

subcode: load_standard_includes
    my @standard_includes;
    $if $var->{module} eq "php"
	push @standard_includes, "std_php.def";
    $elsif $var->{module} eq "c"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "xs"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "apple"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "win32"
	push @standard_includes, "std_c.def";
	push @standard_includes, "std_win32.def";

subcode: support_eachfile
    # Hack for the following work:
    #page: order$1
    #    output_dir: sales
    #    foreachfile: templates/order(*).php
    #    htmlcode: main
    #        $call basic_process
    #        $include templates/order$1.php

    sub post_foreachfile {
	my $def=shift;
	my $pages=$def->{pages};
	while(my ($name, $p)=each(%$pages)){
	    if ($p->{foreachfile}){
		my $pat_glob=$p->{foreachfile};
		my $pat_regex=$p->{foreachfile};
		my $n;
		$n=$pat_glob=~s/\(\*\)/\*/g;
		$pat_regex=~s/\(\*\)/\(\.\*\)/g;
		my @files=glob($pat_glob);
		foreach my $f(@files){
		    #my @pat_list=($f=~/order(.*).php/);
		    #$pat_glob="order(.*).php";
		    my @pat_list=($f=~/$pat_regex/);
		    dupe_page($def, $p, $n, @pat_list);
		    #print "$f: ", join(",", @pat_list), "\n";
		}
		delete $pages->{$name};
	    }
	}
    }

    sub post_matchblock {
	my $def=shift;
	my $codes=$def->{codes};
	my @codelist=keys(%$codes);
	foreach $name (@codelist){
	    if($name=~/^pre_(\w+)/ and !$codes->{"post_$1"}){
		my $loopname=$1;
		#print "Adding subcode post_$1\n";
		my $params=$codes->{$name}->{params};
		my $type=$codes->{$name}->{type};
		my $presource=$codes->{$name}->{source};
		my $source=[];
		my $t_code={'type'=>$type, 'source'=>$source, 'params'=>$params};
		foreach my $l(@$presource){
		    if($l=~/\$openfor/){
			push @$source, "DEDENT }";
		    }
		}
		$codes->{"post_$loopname"}=$t_code;
	    }
	}
    }

    sub dupe_page {
	my ($def, $page, $n, @pat_list)=@_;
	my $pagename=dupe_line($page->{pagename}, $n, @pat_list);
	print "    foreach file $pagename $n: ", join(",", @pat_list), "\n";
	my $p={};
	while(my ($k, $v)=each(%$page)){
	    if($k eq "pagename"){
		$p->{pagename}=$pagename;
	    }
	    elsif($k eq "codes"){
		my $codes={};
		while(my ($tk, $tv)=each(%$v)){
		    my $tcode={};
		    $tcode->{type}=$tv->{type};
		    $tcode->{params}=$tv->{params};
		    my @source;
		    my $tsource=$tv->{source};
		    foreach my $l (@$tsource){
			push @source, dupe_line($l, $n, @pat_list);
		    }
		    $tcode->{source}=\@source;
		    $codes->{$tk}=$tcode;
		}
		$p->{codes}=$codes;
	    }
	    elsif($k eq "foreachfile"){
	    }
	    else{
		$p->{$k}=dupe_line($v);
	    }
	}
	my $pages=$def->{pages};
	if($pages->{$pagename}){
	    my $t=$pagename;
	    my $j=0;
	    while($pages->{$pagename}){
		$j++;
		$pagename=$t."_$j";
	    }
	}
	$pages->{$pagename}=$p;
    }

    sub dupe_line {
	my ($l, $n, @pat_list)=@_;
	for (my $i=1; $i<=$n; $i++){
	    $rep=$pat_list[$i-1];
	    $l=~s/\$$i/$rep/g;
	}
	return $l;
    }

