include: macros_parse/indentation.def
include: macros_parse/subcode.def
include: macros_parse/debug.def
include: macros_util/path.def
include: macros_util/ogdl.def
include: macros_util/debug.def
include: perl/indentations.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::parseutil
    subcode: main
        $global $debug=0
        # $call support_subs
        $call support_eachfile
        $call support_ogdl
        1;

#---------------------------------------- 
fncode: import_data($file)
    $global $defname="default";
    $if $file=~/([^\/]+)\.def/
        $defname=$1

    my $def={"resource"=>{}, 
            "pages"=>{}, 
            "pagelist"=>[],
            "codes"=>{}, 
            "macros"=>{},
            "defname"=>$defname,
            };

    # -------- global macros from config ---------
    $while my ($k, $v)=each %$MyDef::var
        $if $k=~/macro_(\w+)/
            $def->{macros}->{$1}=$v;
    # -------- include files ---------
    my @includes;
    my %includes;

    # -----------------------------------------------
    import_file($file, $def, \@includes,\%includes, "main")
    $call load_standard_includes
    $while 1
        $if @includes
            my $file=shift(@includes)
            import_file($file, $def, \@includes,\%includes, "include")
        $elif @standard_includes
            my $file=shift(@standard_includes)
            import_file($file, $def, \@includes,\%includes, "standard_include")
        $else
            last

    # ---- End of Parsing ---------------------------
    post_foreachfile($def);
    post_matchblock($def);
    # $call compile_perlcode
    $if $debug
        $foreach $k in keys %$debug
            $if $k eq "def"
                debug_def($def)
            $elif $k=~/^code:\s*(\w+)/
                debug_code($def->{codes}->{$1})
    return $def;

fncode: import_file($f, $def, $include_list, $include_hash, $file_type)
    # $print import_file [$f]
    #---- import a single def file, update include_list -----
    # ---------------------
    $call @import_file_init
    my $plines=get_lines($f);
    # Insert an END to flush all the indentations
    # Empty "END" stage gets ignored by default
    push @$plines, "END"
    my $cur_file=$f
    my $cur_line=0
    &call parse_loop
        $call get_multiline_comment
        $call get_indentation  # and skip comments, trim leading and tailing spaces

        $call check_end_codeindent

        $if $(in_code)
            $call get_source_indent, $curindent
            $call get_source_dedent, $curindent
        # -------------------------------
        $if $line=~/^\w+code:/ && $(top_scope)
            $call check_end_automain
            $call subcode_start
            $call start_code_indent, code, $curindent+1, $t_code
        $elif $line=~/^macros:/ && $(top_scope)
            $call macros_start
            $call start_code_indent, macro, $curindent+1, $macros
        $elif $(in_code)
            push @$source, $line
        $elif $(in_macro)
            $call process_macros
        $elif $curindent==0
            $call @parse_level_0
        $elif $(in_page)
            $if $line=~/^(\w+):\s*(.*)/
                $call process_page_macros
            $elif $line=~/^\s*$/
                next
            $else
                # $print jump_to_main_code [$line]
                $call jump_to_main_code

#---------------------------------------- 
subcode: parse_loop
    $(allow_recurse:2)
    $while $cur_line < @$plines
        my $line = $plines->[$cur_line]
        $cur_line++
        BLOCK

#---------------------------------------- 
subcode: parse_level_0
    $if $line=~/^include:? (.*)/
        $if !$include_hash->{$1}
            $if $1 ne "noconfig"
                push @$include_list, $1;
            $include_hash->{$1}=1;
            #print STDERR "    include $1\n";
    $elif $line=~/^path:\s*(.+)/
        add_path($1)
    $elif $line=~/^(sub)?page: (.*)/
        my ($subpage, $t)=($1, $2)
        $call start_page
        $call start_code_indent, page, 1, $page
    $elif $line=~/^resource:\s+(\w+)(.*)/
        $call grab_resource
    $elif $line=~/^DEBUG\s*(.*)/
        $if $1
            $debug->{$1}=1
        $else
            $debug->{def}=1

#---------------------------------------- 
subcode: get_multiline_comment
    # multiline_comments, Note: we are more strict than the C comments. 
    $if $line=~/^\s*\/\*/
        $if $line !~ /\*\/\s*$/
            &call parse_loop
                $if $line=~/\*\/\s*$/
                    last
        next

subcode: get_indentation
    $if $line=~/^\s*$/
        # sometime empty lines are significant, passes on, where compileutil will filter
        $line=""
    $elif $line=~/^(\s*)(.*)/
        # get current indentation and stripping starting spaces
        my $indent=get_indent($1)
        $line=$2
        $if $line=~/^#(?!(define|undef|include|line|error|pragma|if|ifdef|ifndef|elif|else|endif)\b)/
            $if $indent != $curindent
                $line="NOOP"
            $else
                next
        $else
            # Trim the tail
            $line=~s/\s+$//
            # Tail # need spaces before and after!
            $line=~s/\s+#\s.*$//
        $curindent=$indent

subcode: grab_resource
    my $grab
    $if $def->{resource}->{$1}
        $grab=$def->{resource}->{$1}
    $else
        $grab={"_list"=>[], "_name"=>$1}
        $def->{resource}->{$1}=$grab
    my $t=$2
    $if $t=~/^\s*,\s*(.*)/
        my @tlist=split /,\s*/, $1
        $grab->{"_parents"}=\@tlist

    #----------------------------------------------- 
    my $grab_indent=$curindent
    my @grab
    &call parse_loop
        $call get_indentation
        $if $curindent>$grab_indent
            my $i=$curindent-$grab_indent-1;
            push @grab, "$i:$line";
        $else
            grab_ogdl($grab, \@grab)
            #print_ogdl($grab, 0)
    $cur_line--


# --------------------------------------------------------
subcode:: import_file_init
    my $page

subcode: start_page
    my ($pagename, $framecode)
    # ---- name
    $if $t=~/([a-zA-Z0-9_\-\$]+),\s*(\w.*)/
        $pagename=$1;
        $framecode=$2;
    $elif $t=~/([a-zA-Z0-9_\-\$]+)/
        $pagename=$1;
    # ---- code
    my $code={};
    $if $framecode
        #-- $framecode may include parameters
        $code->{main}={'type'=>'sub', 'source'=>["\$call $framecode"], 'params'=>[]};

    $page={pagename=>$pagename, codes=>$code};
    $if $subpage
        $page->{subpage}=1;
    $if $file_type eq "main"
        $call add_page

subcode: add_page
    # ---- insert into pages
    $if $pages->{$pagename}
        my $t=$pagename;
        my $j=0;
        $while $pages->{$pagename}
            $j++;
            $pagename=$t.$j;
    $pages->{$pagename}=$page;
    push @$pagelist, $pagename

#---- macros ------------------------------------ 
subcode: macros_start
    $if !$codeitem->{macros}
        $codeitem->{macros}={}
    $macros = $codeitem->{macros}

subcode: process_macros
    $if $line=~/^(\w+):(:)?\s*(.*\S)/
        my ($k,$dblcolon, $v)=($1, $2, $3)
        expand_macro(\$v, $macros);
        $if $macros->{$k}
            $if $dblcolon
                $macros->{$k}.=", $v"
            $elif $debug
                $print "Denied overwriting macro $k"
        $else
            $macros->{$k}=$v

subcode: process_page_macros
    my $k=$1;
    my $v=$2;
    expand_macro(\$v, $macros);
    $page->{$k}=$v;

#---------------------------------------- 
fncode: expand_macro($lref, $macros)
    $while  $$lref=~/\$\(\w+\)/
        my @segs=split /(\$\(\w+\))/, $$lref;
        my $j=0;
        my $flag=0;
        $foreach my $s in @segs
            $if $s=~/\$\((\w+)\)/
                my $t=$macros->{$1};
                $if $t eq $s
                    die "Looping macro $1 in \"$$lref\"!\n";
                $if $t
                    $segs[$j]=$t;
                    $flag++;
            $j++;
        $if $flag
            $$lref=join '', @segs;
        $else
            last;

#---------------------------------------- 
subcode: load_standard_includes
    my @standard_includes
    $if $MyDef::var->{'include'} and !$includes{"noconfig"}
        push @standard_includes, split(/[:,]\s*/, $MyDef::var->{'include'})

    my $stdinc="std_".$MyDef::var->{module}.".def"
    push @standard_includes, $stdinc

subcode: support_eachfile
    # Hack for the following work:
    #page: order$1
    #    output_dir: sales
    #    foreachfile: templates/order(*).php
    #    htmlcode: main
    #        $call basic_process
    #        $include templates/order$1.php

    $sub post_foreachfile
        my $def=shift;
        my $pages=$def->{pages};
        my $pagelist=$def->{pagelist}
        $while my ($name, $p)=each(%$pages)
            $if $p->{foreachfile}
                my $pat_glob=$p->{foreachfile};
                my $pat_regex=$p->{foreachfile};
                my $n;
                $n=$pat_glob=~s/\(\*\)/\*/g;
                $pat_regex=~s/\(\*\)/\(\.\*\)/g;
                my @files=glob($pat_glob);
                $foreach my $f in @files
                    my @pat_list=($f=~/$pat_regex/);
                    dupe_page($def, $p, $n, @pat_list);
                delete $pages->{$name};

    $sub post_matchblock
        my $def=shift;
        my $codes=$def->{codes};
        my @codelist=keys(%$codes);
        $foreach $name in @codelist
            $if $name=~/^pre_(\w+)/ and !$codes->{"post_$1"}
                my $loopname=$1;
                #print "Adding subcode post_$1\n";
                my $params=$codes->{$name}->{params};
                my $type=$codes->{$name}->{type};
                my $presource=$codes->{$name}->{source};
                my $source=[];
                my $t_code={'type'=>$type, 'source'=>$source, 'params'=>$params};
                $foreach $l in @$presource
                    $if $l=~/\$openfor/
                        push @$source, "DEDENT }";
                $codes->{"post_$loopname"}=$t_code;

    $sub dupe_page
        my ($def, $orig, $n, @pat_list)=@_;
        my $pagename=dupe_line($orig->{pagename}, $n, @pat_list);
        print "    foreach file $pagename $n: ", join(",", @pat_list), "\n";
        my $page={};
        $while my ($k, $v)=each(%$orig)
            $if $k eq "pagename"
                $page->{pagename}=$pagename;
            $elif $k eq "codes"
                my $codes={};
                $while my ($tk, $tv)=each(%$v)
                    my $tcode={};
                    $tcode->{type}=$tv->{type};
                    $tcode->{params}=$tv->{params};
                    my @source;
                    my $tsource=$tv->{source};
                    $foreach $l in @$tsource
                        push @source, dupe_line($l, $n, @pat_list);
                    $tcode->{source}=\@source;
                    $codes->{$tk}=$tcode;
                $page->{codes}=$codes;
            $elif $k ne "foreachfile"
                $page->{$k}=dupe_line($v);

        my $pages=$def->{pages};
        my $pagelist=$def->{pagelist}
        $call add_page

    $sub dupe_line
        my ($l, $n, @pat_list)=@_;
        $for my $i=1; $i<=$n; $i++
            my $rep=$pat_list[$i-1];
            $l=~s/\$$i/$rep/g;
        return $l;

# ---------------------------------------------------
subcode: compile_perlcode
    my $pages=$def->{pages}
    my $pagelist=$def->{pagelist}
    my $codes=$def->{codes}

    my @perlcode_list;
    $while my ($name, $code)= each %$codes
        $if $code->{type} eq "perl"
            $if $name ne "perl_global"
                push @perlcode_list, $name

    $if @perlcode_list
        my $maincode=[];
        my $page={pagename=>"perl-$defname", module=>"perl", type=>"pl", codes=>{main=>{type=>'sub', source=>$maincode, params=>[]}}};

        push @$maincode, "\$call \@perl_global"
        push @$maincode, "my (\$subname, \@alist)=\@ARGV"
        $foreach $name in @perlcode_list
            push @$maincode, "\$if \$subname eq \"$name\""
            push @$maincode, "SOURCE_INDENT"
            push @$maincode, "\$call $name"
            push @$maincode, "SOURCE_DEDENT"

        push @$pagelist, "perl-$defname"
        $pages->{"perl-$defname"}=$page


#---- utils ------------------------------------ 
fncode: get_lines($file)
    $if $file eq "-pipe"
        my @lines=<STDIN>
        return \@lines
    $else
        my $filename=find_file($file)
        $call get_file_lines, $filename
        return \@lines;

