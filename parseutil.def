include: macros_util/ogdl.def
include: macros_util/debug.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    subcode: main
	package MyDef::parseutil;
	$call parse_main
	$call support_subs
	$call support_eachfile
	$call support_ogdl
	1;

subcode: parse_main
    my $defname="default";

    $sub import_data
	my ($file, $var)=@_
	$if $file=~/([^\/]+)\.def/
	    $defname=$1
	import_data_lines($file, undef, $var)

    $sub import_data_lines
	my ($file, $plines, $var)=@_;
	my $def={"resource"=>{}, 
		"pages"=>{}, 
		"pagelist"=>[],
		"codes"=>{}, 
		"macros"=>{},
		"defname"=>$defname,
		};

	# -------- global macros from config ---------
	$while my ($k, $v)=each %$var
	    $if $k=~/macro_(\w+)/
		$def->{macros}->{$1}=$v;
	# -------- include files ---------
	my @includes;
	my %includes;
	$call load_standard_includes

	# -----------------------------------------------
	import_file($file, $plines, $var, $def, \@includes,\%includes)
	$while 1
	    $if my $file=shift(@includes)
		import_file($file, undef, $var, $def, \@includes,\%includes)
	    $elif my $file=shift(@standard_includes)
		import_file($file, undef, $var, $def, \@includes,\%includes)
	    $else
		last

	# ---- End of Parsing ---------------------------
	post_foreachfile($def);
	post_matchblock($def);
	$call compile_perlcode
	#$call dump_hash, $def
	return $def;

    $sub import_file
	my ($f, $plines, $var, $def, $include_list, $include_hash)=@_
	my $pages=$def->{pages}
	my $pagelist=$def->{pagelist}
	my $codes=$def->{codes}
	my $macros=$def->{macros}
	# ---------------------
	$call perfile_variables
	$if !$plines
	    $plines=get_lines($f, $var);
	# Insert an END to flush all the indentations
	# Empty "END" stage gets ignored by default
	push @$plines, "END"
	my $cur_file=$f
	my $cur_line=0
	$foreach my $line in @$plines
	    $cur_line++
	    $call get_multiline_comment
	    $call get_indentation  # and skip comments, trim leading and tailing spaces
	    $call grab_block

	    $if $curindent==0
		$if $stage eq "code"
		    $call end_subcode

	    $if $curindent < $codeindent
		# ---- End Code Block
		$call get_source_dedent, codeindent
		$codeindent=0;
	    # -------------------------------
	    $if $codeindent>0
		# ---- In Code Block ---------------------------
		$call get_source_indent, curindent
		$call get_source_dedent, curindent
		push @$source, $line;
	    $elif $line=~/^(\w+)code:([:-@]?)\s*(\w+)(.*)/
		my ($type, $dblcolon, $name, $t)=($1, $2, $3, $4)
		$call start_subcode
	    $elif $curindent==0
		$if $line=~/^include:? (.*)/
		    $if !$include_hash->{$1}
			push @$include_list, $1;
			$include_hash->{$1}=1;
			#print STDERR "    include $1\n";
		$elif $line=~/^(sub)?page: (.*)/
		    my ($subpage, $t)=($1, $2)
		    $call start_page
		$elif $line=~/^resource:\s+(\w+)/
		    $grab="ogdl"
		    $grab_indent=$curindent
		    $grab_key=$1
		    $grab_hash=$def->{resource}
		$elif $line=~/^(\w+)/
		    # fields, macros,
		    $stage=$1;
		    $if !$def->{$stage}
			$def->{$stage}={};
	    $else
		$if $stage =~ /^(fields)$/
		    $call process_fields
		$elsif $stage =~/^macros$/
		    $call process_macros
		$elsif $stage =~/^(page)$/
		    $call process_page_macros

subcode:: perfile_variables
    my $stage="";
    # -- 
    my $item
    my $page

    my $curindent;
    my $codeindent = 0
    my $lastindent;

    # --- grab ogdl
    my $grab=undef
    my $grab_hash
    my $grab_key
    my $grab_indent
    my @grab

    DUMP_STUB import_file_init

# -----------------------------
subcode:: perfile_variables
    my $multi_line_comment_on

subcode: get_multiline_comment
    # multiline_comments, Note: we are more strict than the C comments. 
    $if $multi_line_comment_on
	$if $line=~/\*\/\s*$/
	    $multi_line_comment_on=0
	next
    $elif $line=~/^\s*\/\*/
	$multi_line_comment_on=1
	$if $line=~/\*\/\s*$/
	    $multi_line_comment_on=0
	next

subcode: get_indentation
    $if $line=~/^\s*$/
	$line="NOOP"
    $elif $line=~/^(\s*)(.*)/
	# get current indentation and stripping starting spaces
	my $indent=getindent($1)
	$line=$2
	$if $line=~/^#/
	    $line="NOOP"
	$else
	    # Trim the tail
	    $line=~s/\s+$//
	    # Tail # need spaces before and after!
	    $line=~s/\s+#\s.*$//
	$curindent=$indent

subcode: grab_block
    $if $grab
	$if $curindent>$grab_indent
	    my $i=$curindent-$grab_indent-1;
	    push @grab, "$i:$line";
	    next;
	$else
	    $if $grab eq "ogdl"
		my $ogdl=grab_ogdl($grab_key, \@grab)
		$if !$grab_hash->{$grab_key}
		    $grab_hash->{$grab_key}=$ogdl;
		$else
		    my $t=$grab_hash->{$grab_key}
		    $while my ($k, $v)=each %$ogdl
			$if !defined $t->{$k}
			    $t->{$k}=$v
		#print_ogdl($ogdl, 0)
	    undef $grab;
	    @grab=();

subcode: get_source_indent(curindent)
    $while $$(curindent)>$lastindent
	$lastindent++;
	push @$source, "SOURCE_INDENT";
subcode: get_source_dedent(curindent)
    $while $$(curindent)<$lastindent
	$lastindent--;
	push @$source, "SOURCE_DEDENT";

# --------------------------------------------------------
subcode:: perfile_variables
    my $source
    my $cur_codename
    my $code_prepend

subcode: start_subcode
    ### htmlcode, jscode, subcode, phpcode, fncode
    my $src_location="SOURCE: $cur_file - $cur_line";
    $source=[$src_location];
    $codeindent=$curindent+1;
    $lastindent=$codeindent;
    # -------------------
    $if $curindent == 0
	$stage='code'
	$cur_codename=$name
	undef $code_prepend

    $if $curindent==0 and $codes->{$name} and $codes->{$name}->{attr} ne "default"
	# ---- skip or append -------------
	$if $dblcolon eq "@"
	    # -- skip the default subcode
	$elif $dblcolon eq ":"
	    # -- append
	    $source=$codes->{$name}->{source}
	    push @$source, $src_location
	$elif $dblcolon eq "-"
	    # -- prepend
	    $code_prepend=1
	$elif $codes->{$name}->{attr} eq "optional"
	    # -- append and finalize
	    $codes->{$name}->{attr}=undef
	    $source=$codes->{$name}->{source}
	    push @$source, $src_location
	$elif $debug>1
	    # -- skip
	    print STDERR "overwiritten $type code: $name\n"
    $else
	# ---- new code or overwrite ----
	my @params;
	$if $t=~/\((.*)\)/
	    $t=$1;
	    @params=split /,\s*/, $t;
	my $t_code={'type'=>$type, 'source'=>$source, 'params'=>\@params, 'name'=>$name};
	$if $dblcolon eq "@"
	    $t_code->{attr}="default"
	$elif $dblcolon eq ":" or $dblcolon eq "-"
	    $t_code->{attr}="optional"

	$if $curindent == 0
	    $codes->{$name}=$t_code;
	$elif $stage eq 'page'
	    $if $page->{codes}->{$name} and ($name eq "main")
		$page->{codes}->{'main2'}=$t_code;
	    $else
		$page->{codes}->{$name}=$t_code;

subcode: end_subcode
    $if $code_prepend
	my $orig_source=$codes->{$cur_codename}->{source}
	push @$source, @$orig_source
	$codes->{$cur_codename}->{source}=$source

# --------------------------------------------------------
subcode: start_page
    my ($pagename, $maincode)
    # ---- name
    $if $t=~/([a-zA-Z0-9_\-\$]+),\s*(\w.*)/
	$pagename=$1;
	$maincode=$2;
    $elif $t=~/([a-zA-Z0-9_\-\$]+)/
	$pagename=$1;
    # ---- code
    my $code={};
    $if $maincode
	$code->{main}={'type'=>'sub', 'source'=>["\$call $maincode"], 'params'=>[]};

    $page={pagename=>$pagename, codes=>$code};
    $if $subpage
	$page->{subpage}=1;
    $call add_page
    $stage='page';

subcode: add_page
    # ---- insert into pages
    $if $pages->{$pagename}
	my $t=$pagename;
	my $j=0;
	$while $pages->{$pagename}
	    $j++;
	    $pagename=$t.$j;
    $pages->{$pagename}=$page;
    push @$pagelist, $pagename

subcode: process_fields
    $if $line=~/^optional:(.*)/
	my @tlist=split(/,/, $1);
	$foreach my $t in @tlist
	    $if $t=~/(\w+)/
		$if $def->{$stage}->{$1}
		    $def->{$stage}->{$1}->{optional}=1;
		$else
		    $def->{$stage}->{$1}={optional=>1};
    $elsif $curindent==1
	$if $line=~/^([a-zA-Z0-9-_]+):\s*(.*)$/
	    $if $def->{$stage}->{$1}
		$item=$def->{$stage}->{$1};
	    $else
		$item={};
		$def->{$stage}->{$1}=$item;
	    $if $2
		$item->{type}=$2;
		$item->{value}=$2;
		$item->{title}=$2;
    $elsif $line=~/^(\w+): (.*)/
	my $k=$1;
	my $v=$2;
	expand_macro(\$v, $macros);
	$if $item->{$k}
	    print STDERR " Denied overwriting $k with $v\n" if $debug>1;
	$else
	    $item->{$k}=$v;

subcode: process_macros
    $if $line=~/^(\w+): (.*\S)/
	my $k=$1;
	my $v=$2;
	$if $macros->{$k}
	    print STDERR " Overriden macro $k\n" if $debug>1;
	$else
	    my $t=$v;
	    expand_macro(\$t, $macros);
	    $macros->{$k}=$t;

subcode: process_page_macros
    $if $line=~/^source: (.*)/
	$page->{codes}->{main}={'type'=>"sub", 'source'=>["\$call $1"], 'params'=>[]};
    $elsif $line=~/^(\w+): (.*)/
	my $k=$1;
	my $v=$2;
	expand_macro(\$v, $macros);
	$page->{$k}=$v;

subcode: support_subs
    our @indent_stack=(0);
    $sub getindent
	use integer;
	my $s=shift;
	1 while $s=~s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
	my $i=length($s);
	if($i==$indent_stack[-1]){
	}
	elsif($i>$indent_stack[-1]){
	    push @indent_stack, $i;
	}
	else{
	    while($i<$indent_stack[-1]){
		pop @indent_stack;
	    }
	}
	
	return $#indent_stack;

    $sub expand_macro
	my ($lref, $macros)=@_;
	$while  $$lref=~/\$\(\w+\)/
	    my @segs=split /(\$\(\w+\))/, $$lref;
	    my $j=0;
	    my $flag=0;
	    $foreach my $s in @segs
		$if $s=~/\$\((\w+)\)/
		    my $t=$macros->{$1};
		    $if $t eq $s
			die "Looping macro $1 in \"$$lref\"!\n";
		    $if $t
			$segs[$j]=$t;
			$flag++;
		$j++;
	    $if $flag
		$$lref=join '', @segs;
	    $else
		last;

    $sub get_lines
	my ($file, $var)=@_;

	my $filename="";
	$if -f $file
	    $filename=$file;
	$if !$filename and $var->{'include_path'}
	    my @dirs=split /:/, $var->{'include_path'};
	    $foreach my $dir in @dirs
		$if -f "$dir/$file"
		    $filename="$dir/$file";
		    last;
	$if !-f $filename
	    print "include_path: $var->{include_path}\n";
	    die "$file not found\n";
	#print STDERR "Parsing Definition File: $filename\n";
	open In, $filename or die "Can't open $file.\n";
	my @lines=<In>;
	close In;
	return \@lines;

subcode: load_standard_includes
    my @standard_includes;
    $if $var->{module} eq "php"
	push @standard_includes, "std_php.def";
    $elsif $var->{module} eq "c"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "xs"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "apple"
	push @standard_includes, "std_c.def";
    $elsif $var->{module} eq "win32"
	push @standard_includes, "std_c.def";
	push @standard_includes, "std_win32.def";

subcode: support_eachfile
    # Hack for the following work:
    #page: order$1
    #    output_dir: sales
    #    foreachfile: templates/order(*).php
    #    htmlcode: main
    #        $call basic_process
    #        $include templates/order$1.php

    $sub post_foreachfile
	my $def=shift;
	my $pages=$def->{pages};
	my $pagelist=$def->{pagelist}
	$while my ($name, $p)=each(%$pages)
	    $if $p->{foreachfile}
		my $pat_glob=$p->{foreachfile};
		my $pat_regex=$p->{foreachfile};
		my $n;
		$n=$pat_glob=~s/\(\*\)/\*/g;
		$pat_regex=~s/\(\*\)/\(\.\*\)/g;
		my @files=glob($pat_glob);
		$foreach my $f in @files
		    my @pat_list=($f=~/$pat_regex/);
		    dupe_page($def, $p, $n, @pat_list);
		delete $pages->{$name};

    $sub post_matchblock
	my $def=shift;
	my $codes=$def->{codes};
	my @codelist=keys(%$codes);
	$foreach $name in @codelist
	    $if $name=~/^pre_(\w+)/ and !$codes->{"post_$1"}
		my $loopname=$1;
		#print "Adding subcode post_$1\n";
		my $params=$codes->{$name}->{params};
		my $type=$codes->{$name}->{type};
		my $presource=$codes->{$name}->{source};
		my $source=[];
		my $t_code={'type'=>$type, 'source'=>$source, 'params'=>$params};
		$foreach $l in @$presource
		    $if $l=~/\$openfor/
			push @$source, "DEDENT }";
		$codes->{"post_$loopname"}=$t_code;

    $sub dupe_page
	my ($def, $orig, $n, @pat_list)=@_;
	my $pagename=dupe_line($orig->{pagename}, $n, @pat_list);
	print "    foreach file $pagename $n: ", join(",", @pat_list), "\n";
	my $page={};
	$while my ($k, $v)=each(%$orig)
	    $if $k eq "pagename"
		$page->{pagename}=$pagename;
	    $elif $k eq "codes"
		my $codes={};
		$while my ($tk, $tv)=each(%$v)
		    my $tcode={};
		    $tcode->{type}=$tv->{type};
		    $tcode->{params}=$tv->{params};
		    my @source;
		    my $tsource=$tv->{source};
		    $foreach $l in @$tsource
			push @source, dupe_line($l, $n, @pat_list);
		    $tcode->{source}=\@source;
		    $codes->{$tk}=$tcode;
		$page->{codes}=$codes;
	    $elif $k ne "foreachfile"
		$page->{$k}=dupe_line($v);

	my $pages=$def->{pages};
	my $pagelist=$def->{pagelist}
	$call add_page

    $sub dupe_line
	my ($l, $n, @pat_list)=@_;
	$for my $i=1; $i<=$n; $i++
	    $rep=$pat_list[$i-1];
	    $l=~s/\$$i/$rep/g;
	return $l;

# ---------------------------------------------------
subcode: compile_perlcode
    my $pages=$def->{pages}
    my $pagelist=$def->{pagelist}
    my $codes=$def->{codes}

    my @perlcode_list;
    $while my ($name, $code)= each %$codes
	$if $code->{type} eq "perl"
	    $if $name ne "perl_global"
		push @perlcode_list, $name

    $if @perlcode_list
	my $maincode=[];
	my $page={pagename=>"perl-$defname", module=>"perl", type=>"pl", codes=>{main=>{type=>'sub', source=>$maincode, params=>[]}}};

	push @$maincode, "\$call \@perl_global"
	push @$maincode, "my (\$subname, \@alist)=\@ARGV"
	$foreach $name in @perlcode_list
	    push @$maincode, "\$if \$subname eq \"$name\""
	    push @$maincode, "SOURCE_INDENT"
	    push @$maincode, "\$call $name"
	    push @$maincode, "SOURCE_DEDENT"

	push @$pagelist, "perl-$defname"
	$pages->{"perl-$defname"}=$page


