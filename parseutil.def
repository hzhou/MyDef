include: macros_parse/indentation.def
include: macros_parse/subcode.def
include: macros_parse/template.def
include: macros_parse/debug.def
include: macros_util/path.def
include: macros_util/ogdl.def
include: macros_util/debug.def
include: perl/indentations.def

include: macros_parse/hacks.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::parseutil
    subcode: main
        $global $debug=0
        # $call support_subs
        1;

#---------------------------------------- 
fncode: import_data($file)
    my $def={"resource"=>{}, 
            "pages"=>{}, 
            "pagelist"=>[],
            "codes"=>{}, 
            "macros"=>{},
            };

    # -------- file stat -------------
    $if $file=~/([^\/]+)\.def/
        $def->{name}=$1
        $def->{file}=find_file($file)
    $else
        $def->{name}="default"

    # -------- global macros from config ---------
    my $macros=$def->{macros}
    $while my ($k, $v)=each %$MyDef::var
        $if $k=~/macro_(\w+)/
            $macros->{$1}=$v;
    # -------- include files ---------
    my @includes;
    my %includes;

    # -----------------------------------------------
    import_file($file, $def, \@includes,\%includes, "main")
    $call load_standard_includes
    $while 1
        $if @includes
            my $file=shift(@includes)
            import_file($file, $def, \@includes,\%includes, "include")
        $elif @standard_includes
            my $file=shift(@standard_includes)
            import_file($file, $def, \@includes,\%includes, "standard_include")
        $else
            last

    # ---- End of Parsing ---------------------------
    $call @post_parsing
    $if $debug
        $foreach $k in keys %$debug
            $if $k eq "def"
                debug_def($def)
            $elif $k=~/^code:\s*(\w+)/
                debug_code($def->{codes}->{$1})
    return $def;

fncode: import_file($f, $def, $include_list, $include_hash, $file_type)
    # $print import_file [$f]
    #---- import a single def file, update include_list -----
    # ---------------------
    $call @import_file_init
    my $plines=get_lines($f);
    # Insert an END to flush all the indentations
    # Empty "END" stage gets ignored by default
    push @$plines, "END"
    my $cur_file=$f
    my $cur_line=0
    &call parse_loop
        $call get_multiline_comment
        $call get_indentation  # and skip comments, trim leading and tailing spaces

        $call check_end_codeindent

        $if $(in_code)
            $call get_source_indent, $curindent
            $call get_source_dedent, $curindent
        # -------------------------------
        $if $line=~/^\w+code:/ && $(top_scope)
            $call check_end_automain
            $call subcode_start
            $call start_code_indent, code, $curindent+1, $t_code
        $elif $line=~/^macros:/ && $(top_scope)
            $call macros_start
            $call start_code_indent, macro, $curindent+1, $macros
        $elif $line=~/^template:/ && $(top_scope)
            $call check_end_automain
            $call grab_template
        $elif $(in_code)
            push @$source, $line
        $elif $(in_macro)
            $call process_macros
        $elif $curindent==0
            $call @parse_level_0
        $elif $(in_page)
            $if $line=~/^(\w+):\s*(.*)/
                $call process_page_macros
            $elif $line=~/^\s*$/
                next
            $else
                # $print jump_to_main_code [$line]
                $call jump_to_main_code

#---------------------------------------- 
subcode: parse_loop
    # sub-used in parsing multi-line comments and grabing templates/resources
    $(allow_recurse:2)
    $while $cur_line < @$plines
        my $line = $plines->[$cur_line]
        $cur_line++
        BLOCK

#---------------------------------------- 
subcode: parse_level_0
    $if $line=~/^include:? (.*)/
        $if !$include_hash->{$1}
            $if $1 ne "noconfig"
                push @$include_list, $1;
            $include_hash->{$1}=1;
            #print STDERR "    include $1\n";
    $elif $line=~/^path:\s*(.+)/
        add_path($1)
    $elif $line=~/^(sub)?page:\s*(.*)/
        my ($subpage, $t)=($1, $2)
        $call start_page
        $call start_code_indent, page, 1, $page
    $elif $line=~/^resource:\s+(\w+)(.*)/
        $call grab_resource
    $elif $line=~/^DEBUG\s*(.*)/
        $if $1
            $debug->{$1}=1
        $else
            $debug->{def}=1

#---------------------------------------- 
subcode: get_multiline_comment
    # multiline_comments, Note: we are more strict than the C comments. 
    $if $line=~/^\s*\/\*/
        $if $line !~ /\*\/\s*$/
            &call parse_loop
                $if $line=~/\*\/\s*$/
                    last
        next

subcode: get_indentation
    $if $line=~/^\s*$/
        # sometime empty lines are significant, passes on, where compileutil will filter
        $line=""
    $elif $line=~/^(\s*)(.*)/
        # get current indentation and stripping starting spaces
        my $indent=get_indent($1)
        $line=$2
        $if $line=~/^#(?!(define|undef|include|line|error|pragma|if|ifdef|ifndef|elif|else|endif)\b)/
            $if $indent != $curindent
                $line="NOOP"
            $else
                next
        $else
            # Trim the tail
            $line=~s/\s+$//
            # Tail # need spaces before and after!
            $line=~s/\s+#\s.*$//
        $curindent=$indent

subcode: grab_resource
    my $grab
    $if $def->{resource}->{$1}
        $grab=$def->{resource}->{$1}
    $else
        $grab={"_list"=>[], "_name"=>$1}
        $def->{resource}->{$1}=$grab
    my $t=$2
    $if $t=~/^\s*,\s*(.*)/
        my @tlist=split /,\s*/, $1
        $grab->{"_parents"}=\@tlist

    #----------------------------------------------- 
    my $grab_indent=$curindent
    my @grab
    &call parse_loop
        $call get_indentation
        $if $curindent>$grab_indent
            my $i=$curindent-$grab_indent-1;
            push @grab, "$i:$line";
        $else
            grab_ogdl($grab, \@grab)
            #print_ogdl($grab, 0)
            last
    $cur_line--

subcode: grab_template
    $if !$codeitem->{codes}
        $codeitem->{codes}={}
    my $codes = $codeitem->{codes}

    $if $line =~ /^template:\s*(\w+)/
        my @grab
        my $t_code = {type=>"template",source=>\@grab}
        $codes->{$1}=$t_code

        my $grab_indent=$curindent
        &call parse_loop
            $call get_indentation
            $if $line eq ""
                push @grab, $line
            $elif $curindent>$grab_indent
                push @grab, '    'x($curindent-$grab_indent-1) . $line
            $else
                last
    $cur_line--

# --------------------------------------------------------
subcode: start_page
    my ($pagename, $framecode)
    # ---- name
    $if $t=~/([a-zA-Z0-9_\-\$]+),\s*(\w.*)/
        $pagename=$1;
        $framecode=$2;
    $elif $t=~/([a-zA-Z0-9_\-\$]+)/
        $pagename=$1;
    # ---- code
    my $codes={};

    $global $page
    $page={pagename=>$pagename, codes=>$codes, main_name=>"main"};

    $if $framecode
        $if $framecode=~/^from\s+(\S+)/
            #-- $lines defines a template subcode: TMP_##
            #--    ... and sets the main code to call it
            my $lines = parse_template($def, $codes, $1)
            push @$include_list, $lines
            #- 
            $page->{main_name}="main2"
        $else
            #-- $framecode may include parameters
            $codes->{main}={'type'=>'sub', 'source'=>["\$call $framecode"], 'params'=>[]};
            $page->{main_name}="main2"

    $if $subpage
        $page->{subpage}=1;
    $if $file_type eq "main"
        $call add_page

subcode: add_page
    # ---- insert into pages
    $if $pages->{$pagename}
        my $t=$pagename;
        my $j=0;
        $while $pages->{$pagename}
            $j++;
            $pagename=$t.$j;
    $pages->{$pagename}=$page;
    push @$pagelist, $pagename

#---- macros ------------------------------------ 
subcode: macros_start
    $if !$codeitem->{macros}
        $codeitem->{macros}={}
    $macros = $codeitem->{macros}

subcode: process_macros
    $if $line=~/^(\w+):(:)?\s*(.*\S)/
        my ($k,$dblcolon, $v)=($1, $2, $3)
        expand_macro(\$v, $macros);
        $if $macros->{$k}
            $if $dblcolon
                $macros->{$k}.=", $v"
            $elif $debug
                $print "Denied overwriting macro $k"
        $else
            $macros->{$k}=$v

subcode: process_page_macros
    my $k=$1;
    my $v=$2;
    expand_macro(\$v, $macros);
    $page->{$k}=$v;

#---------------------------------------- 
fncode: expand_macro($lref, $macros)
    $while  $$lref=~/\$\(\w+\)/
        my @segs=split /(\$\(\w+\))/, $$lref;
        my $j=0;
        my $flag=0;
        $foreach my $s in @segs
            $if $s=~/\$\((\w+)\)/
                my $t=$macros->{$1};
                $if $t eq $s
                    die "Looping macro $1 in \"$$lref\"!\n";
                $if $t
                    $segs[$j]=$t;
                    $flag++;
            $j++;
        $if $flag
            $$lref=join '', @segs;
        $else
            last;

#---------------------------------------- 
subcode: load_standard_includes
    my @standard_includes
    $if $MyDef::var->{'include'} and !$includes{"noconfig"}
        push @standard_includes, split(/[:,]\s*/, $MyDef::var->{'include'})

    my $stdinc="std_".$MyDef::var->{module}.".def"
    push @standard_includes, $stdinc

#---- utils ------------------------------------ 
fncode: get_lines($file)
    $if ref($file) eq "ARRAY"
        return $file
    $elif $file eq "-pipe"
        my @lines=<STDIN>
        return \@lines
    $else
        my $filename=find_file($file)
        $call get_file_lines, $filename
        return \@lines;

