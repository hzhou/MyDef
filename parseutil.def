include: macros_parse/indentation.def
include: macros_parse/macros.def
include: macros_parse/subcode.def
include: macros_parse/template.def

include: macros_parse/hacks.def
include: macros_parse/debug.def

include: macros_util/path.def
include: macros_util/ogdl.def
include: macros_util/debug.def
include: perl/indentations.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::parseutil

    1;

#---------------------------------------- 
fncode: import_data($file)
    my $def={"resource"=>{}, 
            "pages"=>{}, 
            "pagelist"=>[],
            "codes"=>{}, 
            "macros"=>{},
            };

    # -------- file stat -------------
    $if $file=~/([^\/]+)\.def/
        $def->{name}=$1
        $def->{file}=find_file($file)
    $else
        $def->{name}="default"

    $call @parse_init

    # -----------------------------------------------
    import_file($file, $def, "main")
    $call load_standard_includes
    $while 1
        $if @includes
            my $file=shift(@includes)
            import_file($file, $def, "include")
        $elif @standard_includes
            my $file=shift(@standard_includes)
            import_file($file, $def, "standard_include")
        $else
            last
    $if $in_default_page
        $call check_default_page_framecode

    # ---- End of Parsing ---------------------------
    $call @post_parsing
    return $def;

fncode: import_file($f, $def, $file_type)
    $call @debug_import
    #---- import a single def file, update @include-----
    my $plines=get_lines($f);
    $if !$plines
        return
    # Insert an END to flush all the indentations
    push @$plines, "END"
    $call @import_file_init
    $if $file_type eq "main"
        $call start_default_page
        $call parse_default_page_macros
    &call parse_loop
        $call parse
    $if $file_type eq "main"
        $call add_default_page

    subcode: parse
        $call get_multiline_comment
        $call get_indentation  # and skip comments, trim leading and tailing spaces
        $call check_end_codeindent

        $if $(in_code)
            $call get_source_indent, $curindent
            $call update_source_pos
            $call get_source_dedent, $curindent
        # -------------------------------
        $if $line=~/^\w+code:/ && $(top_scope)
            $call subcode_start
            $call start_code_indent, code, $curindent+1, $t_code
        $elif $line=~/^macros:/ && $(top_scope)
            $call macros_start
            $call start_code_indent, macro, $curindent+1, $macros
        $elif $line=~/^template:/ && $(top_scope)
            $call grab_template
        $elif $curindent==0 and $line=~/^include:? (.*)/
            $call add_include, $1
        $elif $curindent==0 and $line=~/^(sub)?page:\s*(.*)/
            my ($subpage, $t)=($1, $2)
            $call start_page
            $call start_code_indent, page, 1, $page
            $if $subpage
                $page->{subpage}=1;
        $elif $curindent==0 and $line=~/^DEBUG\s*(.*)/
            parse_DEBUG($1)
        $elif $(in_code)
            push @$source, $line
        $elif $(in_macro)
            $call process_macros
        $elif $(in_page)
            $if !$page->{_got_code} and $line=~/^(\w+):\s*(.*)/
                $call process_page_macros
            $elif $line=~/^\s*$/
                $page->{_got_code}=1
                next
            $else
                $page->{_got_code}=1
                $call jump_to_main_code

    subcode: parse_loop
        # sub-used in parsing multi-line comments and grabing templates/resources
        $(allow_recurse:2)
        $while $cur_line < @$plines
            my $line = $plines->[$cur_line]
            $cur_line++
            BLOCK

subcode: parse_default_page_macros
    $while $plines->[$cur_line]=~/^(\w+):\s*(.*)/
        $if $1 =~ /^(page|macros|\w+code|template)$/
            last
        $elif $1 eq "include"
            $call add_include, $2
        $else
            $page->{$1}=$2
        $cur_line++

#---------------------------------------- 
subcode: start_page
    my ($pagename, $framecode)
    # ---- name
    $if $t=~/([\w\-\$\.]+),\s*(\w.*)/
        $pagename=$1;
        $framecode=$2;
        $if $framecode=~/^from\s+(\S+)/
            $framecode = parse_template($def, $1)
    $elif $t=~/([\w\-\$\.]+)/
        $pagename=$1;
    # ---- code
    my $codes={};

    $global $page
    $call @abort_default_page
    $page={_pagename=>$pagename, codes=>$codes};

    $if $pagename=~/(.+)\.(.+)/
        $page->{type}=''

    $if $framecode
        $page->{_frame}=$framecode

    $if $file_type eq "main"
        $call add_page

#---------------------------------------- 
subcode: start_default_page
    $global $in_default_page
    $global $page
    $page={_pagename=>$def->{name}, codes=>{}};
    $in_default_page = $page
    $call add_main_code
    $call start_code_indent, code, 0, $t_code
    $codetype   = "code"
    $codeindent = 0
    $curindent = 0
    $lastindent = 0

subcode: abort_default_page
    undef $in_default_page
    @indent_stack = ()
    # assert @indent_stack == 1

subcode: add_default_page
    $if $in_default_page
        my $pagename = $def->{name}
        $def->{pages}->{$pagename} = $in_default_page
        push @{$def->{pagelist}}, $pagename
        $def->{in_default_page}=1

subcode: check_default_page_framecode
    $if $def->{codes}->{basic_frame}
        $in_default_page->{_frame}="basic_frame"

#---------------------------------------- 
#-- used here and macros_parse/hacks.def: dupe_page
subcode: add_page
    # ---- insert into pages
    $call @check_duplicate
    $pages->{$pagename}=$page;
    push @$pagelist, $pagename

    subcode: check_duplicate
        $if $pages->{$pagename}
            my $t=$pagename;
            my $j=0;
            $while $pages->{$pagename}
                $j++;
                $pagename=$t.$j;

#---------------------------------------- 
subcode:: import_file_init
    my $cur_file=$f
    my $cur_line=0
    my $line_skipped=0

subcode: get_multiline_comment
    # multiline_comments, Note: we are more strict than the C comments. 
    $if $line=~/^\s*\/\*/
        $if $line !~ /\*\/\s*$/
            &call parse_loop
                $if $line=~/\*\/\s*$/
                    last
        $line_skipped=1
        next

subcode: get_indentation
    $if $line=~/^\s*$/
        # sometime empty lines are significant, passes on, where compileutil will filter
        $line=""
    $elif $line=~/^(\s*)(.*)/
        # get current indentation and stripping starting spaces
        my $indent=get_indent($1)
        $line=$2
        $if $line=~/^#(?!(define|undef|include|line|error|pragma|if|ifdef|ifndef|elif|else|endif)\b)/
            # Leading # with exclusions
            $if $line=~/^#\\n/
                $line="NEWLINE"
            $elif $indent != $curindent
                $line="NOOP"
            $else
                $line_skipped=1
                next
        $else
            # Trim the tail
            $line=~s/\s+$//
            # Tail # need spaces before and after!
            $line=~s/\s+#\s.*$//
        $curindent=$indent

subcode: grab_template
    $call get_parent, codes

    my @grab
    my $t_code = {type=>"template",source=>\@grab}
    $if $line =~ /^template:\s*(\w+)/
        $codes->{$1}=$t_code
    $else
        warn "parseutil: template missing name\n"

    my $grab_indent=$curindent
    &call parse_loop
        $call get_indentation
        $if $line eq ""
            push @grab, $line
        $elif $curindent>$grab_indent
            push @grab, '    'x($curindent-$grab_indent-1) . $line
        $else
            last
    $cur_line--

#---- includes ------------------------------------ 
subcode: _autoload
    $call dbl_list, includes

subcode: add_include(t)
    $if $(t) eq "noconfig"
        # skip config, see below
        $includes{$(t)}=1
    $elif substr($(t), -1) eq "/"
        add_path($(t))
    $else
        $call dbl_push, includes, $(t)

subcode: load_standard_includes
    my $module = $MyDef::var->{module}

    my @standard_includes
    $if $MyDef::var->{'include'} and !$includes{"noconfig"}
        push @standard_includes, split(/[:,]\s*/, $MyDef::var->{'include'})

    my $stdinc="std_$module.def"
    push @standard_includes, $stdinc

#---- utils ------------------------------------ 
fncode: get_lines($file)
    $if ref($file) eq "ARRAY"
        return $file
    $elif $file eq "-pipe"
        my @lines=<STDIN>
        return \@lines
    $else
        my $filename=find_file($file)
        $if $filename
            $call get_file_lines, $filename
            return \@lines;
        return undef

