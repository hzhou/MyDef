include: macros_parse/indentation.def
include: macros_parse/subcode.def
include: macros_parse/debug.def
include: macros_util/ogdl.def
include: macros_util/debug.def
include: perl/indentations.def

page: parseutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::parseutil
    subcode: main
	$global $debug=0
	# $call support_subs
	$call support_eachfile
	$call support_ogdl
	1;

#---------------------------------------- 
fncode: import_data($file)
    $global $defname="default";
    $if $file=~/([^\/]+)\.def/
        $defname=$1

    my $def={"resource"=>{}, 
            "pages"=>{}, 
            "pagelist"=>[],
            "codes"=>{}, 
            "macros"=>{},
            "defname"=>$defname,
            };

    # -------- global macros from config ---------
    $while my ($k, $v)=each %$MyDef::var
        $if $k=~/macro_(\w+)/
            $def->{macros}->{$1}=$v;
    # -------- include files ---------
    my @includes;
    my %includes;

    # -----------------------------------------------
    import_file($file, $def, \@includes,\%includes, "main")
    $call load_standard_includes
    $while 1
        $if my $file=shift(@includes)
            import_file($file, $def, \@includes,\%includes, "include")
        $elif my $file=shift(@standard_includes)
            import_file($file, $def, \@includes,\%includes, "standard_include")
        $else
            last

    # ---- End of Parsing ---------------------------
    post_foreachfile($def);
    post_matchblock($def);
    # $call compile_perlcode
    debug_def($def)
    return $def;

fncode: import_file($f, $def, $include_list, $include_hash, $file_type)
    # $print import_file [$f]
    #---- import a single def file, update include_list -----
    # ---------------------
    $call @import_file_init
    my $plines=get_lines($f);
    # Insert an END to flush all the indentations
    # Empty "END" stage gets ignored by default
    push @$plines, "END"
    my $cur_file=$f
    my $cur_line=0
    &call parse_loop
        $call get_multiline_comment
        $call get_indentation  # and skip comments, trim leading and tailing spaces

        $call check_end_indent

        # -------------------------------
        $if $line=~/^\w+code:/ && $(top_scope)
            $call subcode_start
            $call start_code_indent, code, $curindent+1, $t_code
        $elif $line=~/^macros:/ && $(top_scope)
            $call macros_start
            $call start_code_indent, macro, $curindent+1, $macros
        $elif $(in_code)
            $call get_source_indent, curindent
            $call get_source_dedent, curindent
            push @$source, $line
        $elif $(in_macro)
            $call process_macros
        $elif $curindent==0
            $call @parse_level_0
        $elif $(in_page)
            $if $line=~/^(\w+):\s*(.*)/
                $call process_page_macros
            $else
                $print jump_to_main_code [$line]
                $call jump_to_main_code

#---------------------------------------- 
subcode: parse_loop
    $(allow_recurse:2)
    $while $cur_line < @$plines
        my $line = $plines->[$cur_line]
        $cur_line++
        BLOCK

#---------------------------------------- 
subcode: parse_level_0
    $if $line=~/^include:? (.*)/
        $if !$include_hash->{$1}
            $if $1 ne "noconfig"
                push @$include_list, $1;
            $include_hash->{$1}=1;
            #print STDERR "    include $1\n";
    $elif $line=~/^(sub)?page: (.*)/
        my ($subpage, $t)=($1, $2)
        $call start_page
        $call start_code_indent, page, 1, $page
    $elif $line=~/^resource:\s+(\w+)(.*)/
        $call grab_resource

#---------------------------------------- 
subcode: get_multiline_comment
    # multiline_comments, Note: we are more strict than the C comments. 
    $if $line=~/^\s*\/\*/
        $if $line !~ /\*\/\s*$/
            &call parse_loop
                $if $line=~/\*\/\s*$/
                    last
        next

subcode: get_indentation
    $if $line=~/^\s*$/
        # sometime empty lines are significant, passes on, where compileutil will filter
	$line=""
    $elif $line=~/^(\s*)(.*)/
	# get current indentation and stripping starting spaces
	my $indent=get_indent($1)
	$line=$2
	$if $line=~/^#(?!(define|undef|include|line|error|pragma|if|ifdef|ifndef|elif|else|endif)\b)/
	    $if $indent != $curindent
		$line="NOOP"
	    $else
		next
	$else
	    # Trim the tail
	    $line=~s/\s+$//
	    # Tail # need spaces before and after!
	    $line=~s/\s+#\s.*$//
	$curindent=$indent

subcode: grab_resource
    my $grab
    $if $def->{resource}->{$1}
        $grab=$def->{resource}->{$1}
    $else
        $grab={"_list"=>[], "_name"=>$1}
        $def->{resource}->{$1}=$grab
    my $t=$2
    $if $t=~/^\s*,\s*(.*)/
        my @tlist=split /,\s*/, $1
        $grab->{"_parents"}=\@tlist

    #----------------------------------------------- 
    my $grab_indent=$curindent
    my @grab
    &call parse_loop
        $call get_indentation
        $if $curindent>$grab_indent
            my $i=$curindent-$grab_indent-1;
            push @grab, "$i:$line";
        $else
            grab_ogdl($grab, \@grab)
            #print_ogdl($grab, 0)
    $cur_line--


# --------------------------------------------------------
subcode:: import_file_init
    my $page

subcode: start_page
    my ($pagename, $maincode)
    # ---- name
    $if $t=~/([a-zA-Z0-9_\-\$]+),\s*(\w.*)/
	$pagename=$1;
	$maincode=$2;
    $elif $t=~/([a-zA-Z0-9_\-\$]+)/
	$pagename=$1;
    # ---- code
    my $code={};
    $if $maincode
	$code->{main}={'type'=>'sub', 'source'=>["\$call $maincode"], 'params'=>[]};

    $page={pagename=>$pagename, codes=>$code};
    $if $subpage
	$page->{subpage}=1;
    $if $file_type eq "main"
	$call add_page

subcode: add_page
    # ---- insert into pages
    $if $pages->{$pagename}
	my $t=$pagename;
	my $j=0;
	$while $pages->{$pagename}
	    $j++;
	    $pagename=$t.$j;
    $pages->{$pagename}=$page;
    push @$pagelist, $pagename

#---- macros ------------------------------------ 
subcode:: import_file_init
    my $macros

subcode: macros_start
    $if !$codeitem->{macros}
        $codeitem->{macros}={}
    $macros = $codeitem->{macros}

subcode: process_macros
    $if $line=~/^(\w+):(:)?\s*(.*\S)/
	my ($k,$dblcolon, $v)=($1, $2, $3)
	expand_macro(\$v, $macros);
	$if $macros->{$k}
	    $if $dblcolon
		$macros->{$k}.=", ", $v
	    $elif $debug
		$print "Denied overwriting macro $k"
	$else
	    $macros->{$k}=$v

subcode: process_page_macros
    my $k=$1;
    my $v=$2;
    expand_macro(\$v, $macros);
    $page->{$k}=$v;

#---------------------------------------- 
fncode: expand_macro($lref, $macros)
    $while  $$lref=~/\$\(\w+\)/
        my @segs=split /(\$\(\w+\))/, $$lref;
        my $j=0;
        my $flag=0;
        $foreach my $s in @segs
            $if $s=~/\$\((\w+)\)/
                my $t=$macros->{$1};
                $if $t eq $s
                    die "Looping macro $1 in \"$$lref\"!\n";
                $if $t
                    $segs[$j]=$t;
                    $flag++;
            $j++;
        $if $flag
            $$lref=join '', @segs;
        $else
            last;

#---------------------------------------- 
subcode: load_standard_includes
    my @standard_includes
    $if $MyDef::var->{'include'} and !$includes{"noconfig"}
        push @standard_includes, split(/[:,]\s*/, $MyDef::var->{'include'})

    my $stdinc="std_".$MyDef::var->{module}.".def"
    push @standard_includes, $stdinc

subcode: support_eachfile
    # Hack for the following work:
    #page: order$1
    #    output_dir: sales
    #    foreachfile: templates/order(*).php
    #    htmlcode: main
    #        $call basic_process
    #        $include templates/order$1.php

    $sub post_foreachfile
	my $def=shift;
	my $pages=$def->{pages};
	my $pagelist=$def->{pagelist}
	$while my ($name, $p)=each(%$pages)
	    $if $p->{foreachfile}
		my $pat_glob=$p->{foreachfile};
		my $pat_regex=$p->{foreachfile};
		my $n;
		$n=$pat_glob=~s/\(\*\)/\*/g;
		$pat_regex=~s/\(\*\)/\(\.\*\)/g;
		my @files=glob($pat_glob);
		$foreach my $f in @files
		    my @pat_list=($f=~/$pat_regex/);
		    dupe_page($def, $p, $n, @pat_list);
		delete $pages->{$name};

    $sub post_matchblock
	my $def=shift;
	my $codes=$def->{codes};
	my @codelist=keys(%$codes);
	$foreach $name in @codelist
	    $if $name=~/^pre_(\w+)/ and !$codes->{"post_$1"}
		my $loopname=$1;
		#print "Adding subcode post_$1\n";
		my $params=$codes->{$name}->{params};
		my $type=$codes->{$name}->{type};
		my $presource=$codes->{$name}->{source};
		my $source=[];
		my $t_code={'type'=>$type, 'source'=>$source, 'params'=>$params};
		$foreach $l in @$presource
		    $if $l=~/\$openfor/
			push @$source, "DEDENT }";
		$codes->{"post_$loopname"}=$t_code;

    $sub dupe_page
	my ($def, $orig, $n, @pat_list)=@_;
	my $pagename=dupe_line($orig->{pagename}, $n, @pat_list);
	print "    foreach file $pagename $n: ", join(",", @pat_list), "\n";
	my $page={};
	$while my ($k, $v)=each(%$orig)
	    $if $k eq "pagename"
		$page->{pagename}=$pagename;
	    $elif $k eq "codes"
		my $codes={};
		$while my ($tk, $tv)=each(%$v)
		    my $tcode={};
		    $tcode->{type}=$tv->{type};
		    $tcode->{params}=$tv->{params};
		    my @source;
		    my $tsource=$tv->{source};
		    $foreach $l in @$tsource
			push @source, dupe_line($l, $n, @pat_list);
		    $tcode->{source}=\@source;
		    $codes->{$tk}=$tcode;
		$page->{codes}=$codes;
	    $elif $k ne "foreachfile"
		$page->{$k}=dupe_line($v);

	my $pages=$def->{pages};
	my $pagelist=$def->{pagelist}
	$call add_page

    $sub dupe_line
	my ($l, $n, @pat_list)=@_;
	$for my $i=1; $i<=$n; $i++
	    my $rep=$pat_list[$i-1];
	    $l=~s/\$$i/$rep/g;
	return $l;

# ---------------------------------------------------
subcode: compile_perlcode
    my $pages=$def->{pages}
    my $pagelist=$def->{pagelist}
    my $codes=$def->{codes}

    my @perlcode_list;
    $while my ($name, $code)= each %$codes
	$if $code->{type} eq "perl"
	    $if $name ne "perl_global"
		push @perlcode_list, $name

    $if @perlcode_list
	my $maincode=[];
	my $page={pagename=>"perl-$defname", module=>"perl", type=>"pl", codes=>{main=>{type=>'sub', source=>$maincode, params=>[]}}};

	push @$maincode, "\$call \@perl_global"
	push @$maincode, "my (\$subname, \@alist)=\@ARGV"
	$foreach $name in @perlcode_list
	    push @$maincode, "\$if \$subname eq \"$name\""
	    push @$maincode, "SOURCE_INDENT"
	    push @$maincode, "\$call $name"
	    push @$maincode, "SOURCE_DEDENT"

	push @$pagelist, "perl-$defname"
	$pages->{"perl-$defname"}=$page


#---- utils ------------------------------------ 
fncode: get_lines($file)
    $if $file eq "-pipe"
        my @lines=<STDIN>
        return \@lines
    $else
        my $filename="";
        $if -f $file
            $filename=$file;
        $if !$filename and $MyDef::var->{'include_path'}
            my @dirs=split /:/, $MyDef::var->{'include_path'};
            $foreach $dir in @dirs
                $if -f "$dir/$file"
                    $filename="$dir/$file";
                    last;
        $if !-f $filename
            warn "$file not found\n";
            warn "  search path: $MyDef::var->{'include_path'}\n"
        #print STDERR "Parsing Definition File: $filename\n";
        open In, $filename or die "Can't open $file.\n";
        my @lines=<In>;
        close In;
        return \@lines;

