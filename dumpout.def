include: macros_util/debug.def

page: dumpout
    type: pm
    output_dir: lib/MyDef
    package: MyDef::dumpout

    $sub dumpout
        my $dump=shift;
        my $f=$dump->{f};
        my $out=$dump->{out};
        my $custom=$dump->{custom};
        $if !$out
            die "missing \$out\n";
        $call dumpout
    # ---------------

    1;

#---------------------------------------- 
#----  dumpout: @$out --> @$f   ------
subcode: dumpout
    my @source_stack;

    my $indentation=0
    my @indentation_stack

    DUMP_STUB dumpout_init
    subcode: debug_dumpout
        $if $#$f <10
            $print dumpout $out: [$l]

    $while 1
        $if !@$out
            $out=pop @source_stack;
            $if !$out
                last;
            $else
                next;

        my $l=shift @$out;
        # $call @debug_dumpout
        $if $custom and $custom->($f, \$l)
            # custom dump -- used in output_www.def
        $elif $l =~/^INCLUDE_BLOCK (\S+)/
            push @source_stack, $out
            $out=$dump->{$1}
        $elif $l =~ /^DUMP_STUB\s+(\w+)/
            my $source=$MyDef::compileutil::named_blocks{$1};
            # $print "DUMP_STUB $1 : $source"
            # multiple DUMP_STUB with the same name is OK, only the first one will be in effect
            #    that is because we did "$l= shift @$out"
            $if $source
                push @source_stack, $out;
                $out=$source;
        $elif $l =~ /^DUMP_PERL\s+(\w+)/
            my $t = MyDef::compileutil::eval_sub($1)
            my $source = eval($t)
            $if $@
                $print eval error: [$@]
            $if $source
                push @source_stack, $out;
                $out=$source;
        $elif $l=~/^\s*(INDENT|DEDENT|PUSHDENT|POPDENT)\b(.*)/
            $if $1 eq "INDENT"
                $indentation++;
            $elif $1 eq "DEDENT"
                $indentation-- if $indentation;
            $elif $1 eq "PUSHDENT"
                push @indentation_stack, $indentation
                $indentation=0
            $elif $1 eq "POPDENT"
                $indentation=pop @indentation_stack

            $l=$2;
            $if $l=~/^\s*;?$/
                next;
            $else
                unshift @$out, $l;
                next;
        $elif $l=~/^\s*SOURCE_INDENT/
            $indentation++;
        $elif $l=~/^\s*SOURCE_DEDENT/
            $indentation-- if $indentation;
        $elif $l=~/^\s*BLOCK_(\d+)/
            push @source_stack, $out;
            $out=MyDef::compileutil::fetch_output($1);
        #$elif $l=~/^SCOPE:/
        $elif $l=~/^SUBBLOCK (BEGIN|END)/
            # messages from compileutil.pm
        $elif $l=~/^NOOP/
            # messages from compileutil.pm
        $call @support_make_string
        $elif $l =~/^(.*)=\s*\[(strings?)_from_file:\s*(\S+)\]\s*;/
            my ($head, $file, $type)=($1, $3, $2)
            $call string_from_file
        $else
            $call print_line

subcode: print_line
    $if $l=~/^\s*$/
        push @$f, "\n"
    $elif $l=~/^\s*NEWLINE\b/
        push @$f, "\n"
    $elif $l =~/^PRINT (.*)/
        push @$f, "    "x$indentation."$1\n"
    $elif $l =~/^\s*TAB (.*)/
        # hack for Makefile recipes
        push @$f, "\t$1\n"
    $else
        chomp $l
        push @$f, "    "x$indentation."$l\n"

#---------------------------------------- 
subcode: support_make_string
    # --- MAKE_STRING/POP_STRING: facilitate open gl programs
    #     additional messy support in compile/parse.def
    $elif $l=~/^MAKE_STRING:(.*)/
        $call start_make_string, $1
    $elif $l =~/^POP_STRING/
        $call pop_make_string
    $elif @make_string_stack
        $call print_line_string

    $(block:dumpout_init)
        my @make_string_stack
        my $string_list=undef

    subcode: start_make_string(line)
        $string_list=[]
        push @make_string_stack, {quote=>'"', join=>'\n', line=>$(line), list=>$string_list, indent=>$indentation}

    subcode: pop_make_string
        my $h=pop @make_string_stack
        $if !$h
            die "Error POP_STRING\n"
        $if @make_string_stack
            $string_list=$make_string_stack[-1]->{list}
        $else
            $string_list=undef

        my $l=$h->{line}
        my $join=''
        $if $l=~/\bSTRING\[([^\]]*)\]/
            $join=$1
            $l=~s/\bSTRING\[[^\]]*\]/STRING/g
            #-- ?: STRING[, ]word?
        my $t=join($join, @{$h->{list}})

        $if $l=~/"STRING"/
            $t=~s/"/\\"/g # avoid \"?

        $l=~s/\bSTRING\b/$t/
        $call print_line

    subcode: print_line_string
        $(set:indent=($indentation-$make_string_stack[-1]->{indent}-1))
        $if $l=~/^\s*$/
            # push @$f, "\n"
        $elif $l=~/^\s*NEWLINE\b/
            push @$string_list, ""
        $elif $l =~/^PRINT (.*)/
            push @$string_list, "    "x$(indent) . $1
        $else
            push @$string_list, "    "x$(indent) . $l

#---------------------------------------- 
subcode: string_from_file
    $if $dump->{module} eq "output_perl"
        push @$f, "$head = <<HERE;\n"
        &call open_r, $file
            push @$f, $_
        push @$f, "HERE\n"
    $elif $head=~/^\$/ and $dump->{module} eq "output_www"
        #-- php --
        push @$f, "$head = <<<HERE\n"
        &call open_r, $file
            push @$f, $_
        push @$f, "HERE;\n"
    $else
        my @t
        &call open_r, $file
            chomp
            s/\\/\\\\/g
            s/"/\\"/g
            push @t, $_
        push @$f, "    "x$indentation
        push @$f, "$head = "
        $if $type eq "string"
            push @$f, '"'
            $foreach $t in @t
                push @$f, "$t\\\n"
            push @$f, "\";\n"
        $elif $type eq "strings"
            # $if $dump->{module} eq "output_www"
            my $indent="    " x ($indentation+1)
            push @$f, "[\n"
            $foreach $t in @t
                push @$f, "$indent\"$t\",\n"
            push @$f, "$indent];\n"


