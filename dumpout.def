page: dumpout
    type: pm
    output_dir: lib/MyDef
    subcode: main
	$call dump_main

subcode: dump_main
    use MyDef::compileutil;

    package MyDef::dumpout;

    ################################
    # Function list
    #   maintain a function list so we can use OPEN_FUNC block structure
    my @func_list;
    my $func_index=-1;

    sub init_funclist {
	@func_list=();
	$func_index=-1;
    }
    sub add_function {
	my $func=shift;
	$func_index++;
	$func_list[$func_index]=$func;
	return $func_index;
    }

    sub get_func_list {
	return \@func_list;
    }

    sub get_func_index {
	return $func_index;
    }

    sub get_cur_func {
	return $func_list[$func_index];
    }

    ################################
    sub dumpout {
	my $dump=shift;
	my $f=$dump->{f};
	my $custom=$dump->{custom};
	my $out=$dump->{out};
	if(!$out){
	    die "missing \$out\n";
	}
	#print join("\n", @$out);

	my @source_stack;

	my $indentation=0;
	my @openblock;
	my @closeblock;
	my @preblock;
	my @postblock;
	my $blockstack=0;

	$custom->(\"DUMP_INIT", $dump);
	while(1){
	    my $l;
	    if(@$out){
		$l=shift @$out;
	    }
	    else{
		$out=pop @source_stack;
		if(!$out){
		    last;
		}
		else{
		    next;
		}
	    }
	    # print "[$blockstack]$l\n";
	    if($l =~ /DUMP_STUB\s+(\w+)/){
		my $source=$MyDef::compileutil::named_blocks{$1};
		if($source){
		    push @source_stack, $out;
		    $out=$source;
		}
	    }
	    elsif(!$l or my $r=$custom->(\$l, $dump)){
		if(ref($r) eq "ARRAY"){
		    push @source_stack, $out;
		    $out=$r;
		}
	    }
	    elsif($l=~/^\s*(INDENT|DEDENT)\b(.*)/){
		if($1 eq "INDENT"){
		    $indentation++;
		}
		elsif($1 eq "DEDENT"){
		    $indentation-- if $indentation;
		}
		$l=$2;
		if($l=~/^\s*;?$/){
		    next;
		}
		else{
		    unshift @$out, $l;
		    next;
		}
	    }
	    elsif($l=~/^\s*NEW_BLOCK/){
		push @openblock, [];
		push @preblock, [];
		push @postblock, [];
		push @closeblock, [];
		$blockstack=1;
	    }
	    elsif($l=~/^\s*(PRE|POST|OPEN|CLOSE)_BLOCK\s+(.*)/){
		my $t;
		if($1 eq "OPEN"){
		    $t=$openblock[-1];
		}
		elsif($1 eq "CLOSE"){
		    $t=$closeblock[-1];
		}
		elsif($1 eq "PRE"){
		    $t=$preblock[-1];
		}
		elsif($1 eq "POST"){
		    $t=$postblock[-1];
		}
		if($t){
		    push @$t, $2;
		}
		$blockstack=1;
	    }
	    elsif($l=~/^\s*SOURCE_INDENT/){
		if($blockstack==0){
		    push @openblock, [];
		    push @closeblock, [];
		    push @preblock, [];
		    push @postblock, [];
		}
		push @source_stack, $out;
		push @source_stack, pop(@preblock);
		$out=pop(@openblock);
		push @$out, "INDENT";
	    }
	    elsif($l=~/^\s*SOURCE_DEDENT/){
		push @source_stack, $out;
		push @source_stack, pop(@closeblock);
		$out=pop(@postblock);
		push @$out, "DEDENT";
	    }
	    elsif($l=~/^\s*BLOCK_(\d+)/){
		push @source_stack, $out;
		$out=MyDef::compileutil::fetch_output($1);
	    }
	    elsif($l=~/^\s*OPEN_FUNC_(\d+)/){
		my $func=$func_list[$1];
		push @openblock, $func->{openblock};
		push @closeblock, $func->{closeblock};
		push @preblock, $func->{preblock};
		push @postblock, $func->{postblock};
		$blockstack=1;
	    }
	    elsif($l=~/^SCOPE:/){
		# messages from compilutil.pm
	    }
	    else{
		print_line($l, $indentation, $f);
	    }

	    if($blockstack==1){
		$blockstack=2;
	    }
	    else{
		$blockstack=0;
	    }
	}
    }

    $sub print_line
	my ($line, $indentation, $f)=@_;
	$if $line=~/^\s*$/
	    push @$f, "\n"
	$elif $line =~/^\s*NEWLINE\s*$/
	    push @$f, "\n"
	$else
	    push @$f, "    "x$indentation;
	    push @$f, $line;
	    push @$f, "\n";

    # ---------------
    sub simple_block {
	my ($pre, $post, $out)=@_;
	push @$out, "$pre";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "$post";
	return "NEWBLOCK";
    }

    1;
