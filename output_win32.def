include: output.def
include: macros_c/cfunctions.def
include: macros_win32/resource.def

page: output_win32, output_main
    type: pm
    output_dir: lib/MyDef
    ext: c
    init_mode: sub
    subcode: package_subs
	$call package_global
	$call c_main
    subcode: init_page
	$call c_init
	global_add_var("cur_instance", "HINSTANCE")
    subcode: modeswitch
	$call c_modeswitch
    subcode: parsecode
	$call pre_parse
	$call check_text_includes
	$call c_parsecode
    subcode: dumpout
	push @$f, "#include <winsock2.h>\n";
	push @$f, "#include <windows.h>\n";
	# ----  Main Function -------------------
	my $func=$functions{"WinMain"};
	$if $func
	    $func->{skip_declare}=1;
	    $func->{ret_type}="int APIENTRY";
	    $func->{param_list}=["HINSTANCE hInst", "HINSTANCE hPrev", "LPSTR lpstr_cmdline", "int n_cmdshow"];
	    my $initblock=$func->{init}
	    push @$initblock, "cur_instance = hInst;"

	    $while my $wnd = shift @window_list
		register_window($wnd)
		push @$initblock, "register_$wnd();"
	    push @$initblock, "NEWLINE"
	    push @{$func->{init}}, "DUMP_STUB main_init";
	    push @{$func->{finish}}, "DUMP_STUB main_exit";
	    push @{$func->{finish}}, "return 0;";


	# ---- process_function ------------------------
	my $funclist=MyDef::dumpout::get_func_list()
	$foreach my $func in @$funclist
	    $call process_function_std

	# --- c global stuff -----------------
	unshift @$out, "DUMP_STUB global_init";
	$call c_dump_init

# ---------------------------
subcode: pre_parse
    $if $l=~/^\$MakeWindow\s+(\w+),\s*(\S+)/
	my ($name, $controller)=($1, $2)
	$call make_window
	return 1
    $elif $l=~/^\$LoadView\s+(\w+)/
	my ($name)=($1)
	$call load_view
	return 1
    $elif $l=~/^(\w+)\s*=\s*\$MakeMenu\s+(\w+)/
	my ($var, $name)=($1, $2)
	$call load_menu
	return 1;
    $elif $l=~/^(\w+)\s*=\s*\$MakeFont\s+(.*)/
	my ($var, $spec)=($1, $2);
	$call make_font
	return 1;
    $elif $l=~/\$hgdi_enable/
	hgdi_enable();
	return

subcode:: package_global
    my %var_retain_hash;

subcode:: support_subs
    # ---------------------------
    sub hgdi_enable {
	$misc_vars{hgdi_enable}=1;
	push @func_var_hooks, {var_check=>\&is_hgdi_type, var_init=>\&hgdi_var_init, var_pre_assign=>\&hgdi_pre_assign, var_post_assign=>\&hgdi_post_assign, var_release=>\&hgdi_release};
    }

    sub is_hgdi_type {
	my $type=shift;
	return ($type=~/^H(FONT|PEN|BRUSH|RGN|FONT|BITMAP|PALETTE|GDIOBJ)$/);
    }
    sub hgdi_var_init{
	my ($v, $type)=@_;
	$var_retain_hash{$v}=0;
	return "NULL";
    }
    sub hgdi_release{
	my ($type, $name, $func, $out)=@_;
	if($name=~/(\w+)\[(.*)\]/){
	    push @$out, "for(i=0;i<$2;i++){";
	    push @$out, "    if($1\[i]){";
	    push @$out, "        hgdi_release($1\[i]);";
	    push @$out, "    }";
	    push @$out, "}";
	}
	elsif(is_hgdi_type($type)){
	    if($var_retain_hash{$name}){
		push @$out, "if($name){";
		push @$out, "INDENT";
		push @$out, "hgdi_release($name);";
		push @$out, "DEDENT";
		push @$out, "}";
	    }
	}
    }
    sub hgdi_pre_assign{
	my ($type, $name, $val, $out)=@_;
	if($name=~/(\w+)\[(.*)\]/){
	    push @$out, "if($name){hgdi_release($name);}";
	}
	elsif(is_hgdi_type($type)){
	    if($var_retain_hash{$vname}){
		push @$out, "if($name){hgdi_release($name);}";
		$var_retain_hash{$name}=0;
	    }
	    if($val=~/\w+\(/){
		$var_retain_hash{$name}=1;
	    }
	}
    }
    sub hgdi_post_assign{
	my ($type, $name, $val, $out)=@_;
	if($name=~/(\w+)\[(.*)\]/){
	    push @$out, "if($name){hgdi_retain($name);}";
	}
	elsif(is_hgdi_type($type)){
	    if($val=~/^\s*(NULL|0)\s*$/i){
	    }
	    else{
		$var_retain_hash{$name}=1;
		push @$out, "if($name){";
		push @$out, "    hgdi_retain($name);";
		push @$out, "}";
	    }
	}
    }
