include: macros_util/parse_regex.def

page: utils
    type: pm
    output_dir: lib/MyDef
    package: MyDef::utils
    subcode: main
        1;

#----------------------------------------------
#-- proper_split($param) 
#-- expand_macro($line, $sub) 
#-- uniq_name($name, hash)

#-------------------------------------------------
fncode: proper_split($param)
    my @tlist
    $if $param eq "0"
        return (0)
    $elif !$param
        return @tlist
    # print "proper_split [$param]\n"
    my @closure_stack
    my $t
    &call parse_loop, $param
        &call if_lex, (\s+)
            $if $t or @closure_stack
                $t.=$1
            $else
                #-skip
        $elif $param=~/\G(,)/gc
            $if @closure_stack
                $t.=$1
            $else
                push @tlist, $t
                undef $t
        $elif $param=~/\G([^"'\(\[\{\)\]\},]+)/gc
            $t.=$1
        $elif $param=~/\G("([^"\\]|\\.)*")/gc
            $t.=$1
        $elif $param=~/\G('([^'\\]|\\.)*')/gc
            $t.=$1
        $elif $param=~/\G([\(\[\{])/gc
            $t.=$1
            push @closure_stack, $1
        $elif $param=~/\G([\)\]\}])/gc
            $t.=$1
            $if @closure_stack
                $call proper_split_close_bracket
        $elif $param=~/\G(.)/gc
            my $curfile=MyDef::compileutil::curfile_curline()
            $print "[$curfile]proper_split: unmatched $1 [$param]"
            $t.=$1

    $if $t
        $t=~s/\s+$//
    $if $t or @tlist
        push @tlist, $t
    return @tlist

subcode: proper_split_close_bracket
    my $match
    $if $1 eq ')'
        $match='('
    $elif $1 eq ']'
        $match='['
    $elif $1 eq '}'
        $match='{'
    my $pos=-1
    $for $i=0:@closure_stack
        $if $match==$closure_stack[$i]
            $pos=$i
    $if $pos>=0
        splice(@closure_stack, $pos)
    $else
        warn "proper_split: unbalanced [$param]\n"

#---------------------------------------- 
fncode: expand_macro($line, $sub)
    my @paren_stack
    my $segs=[]
    &call parse_loop, $line
        &call if_lex, \$\(
            $if @$segs && substr($segs->[-1], -1, 1) eq "\\"
                #-- escaped ----
                $if !@paren_stack
                    push @$segs, "\$("
                $else
                    push @$segs, "\$"
                    push @paren_stack, $segs
                    $segs=[]
                    push @paren_stack, "("
            $else
                push @paren_stack, $segs
                $segs=[]
                push @paren_stack, "\$\("
        $elif !@paren_stack
            &call if_lex, ([^\$]|\$(?!\())+
                push @$segs, $&
        $else
            # inside $( ... )
            &call if_lex, \(
                push @paren_stack, $segs
                $segs=[]
                push @paren_stack, "("
            &call if_lex, \)
                my $t=join('', @$segs)
                my $open=pop @paren_stack
                $segs=pop @paren_stack
                $if $open eq "(" or $t!~/^\w/
                    push @$segs, "($t)"
                $else
                    push @$segs, $sub->($t)
            &call if_lex, ([^\$()]|\$(?!\())+
                push @$segs, $&
    return join('', @$segs)

#---------------------------------------------
fncode: uniq_name($name, $hash)
    $if !$hash->{$name}
        return $name
    $else
        my $i=2
        $if $name=~/[0-9_]/
            $name.="_"
        $while $hash->{"$name$i"}
            $i++
        return "$name$i"

#---------------------------------------- 
fncode: string_symbol_name($s)
    my $n=length($s)
    my $name=""
    $for $i=0:$n
        my $c = substr($s, $i, 1)
        $if $c=~/\w/
            $name.=$c
        $elif $c eq "+"
            $name.="Plus"
        $elif $c eq "-"
            $name.="Minus"
        $elif $c eq "*"
            $name.="Mult"
        $elif $c eq "/"
            $name.="Div"
        $elif $c eq "="
            $name.="Eq"
        $elif $c eq "!"
            $name.="Not"
        $elif $c eq "^"
            $name.="Ctrl"
        $elif $c eq "%"
            $name.="Mod"
        $elif $c eq ">"
            $name.="Gt"
        $elif $c eq "<"
            $name.="Lt"
        $elif $c eq "|"
            $name.="Or"
        $elif $c eq "&"
            $name.="And"
        $elif $c eq "("
            $name.="Lp"
        $elif $c eq ")"
            $name.="Rp"
        $elif $c eq "["
            $name.="Lb"
        $elif $c eq "]"
            $name.="Rb"
        $elif $c eq "{"
            $name.="Lc"
        $elif $c eq "}"
            $name.="Rc"
        $elif $c eq "\""
            $name.="Dq"
        $elif $c eq "'"
            $name.="Sq"
        $elif $c eq ","
            $name.="Comma"
        $elif $c eq "."
            $name.="Dot"
        $elif $c eq ":"
            $name.="Colon"
        $elif $c eq ";"
            $name.="Semi"
        $else
            die "string_symbol_name: [$c] not defined\n"

    return $name
