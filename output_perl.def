include: output.def

page: output_perl, output_main
    type: pm
    output_dir: lib/MyDef
    ext: pl
    init_mode: sub
    package: MyDef::output_perl
    interface_type: perl

subcode: init_page
    $if $page->{package} and !$page->{type}
	$page->{type}="pm"
	$ext="pm"
    $elif !$page->{package} and $page->{type} eq "pm"
	$page->{package}=$page->{pagename}

subcode:: package_globals
    our @globals
    our %globals

#---------------------------------------- 
include: macros_output/case.def
include: macros_output/for.def
include: macros_output/scope.def
include: macros_output/sumcode.def

subcode: case_flag_set
    $global $case_flag="\$b_flag_case"
    push @$out, "my \$b_flag_case=1;"
subcode: case_flag_reset
    push @$out, "my \$b_flag_case=0;"

#----
subcode: var_declare(scope)
    $param=~s/\s*;\s*$//
    my @tlist=MyDef::utils::proper_split($param)
    $foreach $v in @tlist
	my ($name, $var)
	$if $v=~/\@(\w+)\[(.*)\](.*)/
	    $name=$1
	    $v='@'.$1.$3
	    $var={}
	    my @tlist=split /,\s*/, $2
	    my $i=0
	    $foreach $t in @tlist
		$i++
		$var->{"dim$i"}=$t
	$(if:scope=global)
	    $if !$globals{$v}
		$globals{$v}=1
		push @globals, $v
	    $if $var
		$global_scope->{var_hash}->{$name}=$var
	$(else)
	    push @$out, "my $v;"
	    $if $var
		$cur_scope->{var_hash}->{$name}=$var
    return 0

#----
subcode: parsecode
    $call parsecode_scope
    $call parsecode_case_support, if, elsif, c_style
    $if $l=~/^\s*\$(\w+)\s*(.*)$/
	my $func=$1;
	my $param=$2;
	$if $func =~ /^global$/
	    $call var_declare, global
	$elif $func =~ /^my$/
	    $call var_declare, my
	$elif $func eq "sub"
	    $if $param=~/^(\w+)\((.*)\)/
		return single_block_pre_post(["sub $1 {", "INDENT", "my ($2)=\@_;"], ["DEDENT", "}"], "sub")
	    $else
		return single_block("sub $param {", "}", "sub")

	$elif $func =~ /^(while)$/
	    return single_block("$1($param){", "}")
	$elif $func eq "for"
	    $call parsecode_for_support, c_style
	$elif $func eq "foreach"
	    $call parsecode_foreach
	$elif $func eq "sumcode"
	    $call parsecode_sum_support, perl
	$elif $func eq "print"
	    $call parsecode_print

    $call check_termination
    push @$out, $l

    return 0;

#---------------------------------------- 
subcode: for_i0_i1_step
    $if $step eq "1"
	$step="++"
    $elif $step eq "-1"
	$step="--"
    $else
	$step= "+=$step"
    $call loop_var
    $param="my $var=$i0; $var $i1; $var$step"

subcode: parsecode_foreach
    $if $param=~/(\S+)\s+in\s+(.*)/
	my ($var, $list)=($1, $2)
	$call loop_var
	return single_block("foreach my $var ($list){", "}", "foreach")

subcode: loop_var
    $if !$var
	$var="\$i"
    $elif $var=~/^(\w+)/
	$var='$'.$var

#---------------------------------------- 
subcode: dumpout
    # needed for wrapping up &case support
    parsecode("NOOP")
    # ---------------
    $if !defined $pagetype or $pagetype eq "pl"
	push @$f, "#!/usr/bin/perl\n"

    $if $pagetype ne "eval"
	push @$f, "use strict;\n"

    $if $MyDef::page->{package}
	push @$f, "package ".$MyDef::page->{package}.";\n"
    
    $foreach $v in @globals
	push @$f, "our $v;\n"

subcode: check_termination
    #$l=~s/^\|//;
    $if $l=~/^\s*$/
	# NOOP
    $elif $l=~/^\s*(break|continue);?\s*$/
	$if $1 eq "break"
	    $l="last;"
	$elif $l eq "continue"
	    $l="next;"
    $elif $l=~/^\s*(for|while|if|else if)\s*\(.*\)\s*$/
	# NOOP
    $elif $l=~/^\s*}/
	# Check the formal blockend
	# Inline blocks will get ; appended.
    $elif $l!~/[,:\(\[\{;]\s*$/
	#print "[$l]appending ;\n";
	$l.=";";
    $else
	#print "[$l]\n";

#---------------------------------------- 
subcode: parsecode_print
    my $str=$param
    $if $str=~/^\s*\"(.*)\"\s*$/
	$str=$1

    my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)

    my @fmt_list
    my @arg_list

    my @group
    my $n_escape=0
    &call parse_loop, $str
	&call if_lex, \$
	    &call if_lex, (red|green|yellow|blue|magenta|cyan)
		#---------------------------------------- 
		#- $print $green ---------
		push @fmt_list, "\\x1b[$colors{$1}m"
		$n_escape++
		&call if_lex, \{
		    push @group, $1
	    $else
		push @fmt_list, '$'
	&call if_lex, \\\$
	    push @fmt_list, '$'
	&call if_lex, \}
	    #---------------------------------------- 
	    #- $print $green{some text}
	    $if @group
		pop @group
		$if !@group
		    push @fmt_list, "\\x1b[0m"
		    $n_escape=0
		$else
		    my $c=$group[-1]
		    push @fmt_list, "\\x1b[$colors{$c}m"
		    $n_escape++
	    $else
		push @fmt_list, '}'
	&call if_lex, [^\$\}]+
	    push @fmt_list, $&

    my $tail=$fmt_list[-1]
    $if $tail=~/(.*)-$/
	$fmt_list[-1]=$1
    $elif $tail!~/\\n$/
	push @fmt_list, "\\n"
    $if $n_escape
	push @fmt_list, "\\x1b[0m"

    push @$out, 'print "'.join('',@fmt_list).'";'
    return
