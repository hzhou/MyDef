include: output.def
include: macros_output/case.def
include: macros_output/for.def

include: macros_output/scope.def
include: macros_output/sumcode.def


page: output_perl, output_main
    output_dir: lib/MyDef
    ext: pl
    package: MyDef::output_perl

subcode: init_page
    $if $page->{package} and !$page->{type}
        MyDef::set_page_extension("pm")
    $elif !$page->{package} and $page->{type} $eq "pm"
        $page->{package}=$page->{pagename}

    $map dbl_list, globals, uses

#---------------------------------------- 
subcode: dbl_push_list(name, list)
    $(list)=~s/\s*;\s*$//
    my @tlist=MyDef::utils::proper_split($(list))
    $foreach $v in @tlist
        $call dbl_push, $(name), $v

#---------------------------------------- 
subcode: case_flag_set
    $global $case_flag="\$b_flag_case"
    push @$out, "my \$b_flag_case=1;"
subcode: case_flag_reset
    push @$out, "my \$b_flag_case=0;"

#---- scope  for sumcode -------
subcode: var_declare(scope)
    $param=~s/\s*;\s*$//
    my @tlist=MyDef::utils::proper_split($param)
    $foreach $v in @tlist
        my ($name, $var)
        $if $v=~/\@(\w+)\[(.*)\](.*)/
            $name=$1
            $v='@'.$1.$3
            $var={}
            my @tlist=split /,\s*/, $2
            my $i=0
            $foreach $t in @tlist
                $i++
                $var->{"dim$i"}=$t
        $(if:scope=global)
            # $print global variable: $v
            $call dbl_push, globals, $v
            $if $var
                $global_scope->{var_hash}->{$name}=$var
        $(else)
            push @$out, "my $v;"
            $if $var
                $cur_scope->{var_hash}->{$name}=$var
    return 0

#----
subcode: parsecode
    $(set:parse_condition=1)
    $call parsecode_scope
    $call parsecode_case_support, if, elsif, c_style
    $if $l=~/^\s*\$(\w+)\s*(.*)$/
        my $func=$1;
        my $param=$2;
        # TODO: think about $loopvar 
        $if $func =~ /^global$/
            $call var_declare, global
        $elif $func =~ /^my$/
            $call var_declare, my
        $elif $func =~ /^loopvar$/
            $call add_loop_var
            return 0
        $elif $func =~ /^use$/
            $call dbl_push_list, uses, $param
            return 0
        $elif $func eq "sub"
            $if $param=~/^(\w+)\((.*)\)/
                return single_block_pre_post(["sub $1 {", "INDENT", "my ($2)=\@_;"], ["DEDENT", "}"], "sub")
            $else
                return single_block("sub $param {", "}", "sub")

        $elif $func =~ /^(while)$/
            $if $param=~/\/.*\/\w*\s*$/
                #-- regex
                return single_block("while($param){", "}")
            $elif $param=~/^(.*?);\s*(.*?)\s*$/
                return single_block_pre_post(["while($1){", "INDENT"], ["$2;", "DEDENT", "}"])
            $else
                return single_block("while($param){", "}")
        $elif $func eq "for"
            $call parsecode_for_support, c_style
        $elif $func eq "foreach"
            $call parsecode_foreach
        $elif $func eq "boolhash"
            $if $param=~/^\((.*?)\)\s*(.*)/
                my $v = $1
                my @plist=split /,\s*/, $2
                my @tlist
                $foreach $t in @plist
                    push @tlist, "$t=>1"
                push @$out, "$v= (".join(', ', @tlist).");"
            return 0
        $elif $func eq "sumcode" or $func eq "loop" or $func eq "sum"
            $if $param=~/^\((.*?)\)\s+(.*)/
                my $dimstr=$1
                $param=$2
                $call parsecode_sum_simple, perl
            $elif $func eq "sumcode"
                $call parsecode_sum_support, perl
        $elif $func eq "print"
            $call parsecode_print
        $elif $func eq "print_to"
            $global $print_target
            $print_target = $param
            return 0
        $elif $func eq "source-$param"
            return "SKIPBLOCK"
    $elif $l=~/^NOOP POST_MAIN/
        $call list_functions
        return 0
    $elif $l=~/^loop:/
        $call define_loop_var
        return 0

    # $call check_hash_equal
    $call check_termination
    push @$out, $l

    return 0;

fncode: parse_condition($t)
    $if $t=~/[!=]~/
        # ok
    $elif $t=~/[^!=><]=[^="]/
       $call warn, assignment in condition [$t]? 
    $elif $t=~/\$(?:eq|ne)/
        #-- to supress warning ----
        $if $t=~/(.*?)(\S+)\s+(\$eq|\$ne)\s+(.*)/
            $if $3 eq '$eq'
                $t=$1."$2 && $2 eq $4"
            $else
                #-- remember to use () when necessary
                $t=$1."!$2 || $2 ne $4"
    return $t

#---------------------------------------- 
subcode: define_loop_var
    $global $loop_idx
    $loop_idx+=1
    push @$out, "DUMP_STUB loop_$loop_idx"

subcode: add_loop_var
    my @tlist=MyDef::utils::proper_split($param)
    my $block=MyDef::compileutil::get_named_block("loop_$loop_idx")
    $foreach $v in @tlist
        push @$block, "my $v;"

#---------------------------------------- 
subcode: for_i0_i1_step
    $if $step eq "1"
        $step="++"
    $elif $step eq "-1"
        $step="--"
    $else
        $step= "+=$step"
    $call loop_var
    $param="my $var=$i0; $var $i1; $var$step"

subcode: parsecode_foreach
    $if $param=~/^(?:my\s+)?(\S+)\s+in\s+(.*)/
        my ($var, $list)=($1, $2)
        $call loop_var
        return single_block("foreach my $var ($list){", "}", "foreach")
    $elif $param=~/^(%.*)/
        return single_block("while (my (\$k, \$v) = each $1){", "}", "foreach")
    $elif $param=~/^(\S+),\s*(\S+)\s+in\s+(.*)/
        my ($k, $v, $hash)=($1, $2, $3)
        return single_block("while (my ($k, $v)=each $hash){", "}", "foreach")

subcode: loop_var
    $if !$var
        $var="\$i"
    $elif $var=~/^(\w+)/
        $var='$'.$var

#---------------------------------------- 
subcode: dumpout
    # needed for wrapping up &case support
    parsecode("NOOP")
    # ---------------
    $if !$pagetype or $pagetype eq "pl"
        push @$f, "#!/usr/bin/perl\n"

    $if $pagetype ne "eval"
        $(set:p=$MyDef::page->{$1})
        push @$f, "use strict;\n"
        $(if:0)
            push @$f, "use warnings;\n"
            
            $if !$(p:nowarn)
                push @$f, "no warnings qw(uninitialized);\n"
            $elif $(p:nowarn) ne "none"
                push @$f, "no warnings qw($(p:nowarn));\n"

        $if @uses
            $foreach $v in @uses
                push @$f, "use $v;\n"
            push @$f, "\n"

        $if $(p:package)
            push @$f, "package ".$(p:package).";\n"
        
        $if @globals
            $foreach $v in @globals
                push @$f, "our $v;\n"
            push @$f, "\n"

        #-- to be processed by dumpout -- reverse order due to unshift
        $if @$fn_block
            $dump->{fn_block}=$fn_block
            unshift @$out, "INCLUDE_BLOCK fn_block"

        unshift @$out, "DUMP_STUB global_init"

#----------------------------------------------- 
subcode: list_functions
    $global $fn_block=[]
    &call replace_output, $fn_block
        &call each_subcode, fn
            # $name, $code
            $call parse_function

    subcode: parse_function
        push @$out, "sub $name {"
        push @$out, "INDENT"
        my $params=$code->{params}
        $if $#$params>=0
            my $pline=join(", ", @$params)
            push @$out, "my ($pline) = \@_;"
        $code->{scope}="list_sub"
        MyDef::compileutil::list_sub($code)
        push @$out, "DEDENT"
        push @$out, "}"
        push @$out, "NEWLINE"
    
#---- for extensions ----
fncode: inject_function($name, $params, $source)
    my $t_code={'type'=>"fn", name=>$name, params=>$params, 'source'=>$source}
    $MyDef::def->{codes}->{$name}=$t_code

#----------------------------------------------- 
subcode: check_hash_equal
    $if $l=~/[({][^)}]*=[^>]/
        $call warn, Miss typed = in hash? [$l]

subcode: check_termination
    #$l=~s/^\|//;
    $if $l=~/^\s*$/
        # NOOP
    $elif $l=~/^\s*(break|continue);?\s*$/
        $if $1 eq "break"
            $l="last;"
        $elif $l eq "continue"
            $l="next;"
    $elif $l=~/^\s*(for|while|if|else if)\s*\(.*\)\s*$/
        # NOOP
    $elif $l=~/^\s*}/
        # Check the formal blockend
        # Inline blocks will get ; appended.
    $elif $l!~/[,:\(\[\{;]\s*$/
        #print "[$l]appending ;\n";
        $l.=";";
    $else
        #print "[$l]\n";

#---------------------------------------- 
subcode: parsecode_print
    my $str=$param
    my $need_escape
    $if $str=~/^\s*\"(.*)\"\s*$/
        $str=$1
    $else
        $need_escape=1

    my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)

    my @fmt_list
    my @arg_list

    my @group
    my $n_escape=0
    &call parse_loop, $str
        &call if_lex, \$
            &call if_lex, (red|green|yellow|blue|magenta|cyan)
                #---------------------------------------- 
                #- $print $green ---------
                push @fmt_list, "\\x1b[$colors{$1}m"
                $n_escape++
                &call if_lex, \{
                    push @group, $1
            $else
                push @fmt_list, '$'
        &call if_lex, (\\.)
            push @fmt_list, $1
        $elif $str=~/\G"/gc
            $if $need_escape
                push @fmt_list, "\\\""
            $else
                push @fmt_list, "\""
        &call if_lex, \}
            #---------------------------------------- 
            #- $print $green{some text}
            $if @group
                pop @group
                $if !@group
                    push @fmt_list, "\\x1b[0m"
                    $n_escape=0
                $else
                    my $c=$group[-1]
                    push @fmt_list, "\\x1b[$colors{$c}m"
                    $n_escape++
            $else
                push @fmt_list, '}'
        $elif $str=~/\G[^\$\}"]+/gc
            push @fmt_list, $&

    my $tail=$fmt_list[-1]
    $if $tail=~/(.*)-$/
        $fmt_list[-1]=$1
    $elif $tail!~/\\n$/
        push @fmt_list, "\\n"
    $if $n_escape
        push @fmt_list, "\\x1b[0m"

    my $p = "print"
    $if $print_target
        $p.=" $print_target"
    push @$out, "$p \"".join('',@fmt_list).'";'
    return
