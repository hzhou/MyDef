# 
subcode: fetch_named_resource(type)
    my $$(type) = $MyDef::def->{resource}->{"$(type)_$name"}
    $if !$$(type)
	print "Resource $(type): $name does not exist\n"
	return

# -------- Window ---------------------------------------
subcode:: package_global
    my %window_hash
    my @window_list
    my %hgdi_hash
    my $resource_id=1000

# ---- MakeWindow ----
subcode: make_window
    $call fetch_named_resource, view
    create_window($out, $view)

subcode:: support_subs
    $sub create_window
	my ($out, $view)=@_
	# ---- get view attr ----
	my $name=$view->{_name}
	$if $name=~/^view_(\w+)/
	    $name=$1
	$call get_res_view_attr
	# ----
	$if !$attr{wndclass}
	    $attr{wndclass}=$name
	    $if !$window_hash{$name}
		$window_hash{$name}=1
		push @window_list, $name

	my ($hwnd, $parent, $data)
	$if $name eq "main"
	    declare_struct("main", "HWND hwnd")
	    global_add_var("main", "struct main")
	    push @$out, "main.hwnd = CreateWindowEx($attr{style_ex}, \"$attr{wndclass}\", \"$attr{text}\", $attr{style}, $x, $y, $w, $h, NULL, (HMENU)$attr{id}, cur_instance, &main);"
	$else
	    $hwnd="hwnd_child"
	    $parent="hwnd"

	    func_add_var($hwnd, "HWND");
	    $if $window_hash{$name}
		func_add_var("view", "void *")
		declare_struct("view_$name", "HWND hwnd")
		push @$out, "view = malloc(sizeof(struct view_$name));"

		push @$out, "$hwnd = CreateWindowEx($attr{style_ex}, \"$attr{wndclass}\", \"$attr{text}\", $attr{style}, $x, $y, $w, $h, $parent, (HMENU)$attr{id}, cur_instance, view);"
		push @$out, "((struct view_$name *)view)->hwnd=$hwnd;"
	    $else
		push @$out, "$hwnd = CreateWindowEx($attr{style_ex}, \"$attr{wndclass}\", \"$attr{text}\", $attr{style}, $x, $y, $w, $h, $parent, (HMENU)$attr{id}, cur_instance, NULL);"

	$if $attr{font}
	    $if $attr{font}=~/^(font_\w+)$/
		$hgdi_hash{$1}=1
		push @$out, "SendMessage($hwnd, WM_SETFONT, (WPARAM)$1, 0);"
	    $else
		my ($var, $spec)=("hfont", $attr{font})
		$call make_font
		push @$out, "SendMessage($hwnd, WM_SETFONT, (WPARAM)hfont, 0);"

subcode: get_res_view_attr
    # default 0
    $call res_init_attr, view
    # default 1
    $call res_update, "view_$name"
    $call res_update, "ctl_$name"
    # last
    $call res_update_attr, $view 
    my ($x, $y)=split /,\s*/, $attr{position}
    my ($w, $h)=split /,\s*/, $attr{size}

# ---- LoadView ----
subcode: load_view
    $if $view->{menu}
	my ($var, $name)=("hmenu", $view->{menu})
	$call fetch_named_resource, menu
	func_add_var($var, "HMENU")
	push @$out, "$var = CreateMenu();"
	ogdl_menu($out, $var, $menu, 0, $view->{commands});
	push @$out, "SetMenu(hwnd, hmenu);"
	push @$out, "DestroyMenu(hmenu);"
    my $list=$view->{_list}
    my $flag_docked_views=0
    $foreach my $v in @$list
	$flag_docked_views+=check_window_dock($v)
    $if $flag_docked_views
	func_add_var(rect_client)
	push @$out, "GetClientRect(hwnd, &rect_client);"
    my $command_hash=$view->{commands}
    $foreach my $v in @$list
	$if $v->{action}
	    $resource_id++
	    my $id="ID_$v->{_name}_$resource_id"
	    $defines{$id}=$resource_id
	    $v->{id}=$id
	    $command_hash->{$id}=$v->{action}
	create_window($out, $v, 0)

subcode:: support_subs
    $sub check_window_dock
	my ($view)=@_
	$call get_res_view_attr
	$if $x<0 and $w<0
	    $x=-$x
	$if $y<0 and $h<0
	    $y=-$y
	$if $x<0
	    $x="rect_client.right-$w$x"
	$if $y<0
	    $y="rect_client.bottom-$h$y"
	$if $w<0
	    $w="rect_client.right-$x$w"
	$if $h<0
	    $h="rect_client.bottom-$y$h"
	$view->{position}="$x, $y"
	$view->{size}="$w, $h"

###### Window Proc Handling
subcode: wndproc_get_view_pointer
    my $struct_type
    $if $name eq "main"
	$struct_type="struct view_$name *"
    $else
	$struct_type="struct view_$name *"
    func_add_var("me", $struct_type)
    push @$out, "if(msg==WM_NCCREATE){"
    &call push_indent_block
	push @$out, "me=($struct_type)((LPCREATESTRUCT)lparam)->lpCreateParams;"
	push @$out, "SetWindowLong(hwnd, GWL_USERDATA, (LONG)me);"
    push @$out, "}"
    push @$out, "else{"
    &call push_indent_block
	push @$out, "me=($struct_type)GetWindowLong(hwnd, GWL_USERDATA);"
    push @$out, "}"
# ------------ Window Proc -----------------    
subcode:: support_subs
    $sub register_window
	my ($name)=@_
	$call fetch_named_resource, view
	$if !$view->{commands}
	    $view->{commands}={}
	my $block=MyDef::compileutil::get_named_block("global_init")
	my $old_function=$cur_function;
	&call replace_output, $block
	    $call window_proc
	$cur_function=$old_function
	$call window_register

# ---- window proc  ----------------
subcode: window_proc
    my $fidx=open_function("wndproc_$name", "HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam")
    $cur_function->{ret_type}="LRESULT CALLBACK";
    &call push_open_function
	$call wndproc_get_view_pointer
	# ---- process window msg ---------------
	push @$out, "switch(msg){";
	&call push_indent_block
	    MyDef::compileutil::call_sub("\@$name\_on_msg", 0)
	    $call msg_create
	    $call msg_command
	    $call msg_paint
	    $call msg_destroy
	    $call msg_default
	push @$out, "}";
	push @$out, "return 0;"

# -- messages --
subcode: msg_create
    push @$out, "case WM_CREATE:"
    &call push_indent_block
	$call load_view
	MyDef::compileutil::call_sub("\@$name\_on_create")
	push @$out, "break;"
subcode: msg_destroy
    push @$out, "case WM_DESTROY:"
    &call push_indent_block
	MyDef::compileutil::call_sub("\@$name\_on_close")
	$if $name eq "main"
	    push @$out, "PostQuitMessage(0);"
	    push @$out, "break;"
subcode: msg_default
    push @$out, "default:";
    &call push_indent_block
	push @$out, "return DefWindowProc(hwnd, msg, wparam, lparam);"

subcode: msg_command
    push @$out, "case WM_COMMAND:"
    &call push_indent_block
	func_add_var(n_id)
	func_add_var(n_cmd)
	func_add_var(hwnd_child)
	push @$out, "n_id=LOWORD(wparam);"
	push @$out, "n_cmd=HIWORD(wparam);"
	push @$out, "hwnd_child=(HWND)lparam;"
	$call fetch_named_resource, view
	my $command_hash=$view->{commands}
	my @id_list=sort keys(%$command_hash)
	$foreach my $id in @id_list
	    $if $command_hash->{$id}
		my @alist=split /,/, $command_hash->{$id}
		$foreach $a in @alist
		    $if $a=~/(\w+):\s*(\w+)/
			push @$out, "if(n_id==$id && n_cmd==$1){"
			push @$out, "INDENT"
			MyDef::compileutil::call_sub("\@$name\_$2")
		    $else
			push @$out, "if(n_id==$id){"
			push @$out, "INDENT"
			MyDef::compileutil::call_sub("\@$name\_$a")
		    push @$out, "break;"
		    push @$out, "DEDENT"
		    push @$out, "}"
	push @$out, "break;"

# --
subcode: msg_conditional(MSG, OnName)
    $if MyDef::compileutil::get_def_attr("codes", "$name\_$(OnName)")
	push @$out, "case WM_$(MSG):"
	&call push_indent_block
	    BLOCK
    $else
	push @$out, "/*Skip msg $name\_$(OnName)*/"

subcode: msg_paint
    &call msg_conditional, PAINT, on_paint
	func_add_var("ps", "PAINTSTRUCT")
	func_add_var("hdc", "HDC")
	func_add_var("cur_x", "int")
	func_add_var("cur_y", "int")
	push @$out, "hdc=BeginPaint(hwnd, &ps);"
	push @$out, "cur_x = 0;"
	push @$out, "cur_y = 0;"
	MyDef::compileutil::call_sub("$name\_on_paint")
	push @$out, "EndPaint(hwnd, &ps);"
	push @$out, "break;"

# ---- register window function ----------------
subcode: window_register
    push @$out, "/* Register Window $name */"
    func_add_var("wc", "WNDCLASSEX")
    push @$out, "memset(&wc, 0, sizeof(wc));"
    push @$out, "wc.hInstance = cur_instance;"
    push @$out, "wc.lpszClassName = \"$name\";"
    push @$out, "wc.lpfnWndProc = wndproc_$name;"
    $call res_init_attr, wnd
    $call res_update, "wnd_$name"
    $call res_fill, wc
    push @$out, "if(!RegisterClassEx(\&wc)) return 0;"

####### Resource Handling #######################
# -------- Menu ---------------------------------------
subcode:: support_subs
    $sub ogdl_menu
	my ($out, $menuvar, $menu, $level, $command_hash)=@_;
	my $pos=0;
	my $menu_item_list=$menu->{_list}
	#print "menu: $menu, list: $menu_item_list\n";
	$foreach $t in @$menu_item_list
	    $if ref($t) eq "HASH"
		my $sublist=$t->{_list}
		$if @$sublist
		    #---- PopUp SubMenu ----
		    my $var=sprintf("hmenu_sub%d", $level+1);
		    func_add_var($var, "HMENU");
		    push @$out, "$var = CreatePopupMenu();";
		    ogdl_menu($out, $var, $t, $level+1, $command_hash);
		    push @$out, "InsertMenu($menuvar, $pos, MF_POPUP|MF_BYPOSITION, (UINT_PTR)$var, \"$t->{_name}\");";
		    push @$out, "DestroyMenu($var);";
		$else
		    #---- MenuItem with Attributes ----
		    my $name=$t->{_name}
		    my $title=$t->{text}
		    $if !defined $title
			$title=$name
		    $resource_id++
		    my $id_name="ID_MENU_$name\_$resource_id";
		    $defines{$id_name}=$resource_id
		    $command_hash->{$id_name}=$t->{action}
		    push @$out, "AppendMenu($menuvar, MF_STRING, $id_name, \"$title\");";

	    $else
		#---- Text MenuItem ----
		$if $t eq "----"
		    push @$out, "AppendMenu($menuvar, MF_SEPARATOR, 0, NULL);";
		$else
		    $resource_id++
		    my $id_name="ID_MENU_$t\_$resource_id";
		    $id_name=~s/[ &]//g;
		    $defines{$id_name}=$resource_id
		    push @$out, "AppendMenu($menuvar, MF_STRING, $id_name, \"$t\");";
	    $pos++;

# -------- Font ---------------------------------------
subcode: make_font
    push @$out, "/* make_font $name */"
    $call res_init_attr, font
    $if $spec
	my @plist=split /,\s*/, $spec
	$foreach my $p in @plist
	    $if $p=~/(\d+)/
		$attr{lfHeight}=-$1
	    $elif $p=~/bold/i
		$attr{lfWeight}="FW_HEAVY"
	    $elif $p=~/italic/i
		$attr{lfItalic}=1
	    $elif $p=~/^font_/ and $MyDef::def->{resource}->{"$p"}
		$call res_update, "$p"
	    $else
		$attr{lfFaceName}="\"$p\""
    $elif $MyDef::def->{resource}->{$var}
	$call res_update, $var
    func_add_var("lf", "LOGFONT")
    $call res_fill, lf
    
    $if $var=~/(\w+)/ and !get_var_type($1)
	func_add_var($var, "HFONT");
    $if $misc_vars{hgdi_enable}
	hgdi_pre_assign("HFONT", $var, "0", $out);
    push @$out, "$var = CreateFontIndirect(&lf);";
    $if $misc_vars{hgdi_enable}
	push @$out, "hgdi_add($var);";
    $var_retain_hash{$var}=1;

# -------- ---------------------------------------
subcode: res_update_attr(a)
    $while my ($k, $v)=each %$(a)
	$if $k!~/^_(name|list)/
	    $attr{$k}=$v
# ----	    
subcode: res_init_attr(type)
    my %attr;
    my $default=$MyDef::def->{resource}->{default_$(type)}
    $call res_update_attr, $default

subcode: res_update(tag)
    my $a=$MyDef::def->{resource}->{$(tag)}
    $if $a
	$call res_update_attr, $a

subcode: res_fill(s)
    $while my ($k, $v)=each %attr
	$if $k!~/^_(name|list)/
	    $if $v=~/^"(.*)"/
		push @$out, "strcpy($(s).$k, $v);"
	    $else
		push @$out, "$(s).$k = $v;"
