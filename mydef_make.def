include: modules.def
include: macros_util/path.def
include: macros_util/debug.def

# mydef_make will recursively look into each subdir
#   unless there is a skipmake file in the subdir.

page: mydef_make
    output_dir: script
    type:

    $call package_global
    $call @sub_make
    # ---- in current directory ----------
    $call read_or_create_config
    $print "    output_dir: $config_outputdir"

    # -- recursive make folders, copylist
    $call read_copylist
    $call collect_files

    # -- dependency list, individual pages, output folders
    my %h_def;
    my %h_page;
    my %folder;

    # ---- Build dependency, Group pages into folders, default to "toproot"
    my @extrafiles
    $call read_eachfile
    $call check_eachpage
    $call expand_dependency
    # ----
    $call write_makefile
    $call module_specific
    $call create_outputdir

    # ---------------------------------------- 
    subcode: sub_make
        $global @master_config;
        $if @ARGV and -d $ARGV[0]
            my $d=$ARGV[0];
            open In, "config";
            @master_config=<In>;
            close In;
            chdir $d or die "can't chdir $d\n";

    subcode: read_or_create_config
        $if !-f "config"
            $call create_config
        $call read_config



subcode:: package_global
    my $module="perl";
    my %module_type=($(module_type))


## --------- config -----------
subcode: create_config
    &call open_w, config
        $if @master_config
            $call copy_master_config
        $else
            $call create_new_config

    # -----------------------
    subcode: copy_master_config
        $foreach my $l in @master_config
            $if $l=~/^include_path:\s*(\S+)/
                $call amend_path
                print Out "include_path: $path\n"
            $else
                print Out $l
        # ----
        subcode: amend_path
            my @t=split /:/, $1
            my @tt;
            push @tt, "..";
            $foreach $s in @t
                $if $s!~/^\// or -d $s
                    push @tt, "../$s";
                $else
                    push @tt, $s;
            my $path=join(":", @tt)

    # -----------------------
    subcode: create_new_config
        $config_outputdir=prompt("Please enter the path to compile into [out]: ");
        print Out "output_dir: $config_outputdir\n";
        $module=prompt("Please enter module type [perl]: ");
        print Out "module: $module\n";

#----
subcode: read_config
    $global $config_outputdir;
    $global $config_outputdir_make=0
    $global $config_filetype
    &call open_r, config
        $if /module:\s+(\w+)/
            $module=$1;
        $elif /output_(dir|path): (\S+)/
            $config_outputdir=$2;
        $elif /filetype:\s*(\S+)/
            $config_filetype=$1
        $elif /^include_path:\s*(\S+)/
            add_path($1)
        $elif /^include:\s*(\S+)/
            $global @include_default
            my $t=$1;
            @include_default=split /[:,]\s*/, $t;
        $elif /^make-(\w+):\s*(.*\S)/
            $global %make_targets
            $make_targets{$1}=$2
        $elif /^macro_(\w+):\s*(.*\S)/
            $macros{$1}=$2;
    add_path($ENV{MYDEFLIB})

## ----------------------------------------------
subcode: read_copylist
    $global %h_copylist
    $if -f "copylist"
        my $location;
        &call open_r, copylist
            my $l=$_
            $if /^(\S+):\s*(.*)/
                $location=$1
                $l=$2;
                my $t="$config_outputdir/$location"
                $if !-d $t
                    mkdir $t
            $if $l
                my @tlist=split /\s+/, $l;
                $foreach $t in @tlist
                    $t=~s/^\s+//
                    $t=~s/\s+$//
                    $if $t=~/\*/
                        my @all=glob($t)
                        $foreach $a in @all
                            $h_copylist{$a}=$location
                    $elif -f $t
                        $h_copylist{$t}=$location
        my $count=keys %h_copylist
        $print "    copylist: loaded $count entries"

subcode: write_var_copylist
    $if %h_copylist
        print Out "COPY=";
        $while  my ($f, $l) = each %h_copylist
            my $sep="/";
            if($l){$sep="/$l/"};
            $if $f=~/(.+)\/(.+)/
                print Out $config_outputdir, $sep, $2, " ";
            $else
                print Out $config_outputdir, $sep, $f, " ";
        print Out "\n";
        push @tlist, "\${COPY}";
    print Out "\n";

subcode: write_rule_copylist
    # copylist
    if(%h_copylist){
        while( my ($f, $l) = each %h_copylist){
            my $sep="/";
            if($l){$sep="/$l/"};
            if($f=~/(.+)\/(.+)/){
                print Out $config_outputdir, "$sep$2: $f\n";
                print Out "\t cp $f $config_outputdir$sep$2\n";
            }
            else{
                print Out $config_outputdir, "/$l/$f: templates/$f\n";
                print Out "\t cp templates/$f $config_outputdir/$l/$f\n";
            }
        }
        print Out "\n";
    }
## ----------------------------------------------------------------------
subcode: _autoload
    my $script=$0;

subcode: collect_files
    $global @make_folders
    my @files;
    my @allfiles=glob("*");
    $foreach my $f in @allfiles
        $if $f=~/.def$/
            # ---- file ----
            push @files, $f;
        $elif -d $f
            # ---- folder ----
            $if -e "$f/skipmake"
                print "    Skip folder $f\n"
            $elif $f =~ /^(cmp|bootstrap|old|tests|macros|macros_.*)$/
                print "    Skip folder $f\n"
            $elif $f eq $config_outputdir and -f "$f/Makefile"
                $config_outputdir_make = 1
            $else
                my @t=glob("$f/*.def");
                $if @t 
                    print "$script $f ... \n";
                    system("$script $f")==0 or die "Failed to spawn sub make: $?\n";
                $if -f "$f/Makefile"
                    push @make_folders, $f;

subcode: read_eachfile
    $while my $f=pop @files
        my @page_list;
        my $page;
        my $output_dir
        $if !$h_def{$f} or $h_def{$f} == 1
            my $deplist=[];
            $h_def{$f}=$deplist;
            # ---- read the file ----
            $call @read_def_file
            $if $output_dir
                $foreach $page in @page_list
                    $if !$page->{output_dir}
                        $page->{output_dir}=$output_dir

subcode: read_def_file
    $if @include_default
        $foreach $i in @include_default
            $call include_file, $i

    &call protect_path
        my $inpage=0;
        &call open_r, $f
            $if $inpage
                $call parse_inpage
            $if !$inpage
                $call parse_global

    # ------------------
    subcode: parse_global
        $if /^include:?\s*(\S+\.def)/
            $call include_file, $1
        $elif /^path:\s*(.+)/
            $call protect_add_path, $1
        $elif /^page: .*\$\d.*/
            $inpage=1;
            $page={};
            push @page_list, $page;
        $elif /^page: ([a-zA-Z0-9_\.-]+)/
            $inpage=1;
            $page={};
            push @page_list, $page;
            $page->{page}=$1;
            $page->{def}=$f;
            $page->{include}={};
            my $key="$f-$1";
            $while $h_page{$key}
                $key.='1';
            $h_page{$key}=$page;
        $elif /^output_(dir|path): (\S+)/
            $output_dir=$1

    # ---------------------
    subcode: include_file(f)
        my $f=find_file($(f))
        $if $f
            push @$deplist, $f;
            $if !$h_def{$f}
                push @files, $f
                    $h_def{$f}=1

    subcode: parse_inpage
        $if /^\s*output_dir: (\S+)/
            $call outputdir_inpage
        $elif /^\s*\$include\s+(\S*)/ and $module ne "c" and -f $1
            $page->{include}->{$1}=1;
        $elif /^\s*type: (\w+)/
            $page->{type}=$1;
        $elif /^\s*type:\s*$/
            $page->{type}="none"
        $elif /^\s*module:\s*(\w+)/
            $page->{module}=$1;
        $elif /^\s*package:/
            $if $module eq "perl"
                $page->{type}="pm"
        $elif /^\s*depend:\s+(.*)/
            $page->{depend}=$1
        $elif /^\s*cmd:\s+(.*)/
            $page->{cmd}=$1
        $elif /\S/ 
            $inpage=0;
        # ----
        subcode: outputdir_inpage
            my $dir=expand_macros($1);

            $if $dir !~/^[\/\.]/ and $output_dir
                $dir=$output_dir."/".$dir
            $page->{output_dir}=$dir;
            my $tlist=$folder{$dir};
            $if $tlist
                push @$tlist, "$f-$page->{page}";
            $else
                $folder{$dir}=["$f-$page->{page}"];
            # Assign to Makefile Variable $dir 
            #     (which is grouped by output folder)
            $page->{in_var}=$dir;


subcode: check_eachpage
    $while my ($p, $h) = each %h_page
        $call @get_file_type
        $call @add_to_toproot
        $call @set_output_name
    # --------------------
    subcode: get_file_type
        $if !$h->{type}
            $if $config_filetype
                $h->{type}=$config_filetype
            $else
                my $t_module=$module
                $if $h->{module}
                    $t_module=$h->{module}
                $if $module_type{$t_module}
                    $h->{type}=$module_type{$t_module}
                $else
                    $h->{type}=$t_module
    # ----
    subcode: set_output_name
        $h->{path}=$h->{page};
        $if $h->{output_dir}
            $h->{path}=$h->{output_dir}."/".$h->{path};
        $if $config_outputdir and $h->{path}!~/^[\/\.]/
            $h->{path}=$config_outputdir."/".$h->{path};
        $if $h->{type} and $h->{type} ne "none"
            $h->{path}.=".$h->{type}"
    # ----
    subcode: add_to_toproot
        $if !$h->{in_var}
            $h->{in_var}="toproot";
            $if $folder{toproot}
                my $tlist=$folder{toproot};
                push @$tlist, $p;
            $else
                $folder{toproot}=[$p];

subcode: expand_dependency
    $while my ($f, $l) = each %h_def
        my %track;
        $foreach my $t in @$l
            $track{$t}=1
        my $j=0;
        $while $j<@$l
            my $t=$l->[$j];
            my $ll=$h_def{$t};
            $foreach $tt in @$ll
                $if !$track{$tt}
                    $track{$tt}=1;
                    push @$l, $tt;
            $j++;

subcode: write_makefile
    &call open_w, Makefile
        print Out "MakePage=mydef_page\n";
        print Out "\n";

        $call write_var_folder
        $call write_var_copylist

        print Out "all_targets: ", join(" ", @tlist, @make_folders),;
        print Out "\n\n";

        $if $config_outputdir_make
            print Out "all: all_targets\n"
            print Out "\tmake -C $config_outputdir\n";
        $if $config_outputdir_make
            print Out "install: $config_outputdir\n"
            print Out "\tmake -C $config_outputdir install\n"
            print Out "\n"

        # expand def dependcy tree
        $call write_rule_copylist
        $call write_rule_pages
        $call write_rule_submake
        $call write_rule_targets
    # ----------------
    subcode: write_rule_targets
        $foreach %make_targets
            print Out "$k:\n"
            print Out "\t$v\n"
            print Out "\n"

subcode: write_var_folder
    my %var_hash;
    my @tlist;
    $while my ($f, $l) = each %folder
        my $name;
        $if $f=~/.*\/(.*)/
            $name=uc($1);
        $else
            $name=uc($f);
        $if !$name
            $name="ROOT"
        $if $var_hash{$name}
            my $j=2;
            while($var_hash{"$name$j"}){$j++;}
            $name="$name$j";
        $var_hash{$name}=1;
        push @tlist, "\${$name}";
        print Out "$name=";
        $foreach my $p in @$l
            print Out $h_page{$p}->{path}, " ";
        print Out "\n";

subcode: write_rule_pages
    $while my ($p, $h)=each %h_page
        my $def=$h->{def};
        my $inc=$h->{include};
        my $inc_dep=join(" ", keys %$inc);
        my $extra_dep=''
        $if $h->{depend}
            $extra_dep=$h->{depend}
        $if $h->{path}
            my @t;
            my $l=$h_def{$def};
            $foreach $tt in @$l
                $if !$inc->{$tt} and -f $tt
                    push @t, $tt;
                    $inc->{$tt}=1
            print Out $h->{path}, ": ", $def, " ", join(" ", @t), " $inc_dep $extra_dep\n";
            $if $h->{cmd}
                print Out "\t$h->{cmd}\n"
            $elif $h->{module} and ($h->{module}ne $module)
                print Out "\t\${MakePage} -m$h->{module} \$< \$\@\n";
            $else
                print Out "\t\${MakePage} \$< \$\@\n";
            print Out "\n";

#---------------------------------------- 
subcode: _autoload
    my $nosub=0;
    $if @ARGV and $ARGV[0] eq 'nosub'
        shift @ARGV;
        $nosub=1;

subcode: write_rule_submake
    # ---- recursive make rule
    $if @make_folders
        $foreach  $f in @make_folders
            $if !$nosub
                print Out "$f: force_look\n";
                print Out "\t cd $f; make\n";
                print Out "\n";

        print Out "force_look:\n\ttrue\n";

subcode: module_specific
    $if $config_outputdir
        $if $module eq "win32"
            $if !-d $config_outputdir
                mkdir $config_outputdir;
            $if (-d $config_outputdir) and (!-f "$config_outputdir/make.bat")
                print "Create win32 $config_outputdir/make.bat\n"
                open Out, ">$config_outputdir/make.bat";
                $if $folder{toproot}
                    my $tlist=$folder{toproot};
                    my $page=$h_page{$tlist->[0]};
                    my $name=$page->{path}
                    $if $page->{path}=~/.*\/(.*)\.c/
                        $name=$1;
                    #print Out "gcc -Wl,-subsystem,windows -o $name.exe $name.c\r\n";
                    print Out "cl /W3 $name.c user32.lib\r\n";
                close Out;
        $if ($module eq "perl" or $module eq "xs") and !-d $config_outputdir
            $if $config_outputdir=~/^\w[0-9a-zA-Z_\-]*$/
                my $name=$config_outputdir;
                $name=~s/-/::/g;
                $if $module eq "perl"
                    my $pm_count=0
                    $while my ($p, $h) = each %h_page
                        $if $h->{type} eq "pm"
                            $pm_count++
                    $if $pm_count>0
                        print "Running h2xs -X $config_outputdir... ...\n";
                        system "h2xs -X $config_outputdir";
                $else
                    print "Running h2xs -n $config_outputdir... ...\n";
                    system "h2xs -n $config_outputdir";

subcode: create_outputdir
    $if $config_outputdir
        $if !-d $config_outputdir
            print "Create output folder $config_outputdir ...\n";
            mkdir $config_outputdir;
    $else
        $config_outputdir="."

    $foreach $f in keys(%folder)
        $if $f=~/toproot|ROOT/
            next
        $if $f !~/^[\/\.]/
            $f=$config_outputdir."/".$f
        $if !-d $f
            print "Create output folder $f ...\n";
            system "mkdir -p $f"


#---------------------------------------- 
fncode: prompt($msg)
    $while 1
        print "$msg\n";
        my $t=<STDIN>;
        chomp $t;
        $if $t
            return $t
        $elif $msg=~/\[(.*)\]: $/
            return $1
        $else
            die "Must reply $msg\n"

subcode: _autoload
    $global %macros

fncode: expand_macros($t)
    $if $t=~/\$\((\w+)\)/
        $if $macros{$1}
            $t=$`.$macros{$1}.$';
        $else
            die "Unknown Macro in $t\n";
    return $t

