include: output.def
include: macros_c/cfunctions.def

page: output_xs, output_main
    type: pm
    output_dir: lib/MyDef
    ext: xs
    init_mode: sub
    subcode: package_subs
	my @xs_globals;
	$call c_main
    subcode: init_page
	register_type_prefix("hv", "HV*");
	register_type_prefix("av", "AV*");
	register_type_prefix("sv", "SV*");
	$call c_init
    subcode: modeswitch
	$if $mode eq "xs"
	    push @$out, "INCLUDE_BLOCK xs_start"
	    set_function_flag("xs_mode", 1)
	    set_function_flag("skip_declare", 1)
    subcode: parsecode
	$call pre_parse
	$call check_text_includes
	$call c_parsecode
    subcode: dumpout
	# ---- process_function ------------------------
	my $funclist=MyDef::dumpout::get_func_list()
	$foreach my $func in @$funclist
	    $if $func->{xs_mode}
		$call process_function_xs
	    $else
		$call process_function_std
	# --- c global stuff -----------------
	$call c_dump_init
	# ---- xs_start -------------------
	my @block_xs_start
	$dump->{xs_start}=\@block_xs_start
	$call init_xs, block_xs_start

    subcode: custom_parse
	$call translate_perl

    subcode: dump_global
	$if $v=~/^[SHA]V/
	    push @xs_globals, "$v;\n";
	$else
	    $call dump_global_std

    subcode: translate_perl
	$if $l=~/(\S+)=(\w+)->\{(.*)\}/
	    my ($var, $hv, $key)=($1, $2, $3);
	    $if $key=~/^['"](.*)['"]/
		$key=$1;
	    my $keylen=length($key);
	    my $vartype;
	    $if $var=~/(\S+)\.(\S+)/
		$vartype=get_c_type($2);
	    $else
		func_add_var($var);
		$vartype=get_var_type($var);
		$if $debug
		    print "func_add_var: $var - $vartype [$l]\n"

	    func_add_var("t_psv");
	    push @$out, "t_psv=hv_fetch($hv, \"$key\", $keylen, 0);";
	    translate_tpsv($out, $var, $vartype);
	    return 
	$elif $l=~/(\S+)=(\w+)->\[(.*)\]/
	    my ($var, $av, $key)=($1, $2, $3);
	    my $vartype;
	    $if $var=~/(\S+)\.(\S+)/
		$vartype=get_c_type($2);
	    $else
		func_add_var($var);
		$vartype=get_var_type($var);

	    func_add_var("t_psv");
	    push @$out, "t_psv=av_fetch($av, $key, 0);";
	    translate_tpsv($out, $var, $vartype);
	    return
	$elif $l=~/\((\w+)->\{(.*)\}\)/
	    my ($pre, $hv, $key, $post)=($`, $1, $2, $');
	    $if $key=~/^['"](.*)['"]/
		$key=$1;
	    my $keylen=length($key);
	    push @$out, "$pre(hv_exists($hv, $keylen))$post";
	    return

    subcode:: support_subs
	# ---- Perl XS Specific -----------------------
	$sub translate_scalar
	    my ($output, $var, $vartype, $sv)=@_;
	    #print "$var, $vartype\n";
	    $if $vartype eq "int"
		push @$output, "$var = SvIV($sv);";
	    $elsif $vartype eq "double" or $vartype eq "float"
		push @$output, "$var = SvNV($sv);";
	    $elsif $vartype eq "char *"
		func_add_var("t_strlen");
		push @$output, "$var = SvPV($sv, t_strlen);";
		push @$output, "$var\[t_strlen\] = '\\0';";
	    $elsif $vartype =~ /^([SAH]V\*)/
		push @$output, "$var = ($1)SvRV($sv);";
	    $else
		print "translate_scalar: unhandled $var - $vartype\n";

	sub translate_null {
	    my ($out, $var, $vartype)=@_;
	    if($vartype !~/int|float|double/){
		push @$out, "    $var = NULL;";
	    }
	    elsif($vartype eq "int"){
		push @$out, "    $var = 0;";
	    }
	    else{
		push @$out, "    $var = 0.0;";
	    }
	}

	sub translate_tpsv {
	    my ($out, $var, $vartype)=@_;
	    push @$out, "if(t_psv){";
	    push @$out, "INDENT";
	    translate_scalar($out, $var, $vartype, "*t_psv");
	    push @$out, "DEDENT";
	    push @$out, "}";
	    push @$out, "else{";
	    translate_null($out, $var, $vartype);
	    push @$out, "}";
	}

	sub translate_perl_cond {
	    my ($l, $out)=@_;
	    if($l=~/^\s*(\w+)->\{(.+)\}\s*$/){
		my ($hv, $key)=($1, $2);
		my $keylen=length($key);
		my $tl="hv_exists($hv, \"$key\", $keylen)";
		return $tl;
	    }
	    elsif($l=~/^\s*(\w+)->\[(.+)\]\s*$/){
		my ($hv, $key)=($1, $2);
		my $tl="SvTRUE(*(av_fetch($hv, $key, 0)))";
		return $tl;
	    }
	    else{
		return $l;
	    }
	}

################################################
subcode: init_xs(block)
    push @$(block), "#include \"EXTERN.h\"\n";
    push @$(block), "#include \"perl.h\"\n";
    push @$(block), "#include \"XSUB.h\"\n";
    push @$(block), "\n";
    push @$(block), "#include \"ppport.h\"\n";
    push @$(block), "\n";
    $foreach my $l in @xs_globals
	push @$(block), $l;
    push @$(block), "\n";
    my $pagename=$page->{pagename}
    push @$(block), "MODULE = $pagename\t\tPACKAGE = $pagename\n";
    push @$(block), "\n";

subcode: pre_parse
    $if $l=~/^\s*\$(if|while|elif|elsif|elseif)\s*(.*)/
	$l="\$$1 ".translate_perl_cond($2, $out);
    $elsif $l=~/^\$foreach\s+(\w+)\s+in\s+(av_\w+)/
	my $v_i=$1;
	my $v_av=$2;
	my $v_idx=$2."_index"
	func_add_var($v_idx, "int")
	func_add_var($v_i)
	func_add_var("t_psv")
	my @pre;
	push @pre, "for($v_idx=0; $v_idx<=av_len($v_av); $v_idx++){"
	push @pre, "INDENT"
	push @pre, "t_psv=av_fetch($v_av, $v_idx, 0);"
	translate_scalar(\@pre, $v_i, get_var_type($v_i), "*t_psv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$foreach\s+\((\w+),\s*(\w+)\)\s+in\s+(hv_\w+)/
	my ($v_name, $v_val, $v_hv)=($1, $2, $3);
	func_add_var("t_n");
	func_add_var($v_name);
	func_add_var($v_val);
	func_add_var("t_sv");
	my @pre;
	push @pre, "while((t_sv=hv_iternextsv($v_hv, &$v_name, &t_n))){";
	push @pre, "INDENT"
	push @pre, "t_n=hv_iterinit($v_hv);"
	translate_scalar(\@pre,$v_val,get_var_type($v_val),"t_sv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$getparam\s+(.*)/
	my @vlist=split /,\s+/, $1;
	my $j=0;
	$foreach my $v in @vlist
	    my $type=get_c_type($v);
	    func_add_var($v);
	    translate_scalar($out, $v, $type, "ST($j)");
	    $j++;
	return

subcode: process_function_xs
    my (@t0, @t1, @pre, @post);
    $func->{openblock}=\@t0;
    $func->{closeblock}=\@t1;
    $func->{preblock}=\@pre;
    $func->{postblock}=\@post;
    my $name=$func->{name};

    # ---- ret_type and parameters ------------------
    $if $name
	my $ret_type=$func->{'ret_type'};
	if(!$ret_type){$ret_type="void";}
	my $paramlist=$func->{'param_list'};
	my @param_name_list;
	foreach my $p(@$paramlist){
	    if($p=~/(\w+)\s*$/){
		push @param_name_list, $1;
	    }
	}
	my $param_name_list_str=join(",", @param_name_list);

	push @t0, "$ret_type";
	push @t0, "$name($param_name_list_str)";
	$if @$paramlist
	    push @pre, "INDENT";
	    $foreach my $p in @$paramlist
		push @pre, "$p;";
	    push @pre, "DEDENT";

    # ---- Local Variables ---------------------------
    my $var_decl=$func->{var_decl};
    my $var_list=$func->{'var_list'};
    $if @$var_list
	push @pre, "PREINIT:";
	push @pre, "INDENT";
	$foreach my $v in @$var_list
	    $if $global_type->{$v}
		print "  [warning] In $name: local variable $v with exisiting global\n"
	    push @pre, "$var_decl->{$v};";
	push @pre, "DEDENT";
    push @pre, "PPCODE:";
    push @pre, "INDENT";

    # ---- init and finish --------------------------
    $foreach my $tl in @{$func->{init}}
	push @pre, $tl;
    $foreach my $tl in @{$func->{finish}}
	push @post, $tl;
    $if $name
	push @post, "DEDENT";
	push @t1, "NEWLINE";

