include: output.def

page: output_xs
    type: pm
    output_dir: lib/MyDef
    ext: xs
    init_mode: sub
    subcode: main
	$call output_main
	use MyDef::dumpout;
	use MyDef::output_c;
	package MyDef::$(pagename);

	$sub get_interface
	    return (\&init_page, \&MyDef::output_c::parsecode, \&MyDef::output_c::set_output, \&MyDef::output_c::modeswitch, \&dumpout);
	$sub modeswitch($mode, $in)
	    $call on_modeswitch

	$sub init_page
	    my @ret = MyDef::output_c::init_page(@_)
	    $call @on_init
	    return @ret

	$sub parsecode($l)
	    $call on_parsecode
	    return MyDef::output_c::parsecode($l)

	$sub dumpout($f, $out)
	    $call @on_dumpout
	    MyDef::output_c::dumpout($f, $out)

	$call @support_subs
	1;

subcode: on_init
    my @xs_globals;
    MyDef::output_c::register_type_prefix("hv", "HV*");
    MyDef::output_c::register_type_prefix("av", "AV*");
    MyDef::output_c::register_type_prefix("sv", "SV*");

subcode: on_modeswitch
    $if $mode eq "xs"
	push @$MyDef::output_c::out, "INCLUDE_BLOCK xs_start"
	MyDef::output_c::set_function_flag("xs_mode", 1)
	MyDef::output_c::set_function_flag("skip_declare", 1)

subcode: on_dumpout
    # ---- process_function ------------------------
    my $funclist=MyDef::dumpout::get_func_list()
    $foreach $func in @$funclist
	$if $func->{xs_mode}
	    $call process_function_xs
	    $func->{processed}=1

    # ---- xs globals ----------------
    my @t
    my $cnt
    $foreach $v in @MyDef::output_c::globals
	$if $v=~/^[SHA]V/
	    push @xs_globals, "$v;\n";
	    $cnt++
	$else
	    push @t, $v
    $if $cnt>0
	@MyDef::output_c::globals=@t

    # ---- xs_start -------------------
    my @block_xs_start
    $dump->{xs_start}=\@block_xs_start
    $call init_xs, block_xs_start

subcode: on_parsecode
    my $out=$MyDef::output_c::out
    $if $l=~/^\s*(\$if|while|elif|elsif|elseif)\s*(.*)/
	$l="$1 ".translate_perl_cond($2, $out);
    $elsif $l=~/^\$foreach\s+(\w+)\s+in\s+(av_\w+)/
	my $v_i=$1;
	my $v_av=$2;
	my $v_idx=$2."_index"
	MyDef::output_c::func_add_var($v_idx, "int")
	MyDef::output_c::func_add_var($v_i)
	my $vartype=MyDef::output_c::get_var_type($v_i);
	MyDef::output_c::func_add_var("t_psv")
	my @pre;
	push @pre, "for($v_idx=0; $v_idx<=av_len($v_av); $v_idx++){"
	push @pre, "INDENT"
	push @pre, "t_psv=av_fetch($v_av, $v_idx, 0);"
	translate_scalar(\@pre, $v_i, $vartype, "*t_psv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$foreach\s+\((\w+),\s*(\w+)\)\s+in\s+(hv_\w+)/
	my ($v_name, $v_val, $v_hv)=($1, $2, $3);
	MyDef::output_c::func_add_var("t_n");
	MyDef::output_c::func_add_var($v_name);
	MyDef::output_c::func_add_var($v_val);
	my $vartype=MyDef::output_c::get_var_type($v_val);
	MyDef::output_c::func_add_var("t_sv");
	my @pre;
	push @pre, "t_n=hv_iterinit($v_hv);"
	push @pre, "while((t_sv=hv_iternextsv($v_hv, &$v_name, &t_n))){";
	push @pre, "INDENT"
	translate_scalar(\@pre,$v_val,$vartype,"t_sv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$getparam\s+(.*)/
	my @vlist=split /,\s+/, $1;
	my $j=0;
	$foreach $v in @vlist
	    MyDef::output_c::func_add_var($v);
	    my $vartype=MyDef::output_c::get_var_type($v);
	    translate_scalar($out, $v, $vartype, "ST($j)");
	    $j++;
	return
    $elif $l=~/(\S+)=(\w+)->\{(.*)\}/
	my ($var, $hv, $key)=($1, $2, $3);
	$if $key=~/^['"](.*)['"]/
	    $key=$1;
	my $keylen=length($key);

	$if $var=~/^\w+$/
	    MyDef::output_c::func_add_var($var);
	my $vartype=MyDef::output_c::get_var_type($var);

	MyDef::output_c::func_add_var("t_psv", "SV**");
	push @$out, "t_psv=hv_fetch($hv, \"$key\", $keylen, 0);";
	translate_tpsv($out, $var, $vartype);
	return 
    $elif $l=~/(\S+)=(\w+)->\[(.*)\]/
	my ($var, $av, $key)=($1, $2, $3);
	my $vartype;
	$if $var=~/^\w+$/
	    MyDef::output_c::func_add_var($var);
	$vartype=MyDef::output_c::get_var_type($var);

	MyDef::output_c::func_add_var("t_psv", "SV**");
	push @$out, "t_psv=av_fetch($av, $key, 0);";
	translate_tpsv($out, $var, $vartype);
	return

subcode:: support_subs
    # ---- Perl XS Specific -----------------------
    $sub translate_scalar($out, $var, $vartype, $sv)
	#print "$var, $vartype\n";
	$if $vartype eq "int"
	    push @$out, "$var = SvIV($sv);";
	$elsif $vartype eq "double" or $vartype eq "float"
	    push @$out, "$var = SvNV($sv);";
	$elsif $vartype eq "char *"
	    func_add_var("t_strlen");
	    push @$out, "$var = SvPV($sv, t_strlen);";
	    push @$out, "$var\[t_strlen\] = '\\0';";
	$elsif $vartype =~ /^([SAH]V\*)/
	    push @$out, "$var = ($1)SvRV($sv);";
	$else
	    print "translate_scalar: unhandled $var - $vartype\n";

    $sub translate_null($out, $var, $vartype)
	$if $vartype !~/int|float|double/
	    push @$out, "    $var = NULL;";
	$elif $vartype eq "int"
	    push @$out, "    $var = 0;";
	$else
	    push @$out, "    $var = 0.0;";

    $sub translate_tpsv($out, $var, $vartype)
	push @$out, "if(t_psv){";
	push @$out, "INDENT";
	translate_scalar($out, $var, $vartype, "*t_psv");
	push @$out, "DEDENT";
	push @$out, "}";
	push @$out, "else{";
	translate_null($out, $var, $vartype);
	push @$out, "}";

    $sub translate_perl_cond($l, $out)
	$if $l=~/^\s*(\w+)->\{(.+)\}\s*$/
	    my ($hv, $key)=($1, $2);
	    my $keylen=length($key);
	    my $tl="hv_exists($hv, \"$key\", $keylen)";
	    return $tl;
	$elif $l=~/^\s*(\w+)->\[(.+)\]\s*$/
	    my ($hv, $key)=($1, $2);
	    my $tl="SvTRUE(*(av_fetch($hv, $key, 0)))";
	    return $tl;
	$else
	    return $l;

################################################
subcode: init_xs(block)
    push @$(block), "#include \"EXTERN.h\"\n";
    push @$(block), "#include \"perl.h\"\n";
    push @$(block), "#include \"XSUB.h\"\n";
    push @$(block), "\n";
    push @$(block), "#include \"ppport.h\"\n";
    push @$(block), "\n";
    $foreach my $l in @xs_globals
	push @$(block), $l;
    push @$(block), "\n";
    my $pagename=$page->{pagename}
    push @$(block), "MODULE = $pagename\t\tPACKAGE = $pagename\n";
    push @$(block), "\n";

subcode: process_function_xs
    my (@t0, @t1, @pre, @post);
    $func->{openblock}=\@t0;
    $func->{closeblock}=\@t1;
    $func->{preblock}=\@pre;
    $func->{postblock}=\@post;
    my $name=$func->{name};

    # ---- ret_type and parameters ------------------
    $if $name
	my $ret_type=$func->{'ret_type'};
	if(!$ret_type){$ret_type="void";}
	my $paramlist=$func->{'param_list'};
	my @param_name_list;
	foreach my $p(@$paramlist){
	    if($p=~/(\w+)\s*$/){
		push @param_name_list, $1;
	    }
	}
	my $param_name_list_str=join(",", @param_name_list);

	push @t0, "$ret_type";
	push @t0, "$name($param_name_list_str)";
	$if @$paramlist
	    push @pre, "INDENT";
	    $foreach my $p in @$paramlist
		push @pre, "$p;";
	    push @pre, "DEDENT";

    # ---- Local Variables ---------------------------
    my $var_decl=$func->{var_decl};
    my $var_list=$func->{'var_list'};
    $if @$var_list
	push @pre, "PREINIT:";
	push @pre, "INDENT";
	$foreach my $v in @$var_list
	    $if $global_type->{$v}
		print "  [warning] In $name: local variable $v with exisiting global\n"
	    push @pre, "$var_decl->{$v};";
	push @pre, "DEDENT";
    push @pre, "PPCODE:";
    push @pre, "INDENT";

    # ---- init and finish --------------------------
    $foreach my $tl in @{$func->{init}}
	push @pre, $tl;
    $foreach my $tl in @{$func->{finish}}
	push @post, $tl;
    $if $name
	push @post, "DEDENT";
	push @t1, "NEWLINE";

