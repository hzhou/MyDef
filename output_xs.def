include: output.def

/*
    xscode: xs_main 
	-- function_flags: xs_mode, skip_declare
	-- DUMP_START xs_start on xscode: xs_main
	    ---- dumps xs_globals
    on_init:
    on_parsecode:
    on_dumpout:
	process_function_xs
*/

page: output_xs, inherit_c
    type: pm
    output_dir: lib/MyDef
    ext: xs
    init_mode: sub
    package: MyDef::output_xs

subcode: on_init
    $$(C)type_prefix{"hv"}= "HV*"
    $$(C)type_prefix{"av"}= "AV*"
    $$(C)type_prefix{"sv"}= "SV*"

subcode: on_dumpout
    # ---- process_function ------------------------
    my $funclist=MyDef::dumpout::get_func_list()
    $foreach $func in @$funclist
	$if $func->{xs_mode}
	    $call process_function_xs
	    $func->{processed}=1

    # ---- xs globals ----------------
    $global @xs_globals
    my @t
    my $cnt
    my $ghash=$$(C)global_hash
    $foreach $name in @$(C)global_list
	my $v=$ghash->{$name}
	$if $v=~/^[SHA]V/
	    push @xs_globals, "$v;\n";
	    $cnt++
	$else
	    push @t, $name
    $if $cnt>0
	@$(C)global_list=@t

    # ---- xs_start -------------------
    $call init_xs

subcode: init_xs
    my $block=MyDef::compileutil::get_named_block("xs_start")
    push @$block, "#include \"EXTERN.h\"\n";
    push @$block, "#include \"perl.h\"\n";
    push @$block, "#include \"XSUB.h\"\n";
    push @$block, "\n";
    push @$block, "#include \"ppport.h\"\n";
    push @$block, "\n";
    $foreach my $l in @xs_globals
	push @$block, $l;
    push @$block, "\n";
    my $pagename=$(Cpage)->{pagename}
    push @$block, "MODULE = $pagename\t\tPACKAGE = $pagename\n";
    push @$block, "\n";

# *** Custom syntax ***
subcode: on_parsecode
    my $out=$(Cout)
    $if $l=~/^XS_START/
	$(C)parsecode("NOOP POST_MAIN")
	$global $xs_started
	$l= "DUMP_STUB xs_start"
	$$(C)function_flags{"xs_mode"}= 1
	$$(C)function_flags{"skip_declare"}= 1
	$xs_started=1
    $elif $l=~/^\s*(\$if|while|elif|elsif|elseif)\s*(.*)/
	$l="$1 ".translate_perl_cond($2, $out);
    $elsif $l=~/^\$foreach\s+(\w+)\s+in\s+(av_\w+)/
	my $v_i=$1;
	my $v_av=$2;
	my $v_idx=$2."_index"
	$(C)func_add_var($v_idx, "int")
	$(C)func_add_var($v_i)
	my $vartype=$(C)get_var_type($v_i);
	$(C)func_add_var("t_psv")
	my @pre;
	push @pre, "for($v_idx=0; $v_idx<=av_len($v_av); $v_idx++){"
	push @pre, "INDENT"
	push @pre, "t_psv=av_fetch($v_av, $v_idx, 0);"
	translate_scalar(\@pre, $v_i, $vartype, "*t_psv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return $(C)single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$foreach\s+\((\w+),\s*(\w+)\)\s+in\s+(hv_\w+)/
	my ($v_name, $v_val, $v_hv)=($1, $2, $3);
	$(C)func_add_var("t_n");
	$(C)func_add_var($v_name);
	$(C)func_add_var($v_val);
	my $vartype=$(C)get_var_type($v_val);
	$(C)func_add_var("t_sv");
	my @pre;
	push @pre, "t_n=hv_iterinit($v_hv);"
	push @pre, "while((t_sv=hv_iternextsv($v_hv, &$v_name, &t_n))){";
	push @pre, "INDENT"
	translate_scalar(\@pre,$v_val,$vartype,"t_sv")
	my @post
	push @post, "DEDENT"
	push @post, "}"
	return $(C)single_block_pre_post(\@pre, \@post)
    $elsif $l=~/^\$getparam\s+(.*)/
	my @vlist=split /,\s+/, $1;
	my $j=0;
	$foreach $v in @vlist
	    $(C)func_add_var($v);
	    my $vartype=$(C)get_var_type($v);
	    translate_scalar($out, $v, $vartype, "ST($j)");
	    $j++;
	return
    $elif $l=~/(\S+)=(\w+)->\{(.*)\}/
	my ($var, $hv, $key)=($1, $2, $3);
	$if $key=~/^['"](.*)['"]/
	    $key=$1;
	my $keylen=length($key);

	$if $var=~/^\w+$/
	    $(C)func_add_var($var);
	my $vartype=$(C)get_var_type($var);

	$(C)func_add_var("t_psv", "SV**");
	push @$out, "t_psv=hv_fetch($hv, \"$key\", $keylen, 0);";
	translate_tpsv($out, $var, $vartype);
	return 
    $elif $l=~/(\S+)=(\w+)->\[(.*)\]/
	my ($var, $av, $key)=($1, $2, $3);
	my $vartype;
	$if $var=~/^\w+$/
	    $(C)func_add_var($var);
	$vartype=$(C)get_var_type($var);

	$(C)func_add_var("t_psv", "SV**");
	push @$out, "t_psv=av_fetch($av, $key, 0);";
	translate_tpsv($out, $var, $vartype);
	return

subcode:: support_subs
    # ---- Perl XS Specific -----------------------
    $sub translate_scalar($out, $var, $vartype, $sv)
	#print "$var, $vartype\n";
	$if $vartype eq "int"
	    push @$out, "$var = SvIV($sv);";
	$elsif $vartype eq "double" or $vartype eq "float"
	    push @$out, "$var = SvNV($sv);";
	$elsif $vartype eq "char *"
	    $(C)func_add_var("t_strlen");
	    push @$out, "$var = SvPV($sv, t_strlen);";
	    push @$out, "$var\[t_strlen\] = '\\0';";
	$elsif $vartype =~ /^([SAH]V\*)/
	    push @$out, "$var = ($1)SvRV($sv);";
	$else
	    print "translate_scalar: unhandled $var - $vartype\n";

    $sub translate_null($out, $var, $vartype)
	$if $vartype !~/int|float|double/
	    push @$out, "    $var = NULL;";
	$elif $vartype eq "int"
	    push @$out, "    $var = 0;";
	$else
	    push @$out, "    $var = 0.0;";

    $sub translate_tpsv($out, $var, $vartype)
	push @$out, "if(t_psv){";
	push @$out, "INDENT";
	translate_scalar($out, $var, $vartype, "*t_psv");
	push @$out, "DEDENT";
	push @$out, "}";
	push @$out, "else{";
	translate_null($out, $var, $vartype);
	push @$out, "}";

    $sub translate_perl_cond($l, $out)
	$if $l=~/^\s*(\w+)->\{(.+)\}\s*$/
	    my ($hv, $key)=($1, $2);
	    my $keylen=length($key);
	    my $tl="hv_exists($hv, \"$key\", $keylen)";
	    return $tl;
	$elif $l=~/^\s*(\w+)->\[(.+)\]\s*$/
	    my ($hv, $key)=($1, $2);
	    my $tl="SvTRUE(*(av_fetch($hv, $key, 0)))";
	    return $tl;
	$else
	    return $l;

################################################
subcode: process_function_xs
    my (@t0, @t1, @pre, @post);
    $func->{openblock}=\@t0;
    $func->{closeblock}=\@t1;
    $func->{preblock}=\@pre;
    $func->{postblock}=\@post;
    my $name=$func->{name};

    # ---- ret_type and parameters ------------------
    $if $name
	my $ret_type=$func->{'ret_type'};
	if(!$ret_type){$ret_type="void";}
	my $paramlist=$func->{'param_list'};
	my @param_name_list;
	$foreach $p in @$paramlist
	    $if $p=~/(\w+)\s*$/
		push @param_name_list, $1
	my $param_name_list_str=join(",", @param_name_list);

	push @t0, "$ret_type";
	push @t0, "$name($param_name_list_str)";
	$if @$paramlist
	    push @pre, "INDENT";
	    $foreach my $p in @$paramlist
		push @pre, "$p;";
	    push @pre, "DEDENT";

    # ---- Local Variables ---------------------------
    my $var_decl=$func->{var_decl};
    my $var_list=$func->{'var_list'};
    $if @$var_list
	push @pre, "PREINIT:";
	push @pre, "INDENT";
	$foreach my $v in @$var_list
	    $if $$(C)global_type->{$v}
		print "  [warning] In $name: local variable $v with exisiting global\n"
	    push @pre, "$var_decl->{$v};";
	push @pre, "DEDENT";
    push @pre, "PPCODE:";
    push @pre, "INDENT";

    # ---- init and finish --------------------------
    $foreach my $tl in @{$func->{init}}
	push @pre, $tl;
    $foreach my $tl in @{$func->{finish}}
	push @post, $tl;
    $if $name
	push @post, "DEDENT";
	push @t1, "NEWLINE";

