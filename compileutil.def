page: compileutil
    type: pm
    output_dir: lib/MyDef
    subcode: main
	$call compile_main

subcode: compile_main
    package MyDef::compileutil;

    #--- Context
    our $deflist;
    our $modelist;

    our $f_init;
    our $f_parse;
    our $f_modeswitch;
    our $f_dumpout;

    sub set_interface {
	($f_init, $f_parse, $f_modeswitch, $f_dumpout)=@_;
	#print "setting interface: f_init=$f_init\n";
    }

    # ---------------------------------------------------
    our $out;
    our @output_list;
    our @block_stack;    # maintain state for each parseblock
    our @callback_stack; # &call
    our %named_blocks;   # $(block: name)

    sub init_output {
	@output_list=([]);
	$out=$output_list[0];
	return $output_list[0];
    }

    sub new_output {
	my $flag_nest=shift;
	my $out=[];
	push @output_list, $out;
	if($flag_nest and @callback_stack){
	    # -- flag_nest==1 when "BLOCK" inside &call sub
	    my $outlist=$callback_stack[-1];
	    push @$outlist, $out;
	}
	my $nidx=$#output_list;
	return $nidx;
    }

    sub fetch_output {
	my $n=shift;
	return $output_list[$n];
    }
    # ---------------------------------------------------
    sub parse_code {
	my ($code)=@_;
	my $srclist=$code->{source};
	modepush($code->{type});
	parseblock($srclist);
	modepop();
    }
    sub compile {
	my ($pagename)=@_;

	my $page=$MyDef::def->{pages}->{$pagename};
	init_output();
	my ($ext, $mode)=$f_init->($page);
	print STDERR "PAGE: $pagename\n";

	#---- save var
	my %varsave;
	while(my ($k, $v)=each %$page){
	    $varsave{$k}=$MyDef::var->{$k};
	    $MyDef::var->{$k}=$v;
	}
	#---- compile
	$deflist=[$MyDef::def, $MyDef::def->{macros}, $page];
	$modelist=[$mode];

	#---- autoload
	my $codelist=$MyDef::def->{codes};
	foreach my $codename (keys %$codelist){
	    if($codename=~/_autoload$/){
		parse_code($codelist->{$codename});
	    }
	}

	#---- main
	my $maincode=$page->{codes}->{main};
	if(!$maincode){
	    $maincode=$MyDef::def->{codes}->{main};
	}
	parse_code($maincode);

	#---- restore var
	while(my ($k, $v)=each %varsave){
	    $MyDef::var->{$k}=$v;
	}
	
	#---- Dump
	if(!$page->{subpage}){
	    my @buffer;
	    $f_dumpout->(\@buffer, fetch_output(0));
	    return (\@buffer, $ext);
	}
    }

    sub output {
	my ($pagename, $plines, $ext)=@_;
	my $page=$MyDef::def->{pages}->{$pagename};

	$pagename=$page->{pagename};
	my $outdir=".";
	if($MyDef::var->{output_dir}){
	    $outdir=$MyDef::var->{output_dir};
	}
	if($page->{output_dir}){
	    if($page->{output_dir}=~/^\//){
		$outdir=$page->{output_dir};
	    }
	    else{
		$outdir=$outdir."/".$page->{output_dir};
	    }
	}
	$outdir=~s/^\s+//;
	# create output dir
	if(! -d $outdir){
	    my @tdir_list=split /\//, $outdir;
	    my $tdir;
	    my $slash=0;
	    foreach my $t (@tdir_list){
		if(!$slash){
		    $tdir=$t;
		    $slash=1;
		}
		else{
		    $tdir=$tdir.'/'.$t;
		}
		if(!$tdir){next;}
		if(! -d $tdir){
		    mkdir $tdir or die "Can't create output directory: $tdir\n";
		}
	    }
	}

	if($ext eq "ch"){
	    my $outname_c=$outdir."/".$pagename.".c";
	    my $outname_h=$outdir."/".$pagename.".h";
	    print "  --> [$outname_c], [$outname_h]\n";

	    open Out_c, ">$outname_c" or die "Can't write $outname_c\n";
	    open Out_h, ">$outname_h" or die "Can't write $outname_h\n";
	    my $start_h=0;
	    foreach my $l(@$plines){
		if($start_h){
		    if($l=~/END_H/){
			$start_h=0;
		    }
		    else{
			print Out_h $l;
		    }
		}
		else{
		    if($l=~/START_H/){
			$start_h=1;
		    }
		    else{
			if(substr($l, 0, 2) eq "H:"){
			    print Out_h substr($l, 2);
			}
			else{
			    print Out_c $l;
			}
		    }
		}
	    }
	    close Out_c;
	    close Out_h;
	}
	else{
	    my $outname=$outdir."/".$pagename;
	    if($ext){
		$outname.=".$ext";
	    }
	    print "  --> [$outname]\n";

	    my $subfile=0;
	    open Out, ">$outname" or die "Can't write $outname\n";
	    foreach my $l(@$plines){
		if($subfile){
		    if($l=~/^END_SUBFILE/){
			$subfile=0;
			close Subfile;
		    }
		    else{
			print Subfile $l;
		    }
		}
		else{
		    if($l=~/^START_Makefile/){
			if(!-f "$outdir/Makefile"){
			    print "Write $outdir/Makefile\n";
			    open Subfile, ">$outdir/Makefile" or die "Can't write $outdir/Makefile";
			    $subfile=1;
			    print Subfile "$pagename: $pagename.$ext\n";
			}
			else{
			    open Subfile, ">/dev/null";
			    $subfile=1;
			}
		    }
		    elsif($l=~/^START_h/){
			open Subfile, ">$outdir/$pagename.h" or die "Can't write $outdir/$pagename.h";
			$subfile=1;
		    }
		    else{
			print Out $l;
		    }
		}
	    }
	    close Out;
	}
    }

    # --------------------------------------------------------
    sub parseblock {
	my ($block)=@_;
	my $indent=0;
	my $context;
	my $lindex=0;

	my @indent_stack;
	my @output_stack;

	my $debug; 
	foreach my $b (@block_stack){
	    if($b->{debug}){
		$debug=1;
		last;
	    }
	}
	if($debug){
	    $f_parse->("DEBUG ON");
	}
	else{
	    $f_parse->("DEBUG OFF");
	}
	# ---- protect $out context
	push @block_stack, {out=>$out};

	while($lindex<@$block){
	    my $l=$block->[$lindex];
	    if($debug){ print "SRC: $l\n";}
	    $lindex++;

	    if($l eq "DEBUG"){
		$block_stack[-1]->{debug}=1;
		$debug=1;
		$f_parse->("DEBUG ON");
		next;
	    }
	    # -- handle block code
	    elsif(@indent_stack and $indent==$indent_stack[-1]){
		# $block 
		#     blockcodes
		# 
		if($l eq "SOURCE_INDENT"){
		    # -- start a block
		    $out=$output_stack[-1];
		    $indent++;
		    next;
		}
		else{
		    # -- must be an empty block
		    pop @indent_stack;
		    pop @output_stack;
		}
	    }
	    elsif(@indent_stack and $indent-1==$indent_stack[-1]){
		# Once we are inside the block, we need check exit
		if($l eq "SOURCE_DEDENT"){
		    pop @indent_stack;
		    pop @output_stack;
		    if(@output_stack){
			$out=$output_stack[-1];
		    }
		    else{
			$out=$block_stack[-1]->{out};
		    }
		    $indent--;
		    next;
		}
	    }

	    # -- maintain indent level
	    if($l eq "SOURCE_INDENT"){ 
		$indent++; 
	    }
	    elsif($l eq "SOURCE_DEDENT"){ 
		$indent-- if $indent>0; 
	    }
	    elsif($l eq "BLOCK"){
		my $n=new_output(1);
		$l="BLOCK_$n";
	    }

	    # -- handle preproc and out-of-switch
	    if($l=~/^\$\(for:\s*(\S+)\s+in\s+(.*)\)/){
		my $vname=$1;
		my $vparam=$2;
		my @tlist=split /,\s*/, $vparam;
		my $subblock=grabblock($block, \$lindex);
		foreach my $t(@tlist){
		    my $macro={$vname=>$t};
		    push @$deflist, $macro;
		    parseblock($subblock);
		    pop @$deflist;
		}
	    }
	    elsif($l=~/^\$\(export:\s*([^)]+)=(.*)\)/){
		$deflist->[-2]->{$1}=$2;
	    }
	    elsif($l=~/^\$\(export:\s*([^)]+)\)/){
		my $t=get_def($1);
		$deflist->[-2]->{$1}=$t;
	    }
	    elsif($l=~/^\$\(set:\s*([^)]+)=(.*)\)/){
		$deflist->[-1]->{$1}=$2;
	    }
	    elsif($l=~/^\$\(set:\s*([^)]+)\+=(\d+)\)/){
		my $i=@$deflist;
		while($i>0 and !defined $deflist->[$i]->{$1}){
		    $i--;
		}
		$deflist->[$i]->{$1}+=$2;
	    }
	    elsif($l=~/^\$\(preset:([^:]+):(.*)\)/){
		my $preset=$1;
		my $t=$2;
		foreach my $tt(split /,/, $t){
		    $deflist->[-1]->{$tt}="$preset$tt";
		}
	    }
	    elsif($l=~/^\$\(if:\s*(.*)\)/){
		my $subblock=grabblock($block, \$lindex);
		#foreach my $t(@$subblock){ print "\t[$t]\n"; }
		if(testcondition($1)){
		    #print "testcondition [$1] = 1\n";
		    #foreach my $t(@$subblock){ print "\t[$t]\n"; }
		    parseblock($subblock);
		    $context="switch_off";
		}
		else{
		    #print "testcondition [$1] = 0\n";
		    $context="switch_on";
		}
	    }
	    elsif($l=~/^\$\(els?e?if:\s*(.*)\)/){
		my $subblock=grabblock($block, \$lindex);
		if($context eq "switch_on"){
		    if(testcondition($1)){
			#foreach my $t(@$subblock){ print "\t[$t]\n"; }
			parseblock($subblock);
			$context="switch_off";
		    }
		    else{
			$context="switch_on";
		    }
		}
	    }
	    elsif($l=~/^\$\(else\)/){
		my $subblock=grabblock($block, \$lindex);
		if($context eq "switch_on"){
		    parseblock($subblock);
		    undef $context;
		}
	    }
	    elsif($l=~/^\$\(block:(\w+)\)/){
		my $name=$1;
		my $subblock=grabblock($block, \$lindex);
		my $n=new_output();
		if(!$named_blocks{$name}){
		    $named_blocks{$name}=[];
		}
		push @{$named_blocks{$name}}, "BLOCK_$n";

		my $temp=$out;
		$out=$output_list[-1];
		$f_parse->("SCOPE: $name", $modelist->[-1], $out);
		parseblock($subblock);
		$f_parse->("SCOPE: NONE", $modelist->[-1], $out);
		$out=$temp;
	    }
	    else{
		undef $context;
		expand_macro_recurse(\$l);
		if($l=~/^\s*\$(call|map|list)\s+(.*)$/){
		    my $func=$1;
		    my $param=$2;
		    $param=~s/\s*$//;
		    if($func eq "map"){
			call_sub($param, 1);
		    }
		    elsif($func eq "call"){
			call_sub($param, 0);
		    }
		    elsif($func eq "list"){
			list_sub($param);
		    }
		}
		elsif($l=~/^\s*&call\s+(.*)$/){
		    my $param=$1;
		    $param=~s/\s*$//;
		    my @tlist;
		    push @callback_stack, \@tlist;
		    call_sub($param, 0);
		    pop @callback_stack;
		    while(my $o=shift @tlist){
			push @indent_stack, $indent;
			push @output_stack, $o;
		    }
		}
		else{
		    my $idx=$#$out+1;
		    my $output;

		    my $msg=$f_parse->($l, $modelist->[-1], $out);
		    if(!$msg){
		    }
		    elsif(ref($msg) eq "ARRAY"){
			# output is held until post processing
			#     eg. output_apple.pm $method
			$output=$msg;
			$idx=0;
		    }
		    elsif($msg=~/^NEWBLOCK/){
			# check the new output for blocks
			#     eg. cfunctions.pm single_block
			$output=$out;
		    }
		    elsif($msg=~/^SET:(\w+)=(.*)/){
			# set/reset definitions
			#     eg. cfunctions.pm get_pointer_type
			$deflist->[-1]->{$1}=$2;
		    }
		    if($output){
			for(my $i=$idx; $i<=$#$output; $i++){
			    if($output->[$i]=~/^BLOCK$/){
				# -- need comment on multi-blocks
				my $n=new_output();
				$output->[$i]="BLOCK_$n";
				push @indent_stack, $indent;
				push @output_stack, $output_list[-1];
			    }
			    elsif($output->[$i]=~/^CALL\s+(.+)/){
				# -- calling macros in 2nd stage codes
				#    eg. std_ios.def
				my $n=new_output();
				$output->[$i]="BLOCK_$n";
				my $temp=$out;
				$out=$output_list[-1];
				call_sub($1, 0);
				$out=$temp;
			    }
			}
		    }
		}
	    }
	}
	pop @block_stack;
	# We should always have balanced SOURCE_INDENT/SOURCE_DEDENT
	# But if not, we'll catch it here
	if(@indent_stack){
	    die "Indent_stack mismatch [$block->[0] ... $block->[-1]\n";
	    while(pop @indent_stack){
		pop @output_stack;
	    }
	}
    }

    sub grabblock {
	my ($block, $index_ref)=@_;
	my @sub;
	my $indent;
	my $lindex=$$index_ref;
	if($block->[$lindex] ne "SOURCE_INDENT"){
	    return \@sub;
	}
	else{
	    $indent=1;
	    $lindex++;
	}
	while($lindex<@$block){
	    if($block->[$lindex]=~/SOURCE_DEDENT/){
		$indent-- if $indent>0;
		if($indent==0){
		    $lindex++;
		    last;
		}
	    }
	    if($block->[$lindex]=~/SOURCE_INDENT/){ 
		$indent++; 
	    }
	    push @sub, $block->[$lindex];
	    $lindex++;
	}
	$$index_ref=$lindex;
	#foreach my $l(@sub){print "grabblock: [$l]\n";}
	return \@sub;
    }

    sub list_sub {
	my ($param)=@_;
	my @plist=split(/,\s*/, $param);
	foreach my $codename(@plist){
	    my $codelib=get_def_attr("codes", $codename);
	    my $params=$codelib->{params};
	    my $source=$codelib->{source};
	    my $line=$codename."-".join(",", @$params);
	    push @$modelist, "$codelib->{type}";
	    $f_modeswitch->($codelib->{type}, $line, $out);
	    parseblock(["SOURCE_INDENT"]);
	    parseblock($source);
	    parseblock(["SOURCE_DEDENT"]);
	    pop @$modelist;
	}
    }

    sub call_sub {
	my ($param, $domap)=@_;
	my $codename;
	my $attr;
	my (@pre_plist, $pline, @plist);
	if($param=~/^(@)?(\w+)(.*)/){
	    $attr=$1;
	    $codename=$2;
	    my $t=$3;
	    if($t=~/\(([^\)]*)\)/){
		my $t1=$1;
		my $t-$';
		@pre_plist=split /,\s*/, $t1;
	    }
	    $t=~s/^\s*,?\s*//;
	    $pline=$t;
	    # ---- Single parameter slurp
	    #      (_f for format such as in printf)
	    if($codename=~/_f$/){
		$t=~s/^\s*,\s*//;
		push @plist, $t;
	    }
	    # ---- '|' seperated param list
	    elsif($t=~/\|/){
		# '|' seprated param list
		@plist=split /\s*\|\s*/, $t;
	    }
	    else{
		@plist=split /,\s*/, $t;
	    }
	}
	else{
	    print STDERR "    call_sub [$param] parse failure\n";
	    return;
	}
	my $codelib=get_def_attr("codes", $codename);
	if(!$codelib and $attr ne '@'){
	    print STDERR "    Code $codename not found!\n";
	    return;
	}
	modepush($codelib->{type});
	my $params=$codelib->{params};
	my $source=$codelib->{source};
	my $np=@pre_plist;
	if(1==@$params and $params->[0]=~/^@(\w+)/){
	    my $macro={$1=>$pline};
	    push @$deflist, $macro;
	    parseblock($source);
	    pop @deflist;
	}
	elsif($domap){
	    if(1+@pre_plist!=@$params){
		warn " Code $codename parameter mismatch.\n";
	    }
	    foreach my $item (@plist){
		my $macro={$params->[$np]=>$item};
		if($np){
		    for(my $i=0; $i<$np; $i++){
			$macro->{$params->[$i]}=$pre_plist[$i];
		    }
		}
		push @$deflist, $macro;
		parseblock($source);
		pop @$deflist;
	    }
	}
	else{
	    if($np+@plist!=@$params){
		my $n2=@plist;
		my $n3=@$params;
		my $pline=join(', ', @plist);
		warn "    code $codename parameter mismatch ($np + $n2) != $n3. [pline:$pline]\n";
	    }
	    my $macro={};
	    for(my $i=0; $i<$np; $i++){
		$macro->{$params->[$i]}=$pre_plist[$i];
	    }
	    for(my $j=0; $j<@$params-$np; $j++){
		my $p=$params->[$np+$j];
		#if($plist[$j]=~/^"(.*)"$/){ $macro->{$p}=$1; } else{ $macro->{$p}=$plist[$j]; }
		#print "  :|$p: $plist[$j]\n";
		$macro->{$p}=$plist[$j];
	    }
	    push @$deflist, $macro;
	    parseblock($source);
	    pop @$deflist;
	}
	modepop();
    }

    # --------------------------------------------------------
    sub get_def {
	my ($name)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    if(defined $deflist->[$i]->{$name}){
		return $deflist->[$i]->{$name};
	    }
	}
	return undef;
    }

    sub get_def_attr {
	my ($name, $attr)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    my $t=$deflist->[$i]->{$name};
	    if($t and $t->{$attr}){
		return $t->{$attr};
	    }
	}
	return undef;
    }

    sub expand_macro {
	my ($lref, $macros)=@_;
	my $hasmacro=0;
	while ($$lref=~/\$\([^)]+\)/){
	    #print "expand_macro: $$lref\n";
	    my @segs=split /(\$\([^)]+\))/, $$lref;
	    my $j=0;
	    my $flag=0;
	    foreach my $s (@segs){
		if($s=~/^\$\((\w+)\.(\w+)\)/){
		    my $t=$macros->{$1};
		    if($t){
			my $tt=$MyDef::def->{fields}->{$t};
			if($tt){
			    if($tt->{$2}){
				$segs[$j]=$tt->{$2};
				$flag++;
			    }
			    elsif($2 eq "title"){
				$segs[$j]=$t;
				$flag++;
			    }
			    else{
				$segs[$j]="";
			    }
			}
			else{
			    if($2 eq "title"){
				$segs[$j]=$t;
				$flag++;
			    }
			    else{
				#print "Macro $t.$2 not found!\n";
			    }
			}
		    }
		}
		elsif($s=~/^\$\((\w+):(\d+)-(\d+)\)/){
		    my $t=$macros->{$1};
		    #print "expand_macro: $s, $1: $t\n";
		    if($t){
			$segs[$j]=substr($t, $2, $3-$2+1);
			$flag++;
		    }
		}
		elsif($s=~/^\$\((.+)\)/){
		    if(exists($macros->{$1})){
			my $t=$macros->{$1};
			if($t eq $s){
			    die "Looping macro $1 in \"$$lref\"!\n";
			}
			$segs[$j]=$t;
			$flag++;
		    }
		    #print "Macro: [$1] [$macros->{$1}]\n";
		}
		$j++;
	    }
	    if($flag){
		$$lref=join '', @segs;
	    }
	    else{
		$hasmacro=1;
		last;
	    }
	}
	return $hasmacro;
    }

    sub expand_macro_recurse {
	my $lref=shift;
	for(my $j=$#$deflist; $j>=0; $j--){
	    my $hasmacro=expand_macro($lref, $deflist->[$j]);
	    if(!$hasmacro){
		last;
	    }
	}
    }

    sub testcondition {
	my ($name)=@_;
	if(!$name){
	    return 0;
	}
	elsif($name=~/ or /){
	    my @nlist=split / or /, $name;
	    foreach my $n(@nlist){
		if(testcondition($n)){
		    return 1;
		}
	    }
	    return 0;
	}
	elsif($name=~/,/){
	    my @nlist=split /,/, $name;
	    foreach my $n(@nlist){
		if(!testcondition($n)){
		    return 0;
		}
	    }
	    return 1;
	}
	elsif($name=~/(\w+)\.(\w+)/){
	    if($1 eq "fields"){
		if ($MyDef::def->{fields}->{$2}){
		    return 1;
		}
	    }
	    else{
		my $t=get_def($1);
		if($t){ 
		    if ($MyDef::def->{fields}->{$t}->{$2}){
			return 1;
		    }
		}
	    }
	}
	elsif($name=~/(\w+)(:\d+)?(~|=|!=|<|>)(.*)/){
	    my $t=get_def($1);
	    my ($tail, $test, $value)=($2, $3, $4);
	    if($tail=~/:(\d+)/){
		$t=substr($t, 0, $1);
	    }
	    if($test eq "="){
		if($t eq $value){ return 1;}
	    }
	    elsif($test eq "!="){
		if($t ne $value){ return 1;}
	    }
	    elsif($test eq ">"){
		if($t > $value){ return 1;}
	    }
	    elsif($test eq "<"){
		if($t < $value){ return 1;}
	    }
	    elsif($test eq "~"){
		if($t=~/$value/){ return 1;}
	    }
	}
	else{
	    if(get_def($name)){
		return 1;
	    }
	}
	return 0;
    }

    # MODES
    sub modepush {
	my ($mode)=@_;
	my $pmode=$modelist->[-1];
	push @$modelist, $mode;
	if($pmode ne $mode){
	    $f_modeswitch->($pmode, $mode, $out);
	}
    }

    sub modepop {
	my $pmode=pop @$modelist;
	my $mode=$modelist->[-1];
	if($pmode ne $mode){
	    $f_modeswitch->($pmode, $mode, $out);
	}
    }


    1;
