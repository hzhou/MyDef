include: macros_util/debug.def

# search point: subcode: parse_preproc

page: compileutil
    type: pm
    output_dir: lib/MyDef
    subcode: main
	$call compile_main

subcode: compile_main
    package MyDef::compileutil;
    $call package_global
    $call manage_output
    $call support_subs
    # ---------------------------------------------------
    $sub compile
	my ($pagename)=@_;
	my $page=$MyDef::def->{pages}->{$pagename};
	$call output_outdir
	$page->{outdir}=$outdir
	$call compile

    $sub output
	my ($pagename, $plines, $ext)=@_;
	my $page=$MyDef::def->{pages}->{$pagename};
	my $outdir=$page->{outdir}

	my $outname=$outdir."/".$pagename;
	$if $ext
	    $outname.=".$ext";
	print "  --> [$outname]\n";

	open Out, ">$outname" or die "Can't write $outname\n";
	$foreach my $l in @$plines
	    print Out $l;
	close Out;

    $sub parse_code
	my ($code)=@_;
	my $srclist=$code->{source};
	modepush($code->{type});
	parseblock($srclist);
	modepop();

    # --------------------------------------------------------
    $sub parseblock
	my ($block)=@_;
	my $indent=0;
	my $context;
	my $lindex=0;

	my $callback_output;
	my @callback_stack; # &call
	my $pending_mode_pop;
	$call parse_stack_push

	$while $lindex<@$block
	    my $l=$block->[$lindex];
	    $if $debug eq "compile"
		$call dump_line, compile
	    $lindex++;

	    # -- such as DEBUG
	    $call parse_catch_meta
	    # -- such as indentation and BLOCK_n
	    $call parse_filter_meta
	    # -- handle preproc and out-of-switch
	    $if $l=~/^\$\((else|\w+:.*)\)/
		my $preproc=$1
		$call parse_preproc
	    $else
		NormalParse:
		undef $context;
		expand_macro_recurse(\$l);
		$while 1
		    # -- parse_line could return a new $l
		    # -- otherwise, last in the end breaks the loop
		    $if $l=~/^(&call|\$call|\$map|\$list)\s+(.*)$/
			my ($func, $param)=($1, $2);
			$call parse_call_sub
		    $else
			$call parse_line
		    last
	$call parse_stack_pop

    $sub set_macro($m, $p)
	$if $p=~/(\S+?)=(.*)/
	    my ($t1, $t2)=($1, $2)
	    $if $t1=~/\$\(.*\)/
		expand_macro_recurse(\$t1)
	    $if $t2=~/\$\(.*\)/
	        expand_macro_recurse(\$t2, 1)
	    $m->{$t1}=$t2
	$elif my $t=get_def($p)
	    $m->{$p}=$t
	$else
	    warn "compileutil::set_macro parse error: [$p]\n"
    # --------------------------------------------------------
    1;

######## Parse Output Stacks ######################################
subcode: parse_stack_push
    # ---- protect $out context
    push @block_stack, {out=>$out};
subcode: parse_stack_pop
    my $blk=pop @block_stack;
    $if $blk->{debug}
	$f_parse->("DEBUG OFF");
	$debug=0

subcode: debug_block(name, idx)
    $if $debug eq "block"
	print "$(name): \n";
	$foreach $i in $(idx),$(idx)+1,$(idx)+2,$(idx)+3
	    print "  $i: $$(name)->[$i]\n"
	print "      ...\n"
	my $i= $#$$(name)
	print "  $i: $$(name)->[$i]\n"

######## Parsing routines  ######################################
subcode: parse_filter_meta
    # -- maintain indent level
    $if $l eq "SOURCE_INDENT" 
	$indent++; 
    $elsif $l eq "SOURCE_DEDENT" 
	$indent-- if $indent>0; 

subcode: parse_catch_meta
    $if $l =~ /^DEBUG (\w+)/
	$block_stack[-1]->{debug}=1;
	$if $1 eq "OFF"
	    $debug=0
	$elif $1 eq "MACRO"
	    $call dump_deflist
	$else
	    $debug=$1
	$f_parse->("DEBUG $1");
	next;
subcode: parse_preproc
    $if $preproc=~/^for:\s*(\S+)\s+in\s+(.*)/
	my $vname=$1;
	my $vparam=$2;
	my @tlist;
	$if $vparam=~/(\d+)\.\.(\d+)/
	    for(my $i=$1;$i<=$2; $i++){
		push @tlist, $i
	    }
	$else
	    @tlist=split /,\s*/, $vparam;

	my $subblock=grabblock($block, \$lindex);
	$foreach my $t in @tlist
	    my $macro={$vname=>$t};
	    push @$deflist, $macro;
	    parseblock($subblock);
	    pop @$deflist;
    $elsif $preproc=~/^reset:\s*(\w+)([+])?=(.*)/
	my ($v, $op, $d)=($1, $2, $3)
	expand_macro_recurse(\$d)
	my $i=@$deflist;
	$while $i>0 and !defined $deflist->[$i]->{$v}
	    $i--;
	$if $op
	    $if $op eq '+'
		$deflist->[$i]->{$v}+=$d;
	$else
	    $deflist->[$i]->{$v}=$d;
    $elsif $preproc=~/^eval:\s*(\w+)=(.*)/
	my ($t1,$t2)=($1,$2)
	expand_macro_recurse(\$t2)
	$deflist->[-1]->{$t1}=eval($t2)
    $elsif $preproc=~/^set:\s*(.*)/
	set_macro($deflist->[-1], $1)
    $elsif $preproc=~/^export:\s*(.*)/
	set_macro($deflist->[-2], $1)
    $elsif $preproc=~/^mset:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-1], $p)
    $elsif $preproc=~/^mexport:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-2], $p)
    $elsif $preproc=~/^preset:([^:]+):(.*)/
	my $preset=$1;
	my $t=$2;
	foreach my $tt(split /,/, $t){
	    $deflist->[-1]->{$tt}="$preset$tt";
	}
    $elsif $preproc=~/^if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if testcondition($1)
	    parseblock($subblock);
	    $context="switch_off";
	$else
	    $context="switch_on";
    $elsif $preproc=~/^els?e?if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    $if testcondition($1)
		#foreach my $t(@$subblock){ print "\t[$t]\n"; }
		parseblock($subblock);
		$context="switch_off";
	    $else
		$context="switch_on";
    $elsif $preproc=~/^else/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    parseblock($subblock);
	    undef $context;
    $elsif $preproc=~/^block:(\w+)/
	my $name=$1;
	$call parse_named_block
    $else
	goto NormalParse

subcode:: package_global	
    our %named_blocks;   # $(block: name)

    $sub get_named_block
	my $name=shift
	$if !$named_blocks{$name}
	    $named_blocks{$name}=[]
	return $named_blocks{$name}

subcode: parse_named_block
    my $subblock=grabblock($block, \$lindex);
    $if !$named_blocks{$name}
	$named_blocks{$name}=[];
    my $output=$named_blocks{$name}

    my $temp=$out;
    set_output($output)
    $f_parse->("SCOPE: $name");
    parseblock($subblock);
    $f_parse->("SCOPE: NONE");
    set_output($temp)

subcode: parse_call_sub
    $param=~s/\s*$//;
    $if $func eq "\$map"
	call_sub($param, $func);
    $elif $func eq "\$call"
	call_sub($param);
    $elif $func eq "\$list"
	list_sub($param);
    $elif $func eq "\&call"
	my @callback_list=callback_sub($param, $func);
	$foreach $n in @callback_list
	    $call parse_handle_block, $n
	modepop()

subcode: parse_line
    undef $callback_output
    my $idx=$#$out+1;
    my $msg=$f_parse->($l);
    my @tails
    $if $msg
	$if ref($msg) eq "ARRAY"
	    # output is held until post processing
	    #     eg. output_apple.pm $method
	    $callback_output=$msg;
	    $idx=0;
	$elsif $msg=~/^NEWBLOCK/
	    # check the new output for blocks
	    #     eg. cfunctions.pm single_block
	    $callback_output=$out;
	    $if $'=~/-(.*)/
		push @tails, $1
	$elsif $msg=~/^SET:(\w+)=(.*)/
	    # set/reset definitions
	    #     eg. cfunctions.pm get_pointer_type
	    $deflist->[-1]->{$1}=$2;
	$elsif $msg=~/^PARSE:(.*)/
	    $l=$1
	    next
	# ---------------------------------
	# single_block and $method
	$if $callback_output
	    $call check_callback
	$if @tails
	    $foreach $t in @tails
		$f_parse->($t)

subcode: check_callback
    $for $i=$idx:$#$callback_output+1
	$if $callback_output->[$i]=~/^BLOCK$/
	    my $n=new_output();
	    $callback_output->[$i]="BLOCK_$n"
	    $call parse_handle_block, $n

subcode: parse_handle_block(n)
    my $subblock=grabblock($block, \$lindex)
    $call debug_block, subblock, 0
    my $temp=$out;
    set_output($output_list[$(n)])
    $f_parse->("SCOPE: CALLBACK");
    parseblock($subblock);
    $f_parse->("SCOPE: NONE");
    set_output($temp)

#################################################
subcode:: package_global
    our $f_init
    our $f_parse
    our $f_setout
    our $f_modeswitch
    our $f_dumpout

    $sub set_interface
	($f_init, $f_parse, $f_setout, $f_modeswitch, $f_dumpout)=@_;

    $sub set_output($output)
	$out=$output
	$f_setout->($out)

    # ---------------------------------------------------
    our $deflist;
    our $modelist;

    our @block_stack;    # maintain state for each parseblock
    my @callsub_stack;

    my $debug;

subcode: dump_deflist
    $for my $i=0;$i<=$#$deflist;$i++
	print "DUMP DEFLIST $i:\n"
	my $h=$deflist->[$i]
	$foreach $k in keys(%$h)
	    print "    $k: $h->{$k}\n"

subcode: manage_output
    our $out;
    our @output_list;
    $sub init_output
	@output_list=([]);
	set_output($output_list[0])

    $sub new_output
	my $new_out=[];
	push @output_list, $new_out;
	my $nidx=$#output_list;
	return $nidx;

    $sub fetch_output
	my $n=shift;
	return $output_list[$n];

subcode: compile
    my ($ext, $mode)=$f_init->($page);
    $modelist=[$mode];
    $f_modeswitch->($mode)
    init_output();
    print STDERR "PAGE: $pagename\n";

    #---- save var
    my %varsave;
    $while my ($k, $v)=each %$page
	$varsave{$k}=$MyDef::var->{$k};
	$MyDef::var->{$k}=$v;
    #---- compile
    $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];

    #---- autoload
    my $codelist=$MyDef::def->{codes};
    $foreach my $codename  in keys %$codelist
	$if $codename=~/_autoload$/
	    parse_code($codelist->{$codename});

    #---- main
    my $maincode=$page->{codes}->{main};
    $if !$maincode
	$maincode=$MyDef::def->{codes}->{main};
    parse_code($maincode);

    #---- restore var
    $while my ($k, $v)=each %varsave
	$MyDef::var->{$k}=$v;
    
    #---- Dump
    $if !$page->{subpage}
	my @buffer;
	$f_dumpout->(\@buffer, fetch_output(0));
	return (\@buffer, $ext);

subcode: output_outdir
    my $outdir=".";
    $if $MyDef::var->{output_dir}
	$outdir=$MyDef::var->{output_dir};
    $if $page->{output_dir}
	$if $page->{output_dir}=~/^\//
	    $outdir=$page->{output_dir};
	$else
	    $outdir=$outdir."/".$page->{output_dir};
    $outdir=~s/^\s+//;
    # create output dir
    $if ! -d $outdir
	my @tdir_list=split /\//, $outdir;
	my $tdir;
	my $slash=0;
	$foreach my $t in @tdir_list
	    $if !$slash
		$tdir=$t;
		$slash=1;
	    $else
		$tdir=$tdir.'/'.$t;
	    if(!$tdir){next;}
	    $if ! -d $tdir
		mkdir $tdir or die "Can't create output directory: $tdir\n";

# ------------------------------------------------------
subcode: call_sub_param
    my $codename;
    my $attr;
    my (@pre_plist, $pline, @plist);
    # ---- Parse Parameter Line ------------------
    $if $param=~/^(@)?(\w+)(.*)/
	$attr=$1;
	$codename=$2;
	my $t=$3;
	$if $t=~/^\(([^\)]*)\)/
	    @pre_plist=split /,\s*/, $1;
	    $t=$';
	$t=~s/^\s*,?\s*//;
	$pline=$t;
	$if $t=~/\|/
	    # ---- '|' seperated param list
	    # '|' seprated param list
	    @plist=split /\s*\|\s*/, $t;
	$else
	    @plist=split /,\s*/, $t;
    $else
	print STDERR "    call_sub [$param] parse failure\n";
	return;

subcode: call_sub_grab
    # ---- Grab Code Block ------------------
    my $codelib=get_def_attr("codes", $codename);
    $if !$codelib and $attr ne '@'
	print STDERR "    Code $codename not found!\n";
	return;
    $foreach my $name in @callsub_stack
	$if $name eq $codename
	    die "Recursive subcode: $codename\n"

subcode: call_sub_map
    $if 1+@pre_plist!=@$params
	warn " Code $codename parameter mismatch.\n";
    $foreach my $item in @plist
	my $macro={$params->[$np]=>$item};
	$if $np
	    $for $i=0:$np
		$macro->{$params->[$i]}=$pre_plist[$i];
	push @$deflist, $macro;
	parseblock($source);
	pop @$deflist;

subcode: call_sub_normal
    $if $np+@plist!=@$params
	my $n2=@plist;
	my $n3=@$params;
	$if $params->[$n3-1]=~/^\@(\w+)/ and $n2>$n3-$np
	    # Last single param slurp ----------
	    my $n0=$n3-$np-1;
	    $for my $i=0;$i<$n0;$i++
		$pline=~s/^[^,]*,//
	    $plist[$n0]=$pline
	$else
	    warn "    code $codename parameter mismatch ($np + $n2) != $n3. [pline:$pline] calltype=[$calltype]\n";
    my $macro={};
    $for $i=0:$np
	$macro->{$params->[$i]}=$pre_plist[$i];
    $for $j=0:@$params-$np
	my $p=$params->[$np+$j];
	$if $p=~/^\@(\w+)/
	    $p=$1
	$if $plist[$j]=~/q"(.*)"/
	    $macro->{$p}=$1;
	$else
	    $macro->{$p}=$plist[$j];
    push @$deflist, $macro;
    parseblock($source);
    pop @$deflist;

subcode: call_sub_block
    $call call_sub_grab
    push @callsub_stack, $codename
    modepush($codelib->{type});
    my $params=$codelib->{params};
    my $source=$codelib->{source};
    BLOCK
    modepop()
    pop @callsub_stack

subcode:: support_subs
    $sub list_sub
	my ($param)=@_;
	my @plist=split(/,\s*/, $param);
	$foreach my $codename in @plist
	    my $funcname = $codename
	    $if $codename=~/(\w+)\((\w+)\)/
		$codename=$1
		$funcname=$2

	    &call call_sub_block
		my $line=$funcname."-".join(",", @$params);
		$f_parse->("FUNC $line")
		parseblock(["SOURCE_INDENT"]);
		parseblock($source);
		parseblock(["SOURCE_DEDENT"]);
		$f_parse->("FUNC END")

    $sub call_sub
	my ($param, $calltype)=@_;
	$call call_sub_param
	&call call_sub_block
	    my $np=@pre_plist;
	    $if $calltype eq "\$map"
		$call call_sub_map
	    $else
		$call call_sub_normal

    $sub callback_sub
	my ($param)=@_;
	$call call_sub_param
	$call call_sub_grab
	push @callsub_stack, $codename
	modepush($codelib->{type});

	my $params=$codelib->{params};
	my $source=$codelib->{source};
	my $np=@pre_plist;
	my @callback_list
	my @blockline_list
	$for $i=0:$#$source+1
	    $if $source->[$i]=~/^BLOCK$/
		my $n=new_output()
		$source->[$i]="BLOCK_$n"
		push @callback_list, $n
		push @blockline_list, $i
	$call call_sub_normal
	$foreach $i in @blockline_list
	    $source->[$i]="BLOCK"
	pop @callsub_stack
	return @callback_list

###########################################################
subcode:: support_subs
    sub get_def {
	my ($name)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    if(defined $deflist->[$i]->{$name}){
		return $deflist->[$i]->{$name};
	    }
	}
	return undef;
    }

    sub get_def_attr {
	my ($name, $attr)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    my $t=$deflist->[$i]->{$name};
	    if($t and $t->{$attr}){
		return $t->{$attr};
	    }
	}
	return undef;
    }

subcode: expand_macro_seg
    $if $s=~/^\$\((\w+)\.(\w+)\)/
	my $t=$macros->{$1};
	$if $t
	    my $tt=$MyDef::def->{fields}->{$t};
	    $if $tt
		$if $tt->{$2}
		    $segs[$j]=$tt->{$2};
		$elsif $2 eq "title"
		    $segs[$j]=$t;
		$else
		    $segs[$j]="";
		$updated++;
	    $else
		$if $2 eq "title"
		    $segs[$j]=$t;
		    $updated++;
    $elif $s=~/^\$\(rep\[(.*?)\](\d+):(.*)\)/
	$if $2>1
	    $segs[$j]="$3$1" x ($2-1) . $3
	    $updated++;
	$else
	    die "Illegal rep macro in \"$$lref\"!\n"
    $elif $s=~/^\$\((\w+):(.*)\)/
	my $t=$macros->{$1};
	my $p=$2;
	$if $t
	    $updated++;
	    $if $p=~/(\d+)-(\d+)/
		# $(macro:0-3)
		$segs[$j]=substr($t, $2, $3-$2+1);
	    $elif $p eq "len"
		# $(macro:len)
		$segs[$j]=length($t)
	    $else
		# $(macro:p1,p2,p3)
		my @plist=split /,/, $p;
		my $i=1;
		$foreach $pp in @plist
		    $t=~s/\$\($i\)/$pp/g
		    $i++
		$segs[$j]=$t
    $elsif $s=~/^\$\((.+)\)/
	$if exists($macros->{$1})
	    my $t=$macros->{$1};
	    $if $t eq $s
		die "Looping macro $1 in \"$$lref\"!\n";
	    $segs[$j]=$t;
	    $updated++;
	$else
	    # warn "Undefined macro $s\n"

subcode:: support_subs
    $sub expand_macro
	my ($lref, $macros)=@_;
	my $hasmacro=0
	my $updated=0
	$if  $$lref=~/\$\(\w[^()]*\)/
	    my @segs=split /(\$\(\w[^()]*\))/, $$lref;
	    my $j=0;
	    $foreach my $s in  @segs
		$call expand_macro_seg
		$j++;
	    $if $updated
		$$lref=join '', @segs;
	    $else
		$hasmacro=1;
	return ($hasmacro, $updated)

subcode:: support_subs
    $sub expand_macro_recurse($lref, $nowarn)
	my ($hasmacro, $updated)
	$updated=1
	$while $updated
	    $for $j=$#$deflist:-1:-1
		($hasmacro, $updated)=expand_macro($lref, $deflist->[$j]);
		$if $updated or !$hasmacro
		    last;
	$if $hasmacro and !$nowarn
	    $while $$lref=~/(\$\([^()]+\))/g
		$if substr($`, -1) ne "\\"
		    warn "Macro $1 not defined in $$lref\n"

subcode:: support_subs
    $sub testcondition
	my ($name)=@_;
	$if !$name
	    return 0;
	$elsif $name=~/ or /
	    my @nlist=split / or /, $name;
	    $foreach $n in @nlist
		$if testcondition($n)
		    return 1;
	    return 0;
	$elsif $name=~/,/
	    my @nlist=split /,/, $name;
	    $foreach $n in @nlist
		$if !testcondition($n)
		    return 0;
	    return 1;
	$elsif $name=~/(\w+)\.(\w+)/
	    $if $1 eq "fields"
		$if $MyDef::def->{fields}->{$2}
		    return 1;
	    $else
		my $t=get_def($1);
		$if $t
		    $if $MyDef::def->{fields}->{$t}->{$2}
			return 1;
	$elsif $name=~/(\w+)(:\d+)?(~|=|!=|<|>)(.*)/
	    my $t=get_def($1);
	    my ($tail, $test, $value)=($2, $3, $4);
	    $if $tail=~/:(\d+)/
		$t=substr($t, 0, $1);
	    $if $test eq "="
		if($t eq $value){ return 1;}
	    $elsif $test eq "!="
		if($t ne $value){ return 1;}
	    $elsif $test eq ">"
		if($t > $value){ return 1;}
	    $elsif $test eq "<"
		if($t < $value){ return 1;}
	    $elsif $test eq "~"
		if($t=~/$value/){ return 1;}
	$else
	    $if get_def($name)
		return 1;
	return 0;

subcode:: support_subs
    # MODES
    $sub modepush($mode)
	push @$modelist, $mode;
	$f_modeswitch->($mode, 1);

    $sub modepop
	pop @$modelist
	my $mode=$modelist->[-1];
	$f_modeswitch->($mode, 0);

    $sub grabblock($block, $index_ref)
	my @sub;
	my $indent;
	my $lindex=$$index_ref;
	$if $block->[$lindex] ne "SOURCE_INDENT"
	    return \@sub;
	$else
	    $indent=1;
	    $lindex++;
	$while $lindex<@$block
	    $if $block->[$lindex] eq "SOURCE_DEDENT"
		$indent-- if $indent>0;
		$if $indent==0
		    $lindex++;
		    last;
	    $if $block->[$lindex] eq "SOURCE_INDENT" 
		$indent++; 
	    push @sub, $block->[$lindex];
	    $lindex++;
	$$index_ref=$lindex;
	#foreach my $l(@sub){print "grabblock: [$l]\n";}
	return \@sub;



