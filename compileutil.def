include: macros_util/debug.def

# search point: subcode: parse_preproc

page: compileutil
    type: pm
    output_dir: lib/MyDef
    subcode: main
	$call compile_main

subcode: compile_main
    package MyDef::compileutil;
    $call package_global
    $call manage_output
    $call support_subs
    # ---------------------------------------------------
    $sub compile
	my ($pagename)=@_;
	my $page=$MyDef::def->{pages}->{$pagename};
	$call compile

    $sub output
	my ($pagename, $plines, $ext)=@_;
	my $page=$MyDef::def->{pages}->{$pagename};
	$call output_outdir

	my $outname=$outdir."/".$pagename;
	$if $ext
	    $outname.=".$ext";
	print "  --> [$outname]\n";

	my $subfile=0;
	open Out, ">$outname" or die "Can't write $outname\n";
	$foreach my $l in @$plines
	    $if !$subfile and $l!~/^START_/
		print Out $l;
	    $else
		$call output_subfile
	close Out;

    $sub parse_code
	my ($code)=@_;
	my $srclist=$code->{source};
	modepush($code->{type});
	parseblock($srclist);
	modepop();

    # --------------------------------------------------------
    $sub parseblock
	my ($block)=@_;
	my $indent=0;
	my $context;
	my $lindex=0;

	$call parse_stack_var
	$call parse_stack_push

	$while $lindex<@$block
	    my $l=$block->[$lindex];
	    $if $debug eq "compile"
		$call dump_line, compile
	    $lindex++;

	    # -- such as DEBUG
	    $call parse_catch_meta
	    $call parse_handle_blockstack
	    # -- such as indentation and BLOCK_n
	    $call parse_filter_meta
	    # -- handle preproc and out-of-switch
	    $if $l=~/^\$\((else|\w+:.*)\)/
		my $preproc=$1
		$call parse_preproc
	    $else
		NormalParse:
		undef $context;
		expand_macro_recurse(\$l);
		$while 1
		    # -- parse_line could return a new $l
		    # -- otherwise, last in the end breaks the loop
		    $if $l=~/^(&call|\$call|\$map|\$list)\s+(.*)$/
			my ($func, $param)=($1, $2);
			$call parse_call_sub
		    $else
			$call parse_line
		    last
	$call parse_stack_pop
	$call parse_stack_catch

    $sub list_sub
	my ($param)=@_;
	$call list_sub

    $sub call_sub
	my ($param, $domap)=@_;
	$call call_sub

    $sub set_macro($m, $p)
	$if $p=~/(\S+?)=(.*)/
	    my ($t1, $t2)=($1, $2)
	    $if $t1=~/\$\(.*\)/
		expand_macro_recurse(\$t1)
	    $if $t2=~/\$\(.*\)/
	        expand_macro_recurse(\$t2, 1)
	    $m->{$t1}=$t2
	$elif my $t=get_def($p)
	    $m->{$p}=$t
	$else
	    warn "compileutil::set_macro parse error: [$p]\n"
    # --------------------------------------------------------
    1;

######## Parse Output Stacks ######################################
subcode: parse_stack_var
    my @indent_stack;
    my @output_stack;
subcode: parse_stack_push
    # ---- protect $out context
    push @block_stack, {out=>$out};
subcode: parse_stack_pop
    my $blk=pop @block_stack;
    $if $blk->{debug}
	$f_parse->("DEBUG OFF");
	$debug=0
subcode: parse_stack_catch
    # We should always have balanced SOURCE_INDENT/SOURCE_DEDENT
    # But if not, we'll catch it here
    $if @indent_stack
	die "Indent_stack mismatch [$block->[0]...$block->[-1]\n";
	$while pop @indent_stack
	    pop @output_stack;

subcode: parse_handle_blockstack
    # -- handle block code
    $if @indent_stack and $indent==$indent_stack[-1]
	# $block 
	#     blockcodes
	# 
	$if $l eq "SOURCE_INDENT"
	    # -- start a block
	    $out=$output_stack[-1]->{out};
	    $f_setout->($out)
	    $mode=$output_stack[-1]->{mode};
	    modepush($mode)
	    $indent++;
	    next;
	$else
	    # -- must be an empty block
	    pop @indent_stack;
	    pop @output_stack;
    $if @indent_stack and $indent-1==$indent_stack[-1]
	# Once we are inside the block, we need check exit
	$if $l eq "SOURCE_DEDENT"
	    pop @indent_stack;
	    pop @output_stack;
	    $if @output_stack
		$out=$output_stack[-1]->{out};
	    $else
		$out=$block_stack[-1]->{out};
	    $f_setout->($out)
	    modepop()
	    $indent--;
	    next;

######## Parsing routines  ######################################
subcode: parse_filter_meta
    # -- maintain indent level
    $if $l eq "SOURCE_INDENT" 
	$indent++; 
    $elsif $l eq "SOURCE_DEDENT" 
	$indent-- if $indent>0; 
    $elsif $l eq "BLOCK"
	my $n=new_output(1);
	$l="BLOCK_$n";

subcode: parse_catch_meta
    $if $l =~ /^DEBUG (\w+)/
	$block_stack[-1]->{debug}=1;
	$debug=$1
	$f_parse->("DEBUG $1");
	next;
subcode: parse_preproc
    $if $preproc=~/^for:\s*(\S+)\s+in\s+(.*)/
	my $vname=$1;
	my $vparam=$2;
	my @tlist;
	$if $vparam=~/(\d+)\.\.(\d+)/
	    for(my $i=$1;$i<=$2; $i++){
		push @tlist, $i
	    }
	$else
	    @tlist=split /,\s*/, $vparam;

	my $subblock=grabblock($block, \$lindex);
	$foreach my $t in @tlist
	    my $macro={$vname=>$t};
	    push @$deflist, $macro;
	    parseblock($subblock);
	    pop @$deflist;
    $elsif $preproc=~/^reset:\s*(\w+)([+])?=(.*)/
	my ($v, $op, $d)=($1, $2, $3)
	expand_macro_recurse(\$d)
	my $i=@$deflist;
	$while $i>0 and !defined $deflist->[$i]->{$v}
	    $i--;
	$if $op
	    $if $op eq '+'
		$deflist->[$i]->{$v}+=$d;
	$else
	    $deflist->[$i]->{$v}=$d;
    $elsif $preproc=~/^eval:\s*(\w+)=(.*)/
	my ($t1,$t2)=($1,$2)
	expand_macro_recurse(\$t2)
	$deflist->[-1]->{$t1}=eval($t2)
    $elsif $preproc=~/^set:\s*(.*)/
	set_macro($deflist->[-1], $1)
    $elsif $preproc=~/^export:\s*(.*)/
	set_macro($deflist->[-2], $1)
    $elsif $preproc=~/^mset:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-1], $p)
    $elsif $preproc=~/^mexport:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-2], $p)
    $elsif $preproc=~/^preset:([^:]+):(.*)/
	my $preset=$1;
	my $t=$2;
	foreach my $tt(split /,/, $t){
	    $deflist->[-1]->{$tt}="$preset$tt";
	}
    $elsif $preproc=~/^if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if testcondition($1)
	    #print "testcondition [$1] = 1\n";
	    #foreach my $t(@$subblock){ print "\t[$t]\n"; }
	    parseblock($subblock);
	    $context="switch_off";
	$else
	    #print "testcondition [$1] = 0\n";
	    $context="switch_on";
    $elsif $preproc=~/^els?e?if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	if($context eq "switch_on"){
	    if(testcondition($1)){
		#foreach my $t(@$subblock){ print "\t[$t]\n"; }
		parseblock($subblock);
		$context="switch_off";
	    }
	    else{
		$context="switch_on";
	    }
	}
    $elsif $preproc=~/^else/
	my $subblock=grabblock($block, \$lindex);
	if($context eq "switch_on"){
	    parseblock($subblock);
	    undef $context;
	}
    $elsif $preproc=~/^block:(\w+)/
	my $name=$1;
	$call parse_named_block
    $else
	goto NormalParse

subcode:: package_global	
    our %named_blocks;   # $(block: name)

    $sub get_named_block
	my $name=shift
	$if !$named_blocks{$name}
	    $named_blocks{$name}=[]
	return $named_blocks{$name}

subcode: parse_named_block
    my $subblock=grabblock($block, \$lindex);
    my $n=new_output();
    $if !$named_blocks{$name}
	$named_blocks{$name}=[];
    push @{$named_blocks{$name}}, "BLOCK_$n";

    my $temp=$out;
    $out=$output_list[-1];
    $f_setout->($out)
    $f_parse->("SCOPE: $name");
    parseblock($subblock);
    $f_parse->("SCOPE: NONE");
    $out=$temp;
    $f_setout->($out)

subcode: parse_call_sub
    $param=~s/\s*$//;
    $if $func eq "\$map"
	call_sub($param, 1);
    $elif $func eq "\$call"
	call_sub($param, 0);
    $elif $func eq "\$list"
	list_sub($param);
    $elif $func eq "\&call"
	my @newoutput_list;
	push @callback_stack, \@newoutput_list;
	call_sub($param, 0);
	pop @callback_stack;
	$while my $o=shift @newoutput_list
	    push @indent_stack, $indent;
	    push @output_stack, $o;

subcode: parse_line
    my $idx=$#$out+1;
    my $output;
    my $msg=$f_parse->($l);
    $if $msg
	$if ref($msg) eq "ARRAY"
	    # output is held until post processing
	    #     eg. output_apple.pm $method
	    $output=$msg;
	    $idx=0;
	$elsif $msg=~/^NEWBLOCK/
	    # check the new output for blocks
	    #     eg. cfunctions.pm single_block
	    $output=$out;
	$elsif $msg=~/^SET:(\w+)=(.*)/
	    # set/reset definitions
	    #     eg. cfunctions.pm get_pointer_type
	    $deflist->[-1]->{$1}=$2;
	$elsif $msg=~/^PARSE:(.*)/
	    $l=$1
	    next
	# ---------------------------------
	# single_block and $method
	$if $output
	    $for $i=$idx:$#$output+1
		$if $output->[$i]=~/^BLOCK$/
		    # -- need comment on multi-blocks
		    my $n=new_output();
		    $output->[$i]="BLOCK_$n";
		    push @indent_stack, $indent;
		    push @output_stack, $output_list[-1];

#################################################
subcode:: package_global
    our $f_init
    our $f_parse
    our $f_setout
    our $f_modeswitch
    our $f_dumpout

    $sub set_interface
	($f_init, $f_parse, $f_setout, $f_modeswitch, $f_dumpout)=@_;

    # ---------------------------------------------------
    our $deflist;
    our $modelist;

    our @block_stack;    # maintain state for each parseblock
    our @callback_stack; # &call
    my @callsub_stack;

    my $debug;

subcode: manage_output
    our $out;
    our @output_list;
    $sub init_output
	@output_list=({out=>[], mode=>$modelist->[-1]});
	$out=$output_list[0]->{out};
	$f_setout->($out)

    $sub new_output
	my $flag_nest=shift;
	my $new_out=[];
	push @output_list, {out=>$new_out, mode=>$modelist->[-1]};
	my $nidx=$#output_list;
	$if $flag_nest and @callback_stack
	    # -- flag_nest==1 when "BLOCK" inside &call sub
	    my $outlist=$callback_stack[-1];
	    push @$outlist, $output_list[$nidx];
	return $nidx;

    $sub fetch_output
	my $n=shift;
	return $output_list[$n]->{out};

subcode: compile
    my ($ext, $mode)=$f_init->($page);
    $modelist=[$mode];
    $f_setout->($out)
    $f_modeswitch->($mode)
    init_output();
    print STDERR "PAGE: $pagename\n";

    #---- save var
    my %varsave;
    $while my ($k, $v)=each %$page
	$varsave{$k}=$MyDef::var->{$k};
	$MyDef::var->{$k}=$v;
    #---- compile
    $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];

    #---- autoload
    my $codelist=$MyDef::def->{codes};
    $foreach my $codename  in keys %$codelist
	$if $codename=~/_autoload$/
	    parse_code($codelist->{$codename});

    #---- main
    my $maincode=$page->{codes}->{main};
    $if !$maincode
	$maincode=$MyDef::def->{codes}->{main};
    parse_code($maincode);

    #---- restore var
    $while my ($k, $v)=each %varsave
	$MyDef::var->{$k}=$v;
    
    #---- Dump
    $if !$page->{subpage}
	my @buffer;
	$f_dumpout->(\@buffer, fetch_output(0));
	return (\@buffer, $ext);

subcode: output_outdir
    my $outdir=".";
    $if $MyDef::var->{output_dir}
	$outdir=$MyDef::var->{output_dir};
    $if $page->{output_dir}
	$if $page->{output_dir}=~/^\//
	    $outdir=$page->{output_dir};
	$else
	    $outdir=$outdir."/".$page->{output_dir};
    $outdir=~s/^\s+//;
    # create output dir
    $if ! -d $outdir
	my @tdir_list=split /\//, $outdir;
	my $tdir;
	my $slash=0;
	$foreach my $t in @tdir_list
	    $if !$slash
		$tdir=$t;
		$slash=1;
	    $else
		$tdir=$tdir.'/'.$t;
	    if(!$tdir){next;}
	    $if ! -d $tdir
		mkdir $tdir or die "Can't create output directory: $tdir\n";

subcode: output_subfile
    $if $subfile
	$if $l=~/^END_SUBFILE/
	    $subfile=0;
	    close Subfile;
	$else
	    print Subfile $l;
    $else
	$if $l=~/^START_Makefile/
	    $if !-f "$outdir/Makefile"
		print "Write $outdir/Makefile\n";
		open Subfile, ">$outdir/Makefile" or die "Can't write $outdir/Makefile";
		$subfile=1;
		print Subfile "$pagename: $pagename.$ext\n";
	    $else
		open Subfile, ">/dev/null";
		$subfile=1;
	$elsif $l=~/^START_h/
	    open Subfile, ">$outdir/$pagename.h" or die "Can't write $outdir/$pagename.h";
	    $subfile=1;

# ------------------------------------------------------
subcode: list_sub
    my @plist=split(/,\s*/, $param);
    $foreach my $codename in @plist
	my $funcname = $codename
	$if $codename=~/(\w+)\((\w+)\)/
	    $codename=$1
	    $funcname=$2
	my $codelib=get_def_attr("codes", $codename);
	my $params=$codelib->{params};
	my $source=$codelib->{source};
	my $line=$funcname."-".join(",", @$params);
	modepush($codelib->{type});
	$f_parse->("FUNC $line")
	parseblock(["SOURCE_INDENT"]);
	parseblock($source);
	parseblock(["SOURCE_DEDENT"]);
	modepop()

subcode: call_sub
    my $codename;
    my $attr;
    my (@pre_plist, $pline, @plist);
    # ---- Parse Parameter Line ------------------
    $if $param=~/^(@)?(\w+)(.*)/
	$attr=$1;
	$codename=$2;
	my $t=$3;
	$if $t=~/^\(([^\)]*)\)/
	    @pre_plist=split /,\s*/, $1;
	    $t=$';
	$t=~s/^\s*,?\s*//;
	$pline=$t;
	$if $codename=~/_f$/
	    # ---- Single parameter slurp
	    #      (_f for format such as in printf)
	    $t=~s/^\s*,\s*//;
	    push @plist, $t;
	$elsif $t=~/\|/
	    # ---- '|' seperated param list
	    # '|' seprated param list
	    @plist=split /\s*\|\s*/, $t;
	$else
	    @plist=split /,\s*/, $t;
    $else
	print STDERR "    call_sub [$param] parse failure\n";
	return;

    # ---- Grab Code Block ------------------
    my $codelib=get_def_attr("codes", $codename);
    $if !$codelib and $attr ne '@'
	print STDERR "    Code $codename not found!\n";
	return;
    $foreach my $name in @callsub_stack
	$if $name eq $codename
	    die "Recursive subcode: $codename\n"
    push @callsub_stack, $codename

    # ---- Call Block -----------------------
    modepush($codelib->{type});
    my $params=$codelib->{params};
    my $source=$codelib->{source};
    my $np=@pre_plist;
    $if 1==@$params and $params->[0]=~/^@(\w+)/
	my $macro={$1=>$pline};
	push @$deflist, $macro;
	parseblock($source);
	pop @deflist;
    $elsif $domap
	$if 1+@pre_plist!=@$params
	    warn " Code $codename parameter mismatch.\n";
	$foreach my $item in @plist
	    my $macro={$params->[$np]=>$item};
	    $if $np
		for(my $i=0; $i<$np; $i++){
		    $macro->{$params->[$i]}=$pre_plist[$i];
		}
	    push @$deflist, $macro;
	    parseblock($source);
	    pop @$deflist;
    $else
	$if $np+@plist!=@$params
	    my $n2=@plist;
	    my $n3=@$params;
	    my $pline=join(', ', @plist);
	    warn "    code $codename parameter mismatch ($np + $n2) != $n3. [pline:$pline]\n";
	my $macro={};
	for(my $i=0; $i<$np; $i++){
	    $macro->{$params->[$i]}=$pre_plist[$i];
	}
	for(my $j=0; $j<@$params-$np; $j++){
	    my $p=$params->[$np+$j];
	    $if $plist[$j]=~/q"(.*)"/
		$macro->{$p}=$1;
	    $else
		$macro->{$p}=$plist[$j];
	}
	push @$deflist, $macro;
	parseblock($source);
	pop @$deflist;
    modepop();
    pop @callsub_stack

###########################################################
subcode:: support_subs
    sub get_def {
	my ($name)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    if(defined $deflist->[$i]->{$name}){
		return $deflist->[$i]->{$name};
	    }
	}
	return undef;
    }

    sub get_def_attr {
	my ($name, $attr)=@_;
	for (my $i=$#$deflist; $i>=0; $i--){
	    my $t=$deflist->[$i]->{$name};
	    if($t and $t->{$attr}){
		return $t->{$attr};
	    }
	}
	return undef;
    }

subcode: expand_macro_seg
    $if $s=~/^\$\((\w+)\.(\w+)\)/
	my $t=$macros->{$1};
	$if $t
	    my $tt=$MyDef::def->{fields}->{$t};
	    $if $tt
		$if $tt->{$2}
		    $segs[$j]=$tt->{$2};
		    $updated++;
		$elsif $2 eq "title"
		    $segs[$j]=$t;
		    $updated++;
		$else
		    $segs[$j]="";
	    $else
		$if $2 eq "title"
		    $segs[$j]=$t;
		    $updated++;
    $elif $s=~/^\$\((\w+):(.*)\)/
	my $t=$macros->{$1};
	my $p=$2;
	$if $t
	    $updated++;
	    $if $p=~/(\d+)-(\d+)/
		$segs[$j]=substr($t, $2, $3-$2+1);
	    $elif $p eq "len"
		$segs[$j]=length($t)
	    $else
		my @plist=split /,/, $p;
		my $i=1;
		$foreach $pp in @plist
		    $t=~s/\$\($i\)/$pp/g
		    $i++
		$segs[$j]=$t
    $elsif $s=~/^\$\((.+)\)/
	$if exists($macros->{$1})
	    my $t=$macros->{$1};
	    $if $t eq $s
		die "Looping macro $1 in \"$$lref\"!\n";
	    $segs[$j]=$t;
	    $updated++;

subcode:: support_subs
    $sub expand_macro
	my ($lref, $macros)=@_;
	#$if $debug
	#    print "expand_macro [$$lref] $macros\n"
	my $hasmacro=0
	my $updated=0
	$if  $$lref=~/\$\(\w[^()]*\)/
	    my @segs=split /(\$\(\w[^()]*\))/, $$lref;
	    my $j=0;
	    $foreach my $s in  @segs
		$call expand_macro_seg
		$j++;
	    $if $updated
		$$lref=join '', @segs;
	    $else
		$hasmacro=1;
	#$if $debug
	#    print "    ->  return hasmacro=$hasmacro, updated=$updated\n";
	return ($hasmacro, $updated)

subcode:: support_subs
    $sub inline_macro
	my ($name, $param)=@_
	my @plist=split /,\s*/, $param
	my $macro={};
	$for $i=0:@plist
	    my $idx=$i+1
	    $macro->{$idx}=$plist[$i]
	my $l="\$($name)"
	push @$deflist, $macro;
	expand_macro_recurse(\$l)
	pop @$deflist;
	return $l

    $sub expand_macro_recurse($lref, $nowarn)
	my ($hasmacro, $updated)
	$updated=1
	$while $updated
	    $for $j=$#$deflist:-1:-1
		($hasmacro, $updated)=expand_macro($lref, $deflist->[$j]);
		$if $updated or !$hasmacro
		    last;
	$if $hasmacro and !$nowarn
	    $while $$lref=~/(\$\([^()]+\))/g
		$if substr($`, -1) ne "\\"
		    warn "Macro $1 not defined in $$lref\n"

subcode:: support_subs
    $sub testcondition
	my ($name)=@_;
	$if !$name
	    return 0;
	$elsif $name=~/ or /
	    my @nlist=split / or /, $name;
	    $foreach $n in @nlist
		$if testcondition($n)
		    return 1;
	    return 0;
	$elsif $name=~/,/
	    my @nlist=split /,/, $name;
	    $foreach $n in @nlist
		$if !testcondition($n)
		    return 0;
	    return 1;
	$elsif $name=~/(\w+)\.(\w+)/
	    $if $1 eq "fields"
		$if $MyDef::def->{fields}->{$2}
		    return 1;
	    $else
		my $t=get_def($1);
		$if $t
		    $if $MyDef::def->{fields}->{$t}->{$2}
			return 1;
	$elsif $name=~/(\w+)(:\d+)?(~|=|!=|<|>)(.*)/
	    my $t=get_def($1);
	    my ($tail, $test, $value)=($2, $3, $4);
	    $if $tail=~/:(\d+)/
		$t=substr($t, 0, $1);
	    $if $test eq "="
		if($t eq $value){ return 1;}
	    $elsif $test eq "!="
		if($t ne $value){ return 1;}
	    $elsif $test eq ">"
		if($t > $value){ return 1;}
	    $elsif $test eq "<"
		if($t < $value){ return 1;}
	    $elsif $test eq "~"
		if($t=~/$value/){ return 1;}
	$else
	    $if get_def($name)
		return 1;
	return 0;

subcode:: support_subs
    # MODES
    $sub modepush($mode)
	push @$modelist, $mode;
	$f_modeswitch->($mode);

    $sub modepop
	pop @$modelist
	my $mode=$modelist->[-1];
	$f_modeswitch->($mode);

    $sub grabblock($block, $index_ref)
	my @sub;
	my $indent;
	my $lindex=$$index_ref;
	$if $block->[$lindex] ne "SOURCE_INDENT"
	    return \@sub;
	$else
	    $indent=1;
	    $lindex++;
	$while $lindex<@$block
	    $if $block->[$lindex]=~/SOURCE_DEDENT/
		$indent-- if $indent>0;
		$if $indent==0
		    $lindex++;
		    last;
	    $if $block->[$lindex]=~/SOURCE_INDENT/ 
		$indent++; 
	    push @sub, $block->[$lindex];
	    $lindex++;
	$$index_ref=$lindex;
	#foreach my $l(@sub){print "grabblock: [$l]\n";}
	return \@sub;



