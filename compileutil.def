include: macros_util/debug.def
include: macros_compile/preproc.def
include: macros_compile/callsub.def
include: macros_compile/parse.def
include: macros_compile/macro.def
include: macros_compile/ogdl.def
include: macros_compile/list.def
include: macros_compile/util.def

page: compileutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::compileutil

    $call compile_main

subcode: compile_main
    $global $cur_file, $cur_line
    $call package_global
    $call support_subs
    # ---------------------------------------------------
    $sub compile
        my $page=$MyDef::page
        my $pagename=$page->{_pagename}
        $call output_outdir
        $call compile

    $sub output($plines)
        my $page=$MyDef::page
        my $pagename=$page->{_pagename}
        my $pageext=$page->{_pageext}
        my $outdir=$page->{outdir}

        my $outname=$outdir."/".$pagename;
        $if $pageext
            $outname.=".$pageext";
        print "  --> [$outname]\n";
        my $n=@$plines
        $if $n==0
            $print "Strange, no output!"
        $else
            &call open_w, $outname
                $foreach $l in @$plines
                    print Out $l;
            $page->{outname}=$outname

    $sub parse_code($code)
        modepush($code->{type});
        parseblock($code);
        modepop();

    # --------------------------------------------------------
    1;

#################################################
subcode: _autoload
    $global $deflist, %misc_vars
    $global $debug=0

fncode: set_output($output)
    my $old=$out
    $out=$output
    $f_setout->($out)
    return $old

macros:
    # ref output.def
    interface: $f_init, $f_parse, $f_setout, $f_modeswitch, $f_dumpout

subcode: _autoload
    $global $(interface)

fncode: set_interface
    ($(interface))=@_;

fncode: set_interface_partial
    my $t
    ($f_init, $f_parse, $f_setout, $t, $f_dumpout)=@_;

#----------------------------------------------- 
#- push/pop _interface is also used by output_www.def
subcode: _autoload
    $global @interface_stack

fncode: push_interface($module)
    push @interface_stack, [$(interface)]

    $(for:$(module_list))
        $case $module eq "$1"
            $(set:M=MyDef::output_$1)
            require $(M)
            set_interface_partial($(M)::get_interface())
    $else
        $call warn, "  push_interface: module $module not found\n"
        return undef

    $f_setout->($out)

fncode: pop_interface
    $if @interface_stack
        my $interface = pop @interface_stack
        set_interface_partial(@$interface)
    $else
        $call warn, "   pop_interface: stack empty\n"

#----------------------------------------------- 
subcode: compile
    $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];
    $deflist->[0]->{_name_}="def_root"
    $deflist->[1]->{_name_}="macros"
    $deflist->[2]->{_name_}="page $page->{_pagename}"

    my $mode=$f_init->($page);
    $if $mode
        modepush($mode)
    init_output();
    print STDERR "PAGE: $pagename\n";

    #---- save var
    my %varsave;
    $while my ($k, $v)=each %$page
        $varsave{$k}=$MyDef::var->{$k};
        $MyDef::var->{$k}=$v;

    #---- autoload
    $global $in_autoload
    $in_autoload=1

    my $codelist=$MyDef::def->{codes};
    $foreach my $codename  in keys %$codelist
        $if $codename=~/_autoload$/
            parse_code($codelist->{$codename});
    $in_autoload=0

    #---- main
    my $maincode=$page->{codes}->{main};
    $if !$maincode
        $maincode=$MyDef::def->{codes}->{main};
    $if $maincode
        parse_code($maincode);
    $else
        # die "Missing maincode\n"
    $f_parse->("NOOP POST_MAIN")

    #---- restore var
    $while my ($k, $v)=each %varsave
        $MyDef::var->{$k}=$v;
    
    #---- Dump
    $if !$page->{subpage}
        my @buffer;
        $f_dumpout->(\@buffer, fetch_output(0), $page->{_pageext})
        return \@buffer

subcode: output_outdir
    my $outdir=".";
    $if $MyDef::var->{output_dir}
        $outdir=$MyDef::var->{output_dir};
    $if $page->{output_dir}
        $if $page->{output_dir}=~/^[\/\.]/
            $outdir=$page->{output_dir};
        $else
            $outdir=$outdir."/".$page->{output_dir};
    $outdir=~s/^\s+//;
    # create output dir
    $if ! -d $outdir
        my @tdir_list=split /\//, $outdir;
        my $tdir;
        my $slash=0;
        $foreach my $t in @tdir_list
            $if !$slash
                $tdir=$t;
                $slash=1;
            $else
                $tdir=$tdir.'/'.$t;
            if(!$tdir){next;}
            $if ! -d $tdir
                mkdir $tdir or die "Can't create output directory: $tdir\n";
    #---------------------
    $page->{outdir}=$outdir

#---- utils ------------------------------------ 
subcode: warn(@msg)
    $(if:msg~")
        $(set:msg=$(msg:strip))
    $print "[$cur_file:$cur_line]$green $(msg)" 

