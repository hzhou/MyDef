include: macros_util/debug.def
include: compile/preproc.def
include: compile/callsub.def
include: compile/parse.def
include: compile/macro.def
include: compile/ogdl.def
include: compile/list.def
include: compile/util.def

page: compileutil
    type: pm
    output_dir: lib/MyDef
    package: MyDef::compileutil

    subcode: main
	$call compile_main

subcode: compile_main
    my ($cur_file, $cur_line);
    $call package_global
    $call manage_output
    $call support_subs
    # ---------------------------------------------------
    $sub compile
	my $page=$MyDef::page
	my $pagename=$page->{pagename}
	$call output_outdir
	$page->{outdir}=$outdir
	$call compile

    $sub output
	my ($plines, $ext)=@_;
	my $page=$MyDef::page
	my $pagename=$page->{pagename}
	my $outdir=$page->{outdir}

	my $outname=$outdir."/".$pagename;
	$if $ext
	    $outname.=".$ext";
	print "  --> [$outname]\n";

	open Out, ">$outname" or die "Can't write $outname\n";
	$foreach my $l in @$plines
	    print Out $l;
	close Out;

    $sub parse_code
	my ($code)=@_;
	modepush($code->{type});
	parseblock($code);
	modepop();

    # --------------------------------------------------------
    1;

#################################################
subcode:: package_global
    our $f_init
    our $f_parse
    our $f_setout
    our $f_modeswitch
    our $f_dumpout

    $sub set_interface
	($f_init, $f_parse, $f_setout, $f_modeswitch, $f_dumpout)=@_;

    $sub get_interface
	return ($f_init, $f_parse, $f_setout, $f_modeswitch, $f_dumpout)

    $sub set_output($output)
	$out=$output
	$f_setout->($out)

    # ---------------------------------------------------
    our $deflist;

    my $debug;

    our %misc_vars;


subcode: manage_output
    $global $out
    $global @output_list

    $sub init_output
	@output_list=([]);
	set_output($output_list[0])

    $sub new_output
	my $new_out=[];
	push @output_list, $new_out;
	my $nidx=$#output_list;
	return $nidx;

    $sub fetch_output
	my $n=shift;
	return $output_list[$n];

subcode: compile
    my ($ext, $mode)=$f_init->($page);
    @mode_stack=($mode)
    $cur_mode=$mode
    $f_modeswitch->($mode)
    init_output();
    print STDERR "PAGE: $pagename\n";

    #---- save var
    my %varsave;
    $while my ($k, $v)=each %$page
	$varsave{$k}=$MyDef::var->{$k};
	$MyDef::var->{$k}=$v;
    #---- compile
    $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];

    #---- autoload
    my $codelist=$MyDef::def->{codes};
    $page->{_autoload}=1
    $foreach my $codename  in keys %$codelist
	$if $codename=~/_autoload$/
	    parse_code($codelist->{$codename});
    $page->{_autoload}=0

    #---- main
    my $maincode=$page->{codes}->{main};
    $if !$maincode
	$maincode=$MyDef::def->{codes}->{main};
    $if !$maincode
	$maincode=$MyDef::def->{codes}->{basic_frame};
    parse_code($maincode);

    #---- restore var
    $while my ($k, $v)=each %varsave
	$MyDef::var->{$k}=$v;
    
    #---- Dump
    $if !$page->{subpage}
	my @buffer;
	$f_dumpout->(\@buffer, fetch_output(0));
	return (\@buffer, $ext);

subcode: output_outdir
    my $outdir=".";
    $if $MyDef::var->{output_dir}
	$outdir=$MyDef::var->{output_dir};
    $if $page->{output_dir}
	$if $page->{output_dir}=~/^\//
	    $outdir=$page->{output_dir};
	$else
	    $outdir=$outdir."/".$page->{output_dir};
    $outdir=~s/^\s+//;
    # create output dir
    $if ! -d $outdir
	my @tdir_list=split /\//, $outdir;
	my $tdir;
	my $slash=0;
	$foreach my $t in @tdir_list
	    $if !$slash
		$tdir=$t;
		$slash=1;
	    $else
		$tdir=$tdir.'/'.$t;
	    if(!$tdir){next;}
	    $if ! -d $tdir
		mkdir $tdir or die "Can't create output directory: $tdir\n";

