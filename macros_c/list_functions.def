subcode:: c_init
    $global @function_stack
    @function_stack=()

    $global %list_function_hash
    $global @list_function_list
    %list_function_hash=()
    @list_function_list=()

#---- page attribute `autolist` automatically adds functions
subcode: autolist_functions
    &call each_subcode, fn
        my $source=$code->{source}
        $foreach $l in @$source
            $if $l=~/^SOURCE/
                #skip
            $elif $l=~/^(lexical|parameter|return):\s*(.+?)\s*$/
                $if $1 eq "lexical"
		    $call parse_lexical
                $elif $1 eq "parameter"
                    $l="\$parameter $2"
                $elif $1 eq "return"
                    $l="\$return_type $2"
            $else
                last
	$global %function_autolist
	$function_autolist{$name}=1

subcode: parse_lexical
    my @tlist=split /,\s*/, $2
    my @params
    my @segs
    $foreach $t in @tlist
        $if $t=~/(.*)\((\w+)\)$/
            push @params, $1
            push @segs, $2
        $else
            push @params, $t
            $if $t=~/^(.+)\s+(\S+)$/
                push @segs, $2
            $else
                push @segs, $t
    $function_defaults{$name}="append:".join(', ', @segs)
    $l="\$parameter ". join(", ", @params)

# ------------------------------------
subcode:: parsecode_func_other
    $elsif $func eq "function"
	$call parse_function
	return
    $elsif $func eq "list"
	# $call parse_function_list
	$call add_list_functions, $param
	return
    $elsif $func eq "fcall"
	$call check_autoload_h
	$if $param=~/(\w+)\s*\(/
	    $call add_list_function, $1
	    $l=$param
	$elif $param=~/^(\w+)\s*$/
	    $call add_list_function, $1
	    $l="$1()"

# ------------------------------------
subcode: add_list_functions(param)
    $call check_autoload_h
    $if !$autoload_h
	my @tlist=split /,\s*/, $(param)
	$foreach $f in @tlist
	    $call add_list_function, $f

subcode: add_list_function(f)
    $if !$list_function_hash{$(f)}
	$list_function_hash{$(f)}=1
	push @list_function_list, $(f)
	$call add_to_autoload_h, "function-$(f)"
    $else
	$list_function_hash{$(f)}++

# #### -------------------------------
subcode: parsecode_post
    #---- NOOP POST_MAIN: called at end of parse or 
    #-      end of each parse group as in output_xs.def
    
    $while my $f=shift @list_function_list
	$call parse_function_list_item, $f

# ------------------------------------
subcode: parse_function_list_item(f)
    my $funcname=$(f)
    $if $lamda_functions{$funcname}
	my $block=$lamda_functions{$funcname}
	push @$out, @$block
    $else
	my ($paramline, $codename)
	$codename=$(f)
	$if $codename=~/(\w+)\((\w+)\)/
	    $codename=$1
	    $funcname=$2
	$funcname=~s/^@//
	my $params=MyDef::compileutil::get_sub_param_list($codename)
	$if defined $params
	    $paramline=join(",", @$params)
	    $if $funcname eq "n_main" or $funcname eq "main2"
		$funcname="main";

	$if defined $paramline
	    &call function_block
		MyDef::compileutil::call_sub($codename, "\$list")
		$if $out->[-1]=~/^return/
		    $cur_function->{return}=pop @$out
	    $call function_pop

# ---- Direct $function ------------------
subcode: parse_function
    $global %lamda_functions
    $call check_autoload_h
    $if !$autoload_h and $param=~/(\w+)(.*)/
	my ($fname, $paramline)=($1, $2)
	$if $paramline=~/\((.*)\)/
	    $paramline=$1
	$elif $paramline=~/^\s*,\s*(.*)/
	    $paramline=$1

	my $funcname=MyDef::utils::uniq_name($fname, \%list_function_hash)
	$call add_to_autoload_h, "function-$funcname"

	my $block=[]
	&call replace_output, $block
	    &call function_block
		push @$block, "BLOCK";
	    push @$block, "PARSE:\$function_pop"

	$lamda_functions{$funcname}=$block
	$call add_list_function, $funcname
	MyDef::compileutil::set_current_macro("lamda", $funcname)

	return $block
    $else
	return "SKIPBLOCK"

#---------------------------------------- 
subcode:: support_subs
    $sub start_function($funcname, $paramline)
	my $func=open_function($funcname, $paramline);
	$call function_push
	#------------------
	push @function_list, $func
	my $fidx=$#function_list
	MyDef::compileutil::set_named_block("fn$fidx\_open", $func->{openblock})
	MyDef::compileutil::set_named_block("fn$fidx\_pre", $func->{preblock})
	MyDef::compileutil::set_named_block("fn$fidx\_post", $func->{postblock})
	MyDef::compileutil::set_named_block("fn$fidx\_close", $func->{closeblock})
	push @$out, "DUMP_STUB fn$fidx\_open"
	push @$out, "INDENT"
	push @$out, "DUMP_STUB fn$fidx\_pre"

	MyDef::compileutil::set_current_macro("FunctionName", $funcname)
	return $fidx

    $sub finish_function($fidx)
	push @$out, "DUMP_STUB fn$fidx\_post"
	push @$out, "DEDENT"
	push @$out, "DUMP_STUB fn$fidx\_close"


    #---------------------------------------- 
    #---- used in deflib/win32/windows.def --
    #--
    $sub start_function_block($funcname, $paramline)
	$if !$lamda_functions{$funcname}
	    my $block=[]
	    my $old_out=MyDef::compileutil::set_output($block)

	    my $fidx = start_function($funcname, $paramline)

	    $lamda_functions{$funcname}=$block
	    push @list_function_list, $funcname
	    $list_function_hash{$funcname}=1
	    return {out=>$old_out, fidx=>$fidx}
	$else
	    return undef

    $sub finish_function_block($context)
	finish_function($context->{fidx})
	MyDef::compileutil::set_output($context->{out})
	$call function_pop

#---------------------------------------- 
subcode: function_block
    my $fidx=start_function($funcname, $paramline)
    BLOCK
    finish_function($fidx)

subcode: function_push
    push @function_stack, $cur_function
    $cur_function=$func

    push @scope_stack, $cur_scope
    $cur_scope=$cur_function

subcode:: parsecode_func_other
    $elsif $func eq "function_pop"
	$call function_pop
	return

subcode: function_pop
    $cur_function=pop @function_stack
    $cur_scope=pop @scope_stack
    my $level=@function_stack
    $if $level==0
	$call case_reset

