subcode:: c_init
    $global %functions, @function_stack, $cur_function
    %functions=()
    @function_stack=()
    undef $cur_function

    #   used in output_xs.def for parsing xs_mode and skip_declare
    $global %function_flags
    %function_flags=()

    $global @func_var_hooks
    @func_var_hooks=()

    $global @scope_stack
    @scope_stack=()

# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub open_function($fname, $param)
	# -- var_list: list of local variables
	# -- var_type: types of local variables
	# -- var_flag: flags
	my $func= {param_list=>[], var_list=>[], var_type=>{}, var_flag=>{}, var_decl=>{}, init=>[], finish=>[]};
	MyDef::compileutil::set_named_block("fn_init", $func->{init})
	MyDef::compileutil::set_named_block("fn_finish", $func->{finish})

	$while my ($k, $v)=each %function_flags
	    $func->{$k}=$v;

	$func->{name}=$fname;
	my $param_list=$func->{param_list};
	my $var_type=$func->{var_type};
	# -- parsing param list
	$if $param eq "api"
	    $call open_function_api
	$if $param
	    $call open_function_params
	# --
	$if $func->{name}
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	# --
	push @function_stack, $cur_function
	$cur_function=$func;
	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;

subcode: open_function_params
    my @plist=split /,\s*/, $param
    my $i=0
    $foreach my $p in @plist
	$i++
	$if $p=~/(\S.*)\s+(\S+)\s*$/
	    my ($type, $name)=($1, $2)
	    $call check_pointer_type_name
	    push @$param_list, "$type $name"
	    $var_type->{$name}=$type
	$elif $p eq "fmt" and $i==@plist
	    push @$param_list, "char * fmt, ..."
	$else
	    $if $fntype{$p}
		push @$param_list, $fntype{$p};
		$var_type->{$p}="function";
	    $else
		my $t= get_c_type($p);
		push @$param_list, "$t $p";
		$var_type->{$p}=$t;

subcode: open_function_api
    $if $fname=~/^([a-zA-Z0-9]+)_(\w+)/
	$if $fntype{$2}
	    my $t=$fntype{$2}
	    $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
		$func->{ret_type}=$1
		$param=$3
# -----------------------------------------------------------------
subcode:: c_support_subs
    my $cur_scope
    $sub open_scope
	push @scope_stack, $cur_scope
	$cur_scope={var_list=>[], var_type=>{}, var_decl=>{}}

    $sub close_scope($scopename)
	my $var_decl=$cur_scope->{var_decl};
	my $var_list=$cur_scope->{var_list};
	$if @$var_list
	    my $block=MyDef::compileutil::get_named_block($scopename)
	    #unshift @$block, "{"
	    $foreach my $v in @$var_list
		push @$block, "$var_decl->{$v};";
	    #push @$out, "}"

	$cur_scope=pop @scope_stack
#-------------------------------------------------------------
subcode:: c_support_subs
    $sub func_return
	my ($l, $out)=@_;
	$if !$cur_function->{ret_type}
	    $if $l=~/return\s+(.*)/
		my $t=$1;
		$if $t=~/(\w+)/
		    $cur_function->{ret_var}=$1;
		$cur_function->{ret_type}=infer_c_type($t)
	    $else
		$cur_function->{ret_type}="void";
	    $if $debug eq "type"
		print "Check ret_type: $cur_function->{name} [$l] -> $cur_function->{ret_type}\n";
	$if $cur_indent<=1
	    $cur_function->{has_return}=1;

	func_var_release($out);

    $sub func_var_init
	my ($v, $type)=@_;
	my $init;
	$foreach my $fh in @func_var_hooks
	    $if $fh->{var_check}->($type)
		$init=$fh->{var_init}->($v, $type);
	$if $init
	    return $init;

    $sub func_var_release
	my ($out)=@_;
	my $ret_type=$cur_function->{ret_type};
	my $ret_var=$cur_function->{ret_var};
	my $var_list=$cur_function->{var_list};
	my $var_type=$cur_function->{var_type};
	$if @$var_list and @func_var_hooks
	    $foreach my $name in @$var_list
		my $type=$var_type->{$name};
		$if $name ne $ret_var
		    $foreach my $fh in @func_var_hooks
			$if $fh->{var_check}->($type)
			    my $exit=$fh->{var_release}->($type, $name);
			    $if $exit
				$foreach my $l in @$exit
				    push @$out, $l;


    $sub func_var_assign
	my ($type, $name, $val, $out)=@_;
	$if $debug eq "type"
	    print "func_var_assign: $type $name = $val\n"
	my $done_out;
	$if @func_var_hooks
	    $foreach my $fh in @func_var_hooks
		$if $fh->{var_check}->($type)
		    $fh->{var_pre_assign}->($type, $name, $val, $out);
		    push @$out, "$name=$val;";
		    $fh->{var_post_assign}->($type, $name, $val, $out);
		    $done_out=1;
		    last;
	$if !$done_out
	    push @$out, "$name=$val;";

# -----------------------------------------------------------------
subcode:: support_subs
    $sub process_function_std($func)
	my $name=$func->{name};

	# ---- open block ------------------
	$if !$func->{openblock}
	    my $declare=$func->{declare}
	    $if !$declare
		my $ret_type=$func->{ret_type};
		if(!$ret_type){$ret_type="void";}
		my $param_list=$func->{"param_list"};
		my $param=join(', ', @$param_list);
		$declare="$ret_type $name($param)"
		$func->{declare}=$declare
	    $func->{openblock}=[$declare."{"]

	# ---- close block ----------------------
	$if !$func->{closeblock}
	    my @t
	    push @t, "}";
	    push @t, "NEWLINE";
	    $func->{closeblock}=\@t

	my (@pre, @post);
	$func->{preblock}=\@pre;
	$func->{postblock}=\@post;

	# ---- pre block -----------------------
	my $var_decl=$func->{var_decl};
	my $var_list=$func->{var_list};
	$if @$var_list
	    $foreach my $v in @$var_list
		$if $global_type->{$v}
		    print "  [warning] In $name: local variable $v has existing global\n"
		push @pre, "$var_decl->{$v};";
	    push @pre, "NEWLINE";

	$foreach my $tl in @{$func->{init}}
	    push @pre, $tl;

	# ---- post block ----------------------- 
	$if !$func->{has_return}
	    $cur_function=$func
	    func_var_release(\@post);

	$foreach my $tl in @{$func->{finish}}
	    push @post, $tl;


