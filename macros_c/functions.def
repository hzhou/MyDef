subcode:: c_init
    $global %functions, @function_stack, $cur_function
    %functions=()
    @function_stack=()
    undef $cur_function

    #   used in output_xs.def for parsing xs_mode and skip_declare
    $global %function_flags
    %function_flags=()

    $global @func_var_hooks
    @func_var_hooks=()

    $global @scope_stack
    @scope_stack=()

# -----------------------------------------------------------------
subcode: check_pointer_type_name
    $if $name=~/^(\*+)(.+)/
	$type.=" $1"
	$name=$2

subcode:: c_support_subs
    $sub open_function($fname, $param)
	# -- var_list: list of local variables
	# -- var_type: types of local variables
	# -- var_flag: flags
	my $func= {param_list=>[], var_list=>[], var_type=>{}, var_flag=>{}, var_decl=>{}, init=>[], finish=>[]};
	MyDef::compileutil::set_named_block("fn_init", $func->{init})
	MyDef::compileutil::set_named_block("fn_finish", $func->{finish})

	$while my ($k, $v)=each %function_flags
	    $func->{$k}=$v;

	$func->{name}=$fname;
	my $param_list=$func->{param_list};
	my $var_type=$func->{var_type};
	# -- parsing param list
	$if $param eq "api"
	    $call open_function_api
	$if $param
	    $call open_function_params
	# --
	$if $func->{name}
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	# --
	push @function_stack, $cur_function
	$cur_function=$func;
	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;

subcode: open_function_params
    my @plist=split /,\s*/, $param
    my $i=0
    $foreach my $p in @plist
	$i++
	$if $p=~/(\S.*)\s+(\S+)\s*$/
	    my ($type, $name)=($1, $2)
	    $call check_pointer_type_name
	    push @$param_list, "$type $name"
	    $var_type->{$name}=$type
	$elif $p eq "fmt" and $i==@plist
	    push @$param_list, "char * fmt, ..."
	$else
	    $if $debug
		print "fntype {$p} = $fntype{$p}\n"
	    $if $fntype{$p}
		push @$param_list, $fntype{$p};
		$var_type->{$p}="function";
	    $else
		my $t= get_c_type($p);
		push @$param_list, "$t $p";
		$var_type->{$p}=$t;

subcode: open_function_api
    $if $fname=~/^([a-zA-Z0-9]+)_(\w+)/
	$if $fntype{$2}
	    my $t=$fntype{$2}
	    $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
		$func->{ret_type}=$1
		$param=$3
# -----------------------------------------------------------------
subcode:: c_support_subs
    my $cur_scope
    $sub open_scope
	push @scope_stack, $cur_scope
	$cur_scope={var_list=>[], var_type=>{}, var_decl=>{}}

    $sub close_scope($scopename)
	my $var_decl=$cur_scope->{var_decl};
	my $var_list=$cur_scope->{var_list};
	$if @$var_list
	    my $block=MyDef::compileutil::get_named_block($scopename)
	    #unshift @$block, "{"
	    $foreach my $v in @$var_list
		push @$block, "$var_decl->{$v};";
	    #push @$out, "}"

	$cur_scope=pop @scope_stack
# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub get_var_type_direct
	my $name=shift;
	$if $debug eq "type"
	    print "get_var_type_direct: [$name]\n"
	$if $cur_scope->{var_type}->{$name}
	    return $cur_scope->{var_type}->{$name}
	$for my $i=$#scope_stack;$i>=0;$i--
	    $if $scope_stack[$i]->{var_type}->{$name}
		return $scope_stack[$i]->{var_type}->{$name}

	$if $cur_function and $cur_function->{var_type}->{$name}
	    return $cur_function->{var_type}->{$name};
	$else
	    return $global_type->{$name};

    $sub get_var_flag
	my $name=shift;
	$if $cur_function->{var_flag}->{$name}
	    return $cur_function->{var_flag}->{$name};
	$else
	    return $global_flag->{$name};

    $sub get_var_type
	my $name=shift
	$if $name=~/^(\w+)(.*)/
	    return get_sub_type(get_var_type_direct($1), $2)
	return "void";

    $sub get_sub_type
	my ($type0, $tail)=@_
	$if !$type0
	    return "void"
	$if $debug eq "type"
	    print "get_sub_type: $type0 - $tail\n"

	$if $tail=~/^(\.|->)(\w+)(.*)/
	    $tail=$3;
	    my $type=get_struct_element_type($type0, $2)
	    return get_sub_type($type, $tail)
	$elif $tail=~/^\[.*?\](.*)/
	    $tail=$1;
	    $if $type0=~/(.*)\s*\*\s*$/
		return get_sub_type($1, $tail)
	    $else
		my $curfile=MyDef::compileutil::curfile_curline()
		warn "[$curfile] error in dereferencing pointer type $type0\n"
		return "void"
	$else
	    return $type0

# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub func_add_var($name, $type, $value)
	my $scope
	$if $type eq "local"
	    undef $type
	    $scope="local"
	$call add_var, func

    $sub global_add_var($name, $type, $value)
	$call add_var, global

    $sub scope_add_var($name, $type, $value)
	$call add_var, scope

    $sub global_add_symbol($name, $type, $value)
	$call add_var, symbol

subcode: add_var(scope)
    # TODO: static array, retain maximum dimensions
    $call split_name
    $(if:scope=global)
	$if $global_type->{$name}
	    return $name
    $(elif:scope=symbol)
	$if $global_type->{$name}
	    return $name
    $(elif:scope=scope)
	my $var_list=$cur_scope->{var_list};
	my $var_decl=$cur_scope->{var_decl};
	my $var_type=$cur_scope->{var_type};

	$if $var_type->{$name}
	    return $name
    $(else)
	my $var_list=$cur_function->{var_list};
	my $var_decl=$cur_function->{var_decl};
	my $var_type=$cur_function->{var_type};

	$if !$cur_function
	    return $name
	$if $scope eq "local"
	    $if $var_type->{$name}
		return $name
	$elif get_var_type_direct($name)
	    return $name

    $if $debug eq "type"
	my $curfile=MyDef::compileutil::curfile_curline()
	print "[$curfile]", "\033[33m", "$(scope) - $type - $name ($array) - $tail ($value)\n", "\033[m"

    $call infer_type
    my ($vtype, $vinit)
    $call var_array_type
    $call var_init_line

    $if $debug eq "type"
	print "    vtype: $vtype\n"
	print "    vinit: $vinit\n"

    $(if:scope=global)
	$global_type->{$name}=$vtype
	$global_flag->{$name}=$vinit
	push @global_list, $vinit
    $(elif:scope=symbol)
	$global_type->{$name}=$vtype
    $(else)
	push @$var_list, $name;
	$var_type->{$name}=$vtype
	# ----
	$if !$tail and !$value
	    $call c_var_init
	$var_decl->{$name}=$vinit;
	# ----
	$if $type=~/struct (\w+)$/
	    $call c_struct_init
    return $name

subcode: c_var_init
    my $init_value=func_var_init($name, $type);
    $if $init_value
	$if $array=~/^\[([^\[\]]+)\]/
	    func_add_var("i", "int");
	    push @{$cur_function->{init}}, "for(i=0;i<$1;i++){$name\[i] = $init_value;}";
	$else
	    $tail=" = $init_value";

subcode: c_struct_init
    my $s_name=$1
    my $s_init=$structs{$s_name}->{hash}->{"-init"}
    $if $s_init and @$s_init
	$if $array=~/^\[([^\[\]]+)\]/
	    func_add_var("i", "int");
	    push @{$cur_function->{init}}, "for(i=0;i<$1;i++){$s_name\_constructor(&$name\[i]);}";
	$else
	    push @{$cur_function->{init}}, "$s_name\_constructor(&$name);"

# ----
subcode: split_name
    my ($tail, $array);
    my $explicit_type;
    my @attrs
    # omit ;
    $name=~s/;\s*$//
    # NOTE: space sensitive!
    $if !$type and $name=~/^\s*(\S[^=]*)\s+([^= \t].*)/
	$type=$1
	$explicit_type=1
	$name=$2
	$call check_pointer_type_name
    $while $type=~/^\s*(extern|static|const)\s*(.*)/
	push @attrs, $1
	$type=$2
    $if $name=~/(\S+?)\s*(=\s*(.*))/
	$name=$1;
	$tail=$2;
	$if $debug eq "type"
	    print "match: name: $1, tail: $2\n"
	$call value_from_file
	$if !$value
	    $value=$3
    $if $name=~/(\w+)(\[.*\])/
	$name=$1;
	$array=$2;

subcode: infer_type
    $if !$type
	$type=get_c_type($name)
	$if $fntype{$name}
	    $type="function"
	$if !($type and $type ne "void" and name_with_prefix($name))
	    $if defined $value
		my $val_type=infer_c_type($value)
		$if $debug eq "type" and $type ne $val_type
		    print "infer_type: $type -- $val_type\n"
		$if $val_type and $val_type ne "void"
		    $type = $val_type

subcode: var_array_type
    $if defined $array
	my $layer=0
	$while $array=~/\[.*?\]/g
	    $if !$explicit_type
		$type=pointer_type($type)
	    $layer++
	$vtype=$type." "."*"x$layer
    $else
	$vtype=$type

subcode: var_init_line
    $if $type eq "function"
	$vinit=$fntype{$name};
    $elif defined $array
	$vinit="$type $name$array$tail";
    $else
	$vinit="$type $name$tail";
    $if @attrs
	$vinit=join(' ', @attrs)." $vinit"

subcode:: package_globals
    use File::stat
    $sub get_mtime($fname)
	my $st=stat($fname)
	return $st->[9]

subcode:: c_init
    $global @extern_binary
    @extern_binary=()

subcode: value_from_file
    $if $tail=~/^=\[string_from_file:(\S+)\]/
	my @t;
	open In, $1 or die "string_from_file: can't open $1\n"
	$while <In>
	    chomp
	    s/\\/\\\\/g
	    s/"/\\"/g
	    push @t, $_
	close In
	$tail="=\"".join("\\n\\\n", @t)."\""
    $elif $tail=~/^=\[binary_from_file:(\S+)\]/
	push @global_list, "extern char _$name"
	$tail="=&_$name"
	push @extern_binary, "$name:$1"

subcode: process_extern_binary
    my $ofile=$page->{outdir}."/extern.o"
    my $otime=get_mtime($ofile)
    my $need_update=0
    my @externS;
    push @externS, "    .section .rodata"
    $foreach $t in @extern_binary
	$if $t=~/(.*):(.*)/
	    my ($name, $fname)=($1,$2)
	    push @externS, "    .global _$name"
	    #push @externS, "    .type   $name, \"object\""
	    push @externS, "    .align  4"
	    push @externS, "_$name:"
	    push @externS, "    .incbin \"$fname\""
	    $if get_mtime($fname)>$otime
		$need_update=1
    $if $need_update
	print "  ---> $ofile\n"
        open Out, ">$page->{outdir}/extern.s"
	print Out join("\n", @externS), "\n";
	close Out

	my $cmd= "as -o $ofile"
	open PIPE, "|$cmd" or die "Can't run $cmd\n"
	print PIPE join("\n", @externS), "\n"
	close PIPE
    $if -f $ofile
	$objects{"extern.o"}=1


#-------------------------------------------------------------
subcode:: c_support_subs
    $sub func_return
	my ($l, $out)=@_;
	$if !$cur_function->{ret_type}
	    $if $l=~/return\s+(.*)/
		my $t=$1;
		$if $t=~/(\w+)/
		    $cur_function->{ret_var}=$1;
		$cur_function->{ret_type}=infer_c_type($t)
	    $else
		$cur_function->{ret_type}="void";
	    $if $debug eq "type"
		print "Check ret_type: $cur_function->{name} [$l] -> $cur_function->{ret_type}\n";
	$if $cur_indent<=1
	    $cur_function->{has_return}=1;

	func_var_release($out);

    $sub func_var_init
	my ($v, $type)=@_;
	my $init;
	$foreach my $fh in @func_var_hooks
	    $if $fh->{var_check}->($type)
		$init=$fh->{var_init}->($v, $type);
	$if $init
	    return $init;

    $sub func_var_release
	my ($out)=@_;
	my $ret_type=$cur_function->{ret_type};
	my $ret_var=$cur_function->{ret_var};
	my $var_list=$cur_function->{var_list};
	my $var_type=$cur_function->{var_type};
	$if @$var_list and @func_var_hooks
	    $foreach my $name in @$var_list
		my $type=$var_type->{$name};
		$if $name ne $ret_var
		    $foreach my $fh in @func_var_hooks
			$if $fh->{var_check}->($type)
			    my $exit=$fh->{var_release}->($type, $name);
			    $if $exit
				$foreach my $l in @$exit
				    push @$out, $l;


    $sub func_var_assign
	my ($type, $name, $val, $out)=@_;
	$if $debug eq "type"
	    print "func_var_assign: $type $name = $val\n"
	my $done_out;
	$if @func_var_hooks
	    $foreach my $fh in @func_var_hooks
		$if $fh->{var_check}->($type)
		    $fh->{var_pre_assign}->($type, $name, $val, $out);
		    push @$out, "$name=$val;";
		    $fh->{var_post_assign}->($type, $name, $val, $out);
		    $done_out=1;
		    last;
	$if !$done_out
	    push @$out, "$name=$val;";

# -----------------------------------------------------------------
subcode:: support_subs
    $sub process_function_std($func)
	my $name=$func->{name};

	# ---- open block ------------------
	$if !$func->{openblock}
	    my $declare=$func->{declare}
	    $if !$declare
		my $ret_type=$func->{ret_type};
		if(!$ret_type){$ret_type="void";}
		my $param_list=$func->{"param_list"};
		my $param=join(', ', @$param_list);
		$declare="$ret_type $name($param)"
		$func->{declare}=$declare
	    $func->{openblock}=[$declare."{"]

	# ---- close block ----------------------
	$if !$func->{closeblock}
	    my @t
	    push @t, "}";
	    push @t, "NEWLINE";
	    $func->{closeblock}=\@t

	my (@pre, @post);
	$func->{preblock}=\@pre;
	$func->{postblock}=\@post;

	# ---- pre block -----------------------
	my $var_decl=$func->{var_decl};
	my $var_list=$func->{var_list};
	$if @$var_list
	    $foreach my $v in @$var_list
		$if $global_type->{$v}
		    print "  [warning] In $name: local variable $v has existing global\n"
		push @pre, "$var_decl->{$v};";
	    push @pre, "NEWLINE";

	$foreach my $tl in @{$func->{init}}
	    push @pre, $tl;

	# ---- post block ----------------------- 
	$if !$func->{has_return}
	    $cur_function=$func
	    func_var_release(\@post);

	$foreach my $tl in @{$func->{finish}}
	    push @post, $tl;


