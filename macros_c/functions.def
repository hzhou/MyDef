subcode:: package_globals
    our %functions
    our @function_stack
    our $cur_function
    # ----
    my @scope_stack

    # ----
    #   used in output_xs.def for parsing xs_mode and skip_declare
    my %function_flags;
    sub set_function_flag {
	my ($k, $v)=@_;
	$function_flags{$k}=$v;
    }
    # ----
    our @func_var_hooks;

subcode:: c_init
    %functions=()
    @function_stack=()
    undef $cur_function

    %function_flags=()
    @func_var_hooks=()

    @scope_stack=()

# -----------------------------------------------------------------
subcode: check_pointer_type_name
    $if $name=~/^(\*+)(.+)/
	$type.=" $1"
	$name=$2

subcode:: c_support_subs
    $sub open_function
	my ($fname, $param)=@_;
	# -- var_list: list of local variables
	# -- var_type: types of local variables
	# -- var_flag: flags
	my $func= {param_list=>[], var_list=>[], var_type=>{}, var_flag=>{}, var_decl=>{}, init=>[], finish=>[]};
	MyDef::compileutil::set_named_block("fn_init", $func->{init})
	MyDef::compileutil::set_named_block("fn_finish", $func->{finish})

	while(my ($k, $v)=each %function_flags){
	    $func->{$k}=$v;
	}
	$func->{name}=$fname;
	my $pbuf=$func->{param_list};
	my $var_type=$func->{var_type};
	# -- parsing param list
	$if $param eq "api"
	    $call open_function_api
	$if $param
	    $call open_function_params
	# --
	$if $func->{name}
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	# --
	push @function_stack, $cur_function
	$cur_function=$func;
	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;

subcode: open_function_params
    my @plist=split /,/, $param
    my $i=0
    $foreach my $p in @plist
	$i++
	$if $p=~/(\S.*)\s+(\S+)\s*$/
	    my ($type, $name)=($1, $2)
	    $call check_pointer_type_name
	    push @$pbuf, "$type $name"
	    $var_type->{$name}=$type
	$elif $p eq "fmt" and $i==@plist
	    push @$pbuf, "char * fmt, ..."
	$else
	    $if $fntype{$p}
		push @$pbuf, $fntype{$p};
		$var_type->{$p}="function";
	    $else
		my $t= get_c_type($p);
		push @$pbuf, "$t $p";
		$var_type->{$p}=$t;

subcode: open_function_api
    $if $fname=~/^([a-zA-Z0-9]+)_(\w+)/
	$if $fntype{$2}
	    my $t=$fntype{$2}
	    $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
		$func->{ret_type}=$1
		$param=$3
# -----------------------------------------------------------------
subcode:: c_support_subs
    my $cur_scope
    $sub open_scope
	push @scope_stack, $cur_scope
	$cur_scope={var_list=>[], var_type=>{}, var_decl=>{}}

    $sub close_scope($scopename)
	my $var_decl=$cur_scope->{var_decl};
	my $var_list=$cur_scope->{var_list};
	$if @$var_list
	    my $block=MyDef::compileutil::get_named_block($scopename)
	    #unshift @$block, "{"
	    $foreach my $v in @$var_list
		push @$block, "$var_decl->{$v};";
	    #push @$out, "}"

	$cur_scope=pop @scope_stack
# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub get_var_type_direct
	my $name=shift;
	$if $cur_scope->{var_type}->{$name}
	    return $cur_scope->{var_type}->{$name}
	$for $i=$#scope_stack;$i>=0;$i--
	    $if $scope_stack[$i]->{var_type}->{$name}
		return $scope_stack[$i]->{var_type}->{$name}

	$if $cur_function and $cur_function->{var_type}->{$name}
	    return $cur_function->{var_type}->{$name};
	$else
	    return $global_type->{$name};
    $sub get_var_flag
	my $name=shift;
	$if $cur_function->{var_flag}->{$name}
	    return $cur_function->{var_flag}->{$name};
	$else
	    return $global_flag->{$name};

    $sub get_var_type
	my $name=shift
	$if $name=~/^(\w+)(.*)/
	    return get_sub_type(get_var_type_direct($1), $2)
	return "void";

    $sub get_sub_type
	my ($type0, $tail)=@_
	$if !$type0
	    return "void"
	$if $debug eq "type"
	    print "get_sub_type: $type0 - $tail\n"

	$if $tail=~/^(\.|->)(\w+)(.*)/
	    $tail=$3;
	    my $type=get_struct_element_type($type0, $2)
	    return get_sub_type($type, $tail)
	$elif $tail=~/^\[.*?\](.*)/
	    $tail=$1;
	    $if $type0=~/(.*)\s*\*\s*$/
		return get_sub_type($1, $tail)
	    $else
		my $curfile=MyDef::compileutil::curfile_curline()
		warn "[$curfile] error in dereferencing pointer type $type0\n"
		return "void"
	$else
	    return $type0

# -----------------------------------------------------------------
subcode: debug_add_var
    my $curfile=MyDef::compileutil::curfile_curline()
    print "[$curfile]func_add_var, $name, $type, $value\n"

subcode:: c_support_subs
    $sub func_add_var($name, $type, $value)
	# $call debug_add_var
	my $scope
	$if $type eq "local"
	    undef $type
	    $scope="local"
	$call add_var, func

    $sub global_add_var($name, $type, $value)
	$call add_var, global

    $sub scope_add_var($name, $type, $value)
	$call add_var, scope

    $sub global_add_symbol($name, $type, $value)
	$call add_var, symbol

subcode: add_var(scope)
    $call split_name
    $(if:scope=global)
	$if $global_type->{$name}
	    return $name
    $(elif:scope=symbol)
	$if $global_type->{$name}
	    return $name
    $(elif:scope=scope)
	my $var_list=$cur_scope->{var_list};
	my $var_decl=$cur_scope->{var_decl};
	my $var_type=$cur_scope->{var_type};

	$if $var_type->{$name}
	    return $name
    $(else)
	my $var_list=$cur_function->{var_list};
	my $var_decl=$cur_function->{var_decl};
	my $var_type=$cur_function->{var_type};

	$if !$cur_function
	    return $name
	$if $scope eq "local"
	    $if $var_type->{$name}
		return $name
	$elif get_var_type_direct($name)
	    return $name

    $if $debug eq "type"
	print "\033[33m", "$(scope) - ($attr) $type - $name ($array) - $tail ($value)\n", "\033[m"

    $call infer_type
    my ($vtype, $vinit)
    $call var_array_type
    $call var_init_line

    $(if:scope=global)
	$global_type->{$name}=$vtype
	push @global_list, $vinit
    $(elif:scope=symbol)
	$global_type->{$name}=$vtype
    $(else)
	push @$var_list, $name;
	$var_type->{$name}=$vtype
	# ----
	$if !$tail and !$value
	    $call c_var_init
	$var_decl->{$name}=$vinit;
	# ----
	$if $type=~/struct (\w+)$/
	    $call c_struct_init
    return $name

subcode: c_var_init
    my $init_value=func_var_init($name, $type);
    $if $init_value
	$if $array=~/^\[([^\[\]]+)\]/
	    func_add_var("i", "int");
	    push @{$cur_function->{init}}, "for(i=0;i<$1;i++){$name\[i] = $init_value;}";
	$else
	    $tail=" = $init_value";

subcode: c_struct_init
    my $s_init=$structs{$1}->{hash}->{"-init"}
    $if @$s_init
	$if $array=~/^\[([^\[\]]+)\]/
	    func_add_var("i", "int");
	    push @{$cur_function->{init}}, "for(i=0;i<$1;i++){$1_constructor(&$name\[i]);}";
	$else
	    push @{$cur_function->{init}}, "$1_constructor(&$name);"

# ----
subcode: split_name
    my ($tail, $array);
    my $explicit_type;
    my @attrs
    # omit ;
    $name=~s/;\s*$//
    # NOTE: space sensitive!
    $if !$type and $name=~/^\s*(\S[^=]*)\s+([^= \t].*)/
	$type=$1
	$explicit_type=1
	$name=$2
	$call check_pointer_type_name
    $while $type=~/^\s*(extern|static|const)\s*(.*)/
	push @attrs, $1
	$type=$2
    $if $name=~/(\S+?)\s*(=\s*(.*))/
	$name=$1;
	$tail=$2;
	$if $debug eq "type"
	    print "match: name: $1, tail: $2\n"
	$call value_from_file
	$if !$value
	    $value=$3
    $if $name=~/(\w+)(\[.*\])/
	$name=$1;
	$array=$2;

subcode: infer_type
    $if !$type
	$type=get_c_type($name)
	$if $fntype{$name}
	    $type="function"
	$if defined $value
	    my $val_type=infer_c_type($value)
	    $if $debug eq "type" and $type ne $val_type
		print "infer_type: $type -- $val_type\n"
	    $if !$type or $type eq "void"
		$if $val_type and $val_type ne "void"
		    $type = $val_type

subcode: var_array_type
    $if defined $array
	my $layer=0
	$while $array=~/\[.*?\]/g
	    $if !$explicit_type
		$type=pointer_type($type)
	    $layer++
	$vtype=$type." "."*"x$layer
    $else
	$vtype=$type

subcode: var_init_line
    $if $type eq "function"
	$vinit=$fntype{$name};
    $elif defined $array
	$vinit="$type $name$array$tail";
    $else
	$vinit="$type $name$tail";
    $if @attrs
	$vinit=join(' ', @attrs)." $vinit"

subcode:: package_globals
    use File::stat
    our @extern_binary;

    $sub get_mtime($fname)
	my $st=stat($fname)
	return $st->[9]

subcode:: c_init
    @extern_binary=()

subcode: value_from_file
    $if $tail=~/^=\[string_from_file:(\S+)\]/
	my @t;
	open In, $1 or die "string_from_file: can't open $1\n"
	$while <In>
	    chomp
	    s/\\/\\\\/g
	    s/"/\\"/g
	    push @t, $_
	close In
	$tail="=\"".join("\\n\\\n", @t)."\""
    $elif $tail=~/^=\[binary_from_file:(\S+)\]/
	push @global_list, "extern char _$name"
	$tail="=&_$name"
	push @extern_binary, "$name:$1"

subcode: process_extern_binary
    my $ofile=$page->{outdir}."/extern.o"
    my $otime=get_mtime($ofile)
    my $need_update=0
    my @externS;
    push @externS, "    .section .rodata"
    $foreach $t in @extern_binary
	$if $t=~/(.*):(.*)/
	    my ($name, $fname)=($1,$2)
	    push @externS, "    .global _$name"
	    #push @externS, "    .type   $name, \"object\""
	    push @externS, "    .align  4"
	    push @externS, "_$name:"
	    push @externS, "    .incbin \"$fname\""
	    $if get_mtime($fname)>$otime
		$need_update=1
    $if $need_update
	print "  ---> $ofile\n"
        open Out, ">$page->{outdir}/extern.s"
	print Out join("\n", @externS), "\n";
	close Out

	my $cmd= "as -o $ofile"
	open PIPE, "|$cmd" or die "Can't run $cmd\n"
	print PIPE join("\n", @externS), "\n"
	close PIPE
    $if -f $ofile
	$objects{"extern.o"}=1


#-------------------------------------------------------------
subcode:: c_support_subs
    $sub func_return
	my ($l, $out)=@_;
	$if !$cur_function->{ret_type}
	    $if $l=~/return\s+(.*)/
		my $t=$1;
		$if $t=~/(\w+)/
		    $cur_function->{ret_var}=$1;
		$cur_function->{ret_type}=infer_c_type($t)
	    $else
		$cur_function->{ret_type}="void";
	    $if $debug eq "type"
		print "Check ret_type: $cur_function->{name} [$l] -> $cur_function->{ret_type}\n";
	$if $cur_indent<=1
	    $cur_function->{has_return}=1;

	func_var_release($out);

    $sub func_var_init
	my ($v, $type)=@_;
	my $init;
	$foreach my $fh in @func_var_hooks
	    $if $fh->{var_check}->($type)
		$init=$fh->{var_init}->($v, $type);
	$if $init
	    return $init;

    $sub func_var_release
	my ($out)=@_;
	my $ret_type=$cur_function->{ret_type};
	my $ret_var=$cur_function->{ret_var};
	my $var_list=$cur_function->{var_list};
	my $var_type=$cur_function->{var_type};
	$if @$var_list and @func_var_hooks
	    $foreach my $name in @$var_list
		my $type=$var_type->{$name};
		$if $name ne $ret_var
		    $foreach my $fh in @func_var_hooks
			$if $fh->{var_check}->($type)
			    my $exit=$fh->{var_release}->($type, $name);
			    $if $exit
				$foreach my $l in @$exit
				    push @$out, $l;


    $sub func_var_assign
	my ($type, $name, $val, $out)=@_;
	$if $debug eq "type"
	    print "func_var_assign: $type $name = $val\n"
	my $done_out;
	$if @func_var_hooks
	    $foreach my $fh in @func_var_hooks
		$if $fh->{var_check}->($type)
		    $fh->{var_pre_assign}->($type, $name, $val, $out);
		    push @$out, "$name=$val;";
		    $fh->{var_post_assign}->($type, $name, $val, $out);
		    $done_out=1;
		    last;
	$if !$done_out
	    push @$out, "$name=$val;";

# -----------------------------------------------------------------
subcode: process_function_std
    my $name=$func->{name};

    # ---- open block ------------------
    $if !$func->{openblock}
	my @t
	my $ret_type=$func->{ret_type};
	if(!$ret_type){$ret_type="void";}
	my $paramlist=$func->{'param_list'};
	my $param=join(', ', @$paramlist);
	push @t,  "$ret_type $name($param){"
	$func->{openblock}=\@t

    # ---- close block ----------------------
    $if !$func->{closeblock}
	my @t
	push @t, "}";
	push @t, "NEWLINE";
	$func->{closeblock}=\@t

    my (@pre, @post);
    $func->{preblock}=\@pre;
    $func->{postblock}=\@post;

    # ---- pre block -----------------------
    my $var_decl=$func->{var_decl};
    my $var_list=$func->{var_list};
    $if @$var_list
	$foreach my $v in @$var_list
	    $if $global_type->{$v}
		print "  [warning] In $name: local variable $v with exisiting global\n"
	    push @pre, "$var_decl->{$v};";
	push @pre, "NEWLINE";

    $foreach my $tl in @{$func->{init}}
	push @pre, $tl;

    # ---- post block ----------------------- 
    $if !$func->{has_return}
	$cur_function=$func
	func_var_release(\@post);

    $foreach my $tl in @{$func->{finish}}
	push @post, $tl;


############################################################################
subcode:: c_support_subs
    sub mu_enable {
	$misc_vars{mu_enable}=1;
	push @func_var_hooks, {var_check=>\&mu_var_check, var_init=>\&mu_var_init, var_pre_assign=>\&mu_pre_assign, var_post_assign=>\&mu_post_assign, var_release=>\&mu_release};
    }

    $sub mu_var_check
	my ($type)=@_;
	$if $type=~/\*$/
	    return 1;
	$else
	    return 0;

    $sub mu_var_init
	return "NULL";

    $sub mu_pre_assign
	my ($type, $name, $val, $out)=@_;
	$if $var_flag->{$name} eq "retained"
	    my $var_flag=$cur_function->{var_flag};
	    push @$out, "if($name){mu_release($name);}";
	    $var_flag->{$name}=0;

    $sub mu_post_assign
	my ($type, $name, $val, $out)=@_;
	#print "mu_post_assign: $type $name = $val\n";
	my $var_flag=$cur_function->{var_flag};
	$if $val=~/^\s*(NULL|0)\s*$/i
	    NOOP
	$elsif $val=~/^\s*(\w+)(.*)/
	    my $v_name=$1;
	    my $v_tail=$2;
	    $if $v_tail=~/^\s*\(/ and MyDef::is_sub($v_name)
		$var_flag->{$name}="retained";
		#print "retain $name\n";
	    $else
		NOOP
		#push @$out, "mu_retain($name);";

    $sub mu_release
	my ($type, $name, $skipcheck)=@_;
	$if $skipcheck
	    return mu_release_0($type, $name, $out)
	$else
	    my $var_flag=$cur_function->{var_flag};
	    #print "$cur_function->{name} mu_release($name): flag: $var_flag->{$name}\n";
	    $if $func->{mu_skip}->{$name}
	    $elsif $var_flag->{$name} eq "retained"
		return mu_release_0($type, $name, $out)

    $sub mu_release_0
	my ($type, $name)=@_;
	my @out;
	push @out, "if($name){";
	push @out, "INDENT";
	if($type=~/^struct\s+(\w+)\s*$/){
	    my $t=$structs{$1}->[0];
	    if($t->{destructor}){
		push @out, "$1_destructor($name);";
	    }
	}
	push @out, "mu_release($name);";
	push @out, "DEDENT";
	push @out, "}";
	return \@out
