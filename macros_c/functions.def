subcode:: c_init
    $global @scope_stack, $cur_scope
    @scope_stack=()

    $global $global_hash, $global_list
    $global_hash={}
    $global_list=[]
    $cur_scope={var_list=>$global_list, var_hash=>$global_hash, name=>"global"}

    $global %functions, $cur_function
    $global @function_list
    %functions=()
    undef $cur_function

subcode:: c_support_subs
    #--------------------------------------------------- 
    #- block scope: variable declaration and exit ------
    $sub open_scope($blk_idx, $scope_name)
	push @scope_stack, $cur_scope
	$cur_scope={var_list=>[], var_hash=>{}, name=>$scope_name}
	#---------------------------------------- 
	#- embed init block just as function.

    $sub close_scope($blk, $pre, $post)
	my ($var_hash, $var_list)
	$if ref($blk) eq "HASH"
	    $var_hash=$blk->{var_hash};
	    $var_list=$blk->{var_list};
	$else
	    $var_hash=$cur_scope->{var_hash};
	    $var_list=$cur_scope->{var_list};
	my @exit_calls
	$if @$var_list
	    $if !$pre
		$pre=MyDef::compileutil::get_named_block("_pre")
	    $foreach $v in @$var_list
		$if $global_hash->{$v}
		    $call warn, In $blk->{name}: local variable $v has existing global
		my $var=$var_hash->{$v}
		my $decl=var_declare($var)
		push @$pre, "$decl;";

		$if $var->{exit}
		    push @exit_calls, "$var->{exit}, $v"

	$if @exit_calls
	    $if !$post
		$post=MyDef::compileutil::get_named_block("_post")
	    my $out_save=$out
	    MyDef::compileutil::set_output($post)
	    $foreach $call_line in @exit_calls
		$if $call_line=~/free, (.*)/
		    push @$out, "if($1)free($1);"
		$else
		    # $print "exit_call: $call_line"
		    MyDef::compileutil::call_sub($call_line)
	    MyDef::compileutil::set_output($out_save)

	$if $blk->{return}
	    $if !$post
		$post=MyDef::compileutil::get_named_block("_post")
	    push @$post, $blk->{return}

	#- -- only applicable to block scopes ----
	$cur_scope=pop @scope_stack

#-----------------------------------------------------------------
subcode:: c_support_subs
    $sub open_function($fname, $param)
	my $func= {param_list=>[], var_list=>[], var_hash=>{}, init=>[], finish=>[], openblock=>[], closeblock=>[], preblock=>[], postblock=>[]};
	#---- reserve fn_init and fn_finish for user def use.----
	MyDef::compileutil::set_named_block("fn_init", $func->{init})
	MyDef::compileutil::set_named_block("fn_finish", $func->{finish})
	#---------
	$func->{name}=$fname;
	# -- parsing param list
	$if $param eq "api"
	    $call open_function_api
	$if $param
	    $call open_function_params
	# --
	$if $func->{name}
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	# --
	return $func

subcode: open_function_params
    my $param_list=$func->{param_list}
    my $var_hash=$func->{var_hash}
    my @plist=split /,\s*/, $param
    my $i=0
    $foreach $p in @plist
	$i++
	$if $p=~/(\S.*)\s+(\S+)\s*$/
	    my ($type, $name)=($1, $2)
	    $call check_pointer_type_name
	    $var_hash->{$name}={name=>$name, type=>$type}
	    push @$param_list, "$type $name"
	$elif $p eq "fmt" and $i==@plist
	    push @$param_list, "char * fmt, ..."
	$else
	    $if $fntype{$p}
		push @$param_list, $fntype{$p};
		$var_hash->{$p}={name=>$p, type=>"function"}
	    $else
		my $t= get_c_type($p);
		push @$param_list, "$t $p";
		$var_hash->{$p}={name=>$p, type=>$t}

subcode: open_function_api
    $if $fname=~/^([a-zA-Z0-9]+)_(\w+)/
	$if $fntype{$2}
	    my $t=$fntype{$2}
	    $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
		$func->{ret_type}=$1
		$param=$3

#---------------------------------------- 
subcode:: parsecode_func_other
    $elif $func eq "return_type"
	$cur_function->{ret_type}=$param;
	return
    $elif $func eq "parameter"
	$call open_function_params
	return
# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub func_return($t)
	MyDef::compileutil::trigger_block_post()

	$if !$cur_function->{ret_type}
	    $if $t
		$if $t=~/(\w+)/
		    $cur_function->{ret_var}=$1;
		$cur_function->{ret_type}=infer_c_type($t)
	    $else
		$cur_function->{ret_type}="void";
	    # print "Check ret_type: $cur_function->{name} [$t] -> $cur_function->{ret_type}\n";
	$if $cur_indent<=1
	    $cur_function->{has_return}=1;

# -----------------------------------------------------------------
subcode:: support_subs
    $sub process_function_std($func)
	my $name=$func->{name};

	my $open=$func->{openblock}
	my $close=$func->{closeblock}
	my $pre=$func->{preblock}
	my $post=$func->{postblock}

	my $ret_type=$func->{ret_type};
	$if !$ret_type
	    $ret_type="void"
	    $func->{ret_type}=$ret_type

	# ---- open block ------------------
	my $declare=$func->{declare}
	$if !$declare
	    my $param_list=$func->{"param_list"};
	    my $param=join(', ', @$param_list);
	    $declare="$ret_type $name($param)"
	    $func->{declare}=$declare
	push @$open, $declare."{"

	# ---- close block ----------------------
	push @$close, "}";
	push @$close, "NEWLINE";

	#---------------------------------------- 
	close_scope($func, $pre, $post)

	# ---- pre block -----------------------
	$if @{$func->{var_list}}
	    push @$pre, "NEWLINE";

	$foreach $t in @{$func->{init}}
	    push @$pre, $t

	# ---- post block ----------------------- 
	$foreach $t in @{$func->{finish}}
	    push @$post, $t


