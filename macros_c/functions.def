subcode:: c_init
    $global @scope_stack, $cur_scope
    @scope_stack=()

    $global $global_hash, $global_list
    $global_hash={}
    $global_list=[]
    $cur_scope={var_list=>$global_list, var_hash=>$global_hash, name=>"global"}

    $global %functions, $cur_function
    %functions=()
    undef $cur_function

subcode:: c_support_subs
    $sub open_scope($blk_name, $name)
	push @scope_stack, $cur_scope
	$cur_scope={var_list=>[], var_hash=>{}, name=>$name}

    $sub close_scope($blk_name)
	my $var_hash=$cur_scope->{var_hash};
	my $var_list=$cur_scope->{var_list};
	$if @$var_list
	    my $block=MyDef::compileutil::get_named_block($blk_name)
	    $foreach $v in @$var_list
		my $decl=var_declare($var_hash->{$v})
		push @$block, "$decl;";

	$cur_scope=pop @scope_stack

#-----------------------------------------------------------------
subcode:: c_support_subs
    $sub open_function($fname, $param)
	my $func= {param_list=>[], var_list=>[], var_hash=>{}, init=>[], finish=>[]};
	MyDef::compileutil::set_named_block("fn_init", $func->{init})
	MyDef::compileutil::set_named_block("fn_finish", $func->{finish})

	$func->{name}=$fname;
	# -- parsing param list
	$if $param eq "api"
	    $call open_function_api
	$if $param
	    $call open_function_params
	# --
	$if $func->{name}
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	# --
	$cur_function=$func;

	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;

subcode: open_function_params
    my $param_list=$func->{param_list}
    my $var_hash=$func->{var_hash}
    my @plist=split /,\s*/, $param
    my $i=0
    $foreach $p in @plist
	$i++
	$if $p=~/(\S.*)\s+(\S+)\s*$/
	    my ($type, $name)=($1, $2)
	    $call check_pointer_type_name
	    $var_hash->{$name}={name=>$name, type=>$type}
	    push @$param_list, "$type $name"
	$elif $p eq "fmt" and $i==@plist
	    push @$param_list, "char * fmt, ..."
	$else
	    $if $fntype{$p}
		push @$param_list, $fntype{$p};
		$var_hash->{$p}={name=>$p, type=>"function"}
	    $else
		my $t= get_c_type($p);
		push @$param_list, "$t $p";
		$var_hash->{$p}={name=>$p, type=>$t}

subcode: open_function_api
    $if $fname=~/^([a-zA-Z0-9]+)_(\w+)/
	$if $fntype{$2}
	    my $t=$fntype{$2}
	    $if $t=~/^(.*?)\s*\(\s*\*\s*(\w+)\s*\)\s*\(\s*(.*)\)/
		$func->{ret_type}=$1
		$param=$3

#---------------------------------------- 
subcode:: parsecode_func_other
    $elif $func eq "return_type"
	$cur_function->{ret_type}=$param;
	return
    $elif $func eq "parameter"
	$call open_function_params
	return
# -----------------------------------------------------------------
subcode:: c_support_subs
    $sub func_return($l)
	MyDef::compileutil::trigger_block_post()

	$if !$cur_function->{ret_type}
	    $if $l=~/return\s+(.*)/
		my $t=$1;
		$if $t=~/(\w+)/
		    $cur_function->{ret_var}=$1;
		$cur_function->{ret_type}=infer_c_type($t)
	    $else
		$cur_function->{ret_type}="void";
	    $if $debug eq "type"
		print "Check ret_type: $cur_function->{name} [$l] -> $cur_function->{ret_type}\n";
	$if $cur_indent<=1
	    $cur_function->{has_return}=1;

    $sub func_var_assign($type, $name, $val)
	$if $debug eq "type"
	    print "func_var_assign: $type $name = $val\n"
	#---- ToDo: instead of fucn_var_hooks, check for operator overload in subcodes
	my $done_out;
	$if !$done_out
	    push @$out, "$name=$val;";

# -----------------------------------------------------------------
subcode:: support_subs
    $sub process_function_std($func)
	my $name=$func->{name};

	# ---- open block ------------------
	$if !$func->{openblock}
	    my $declare=$func->{declare}
	    $if !$declare
		my $ret_type=$func->{ret_type};
		if(!$ret_type){$ret_type="void";}
		my $param_list=$func->{"param_list"};
		my $param=join(', ', @$param_list);
		$declare="$ret_type $name($param)"
		$func->{declare}=$declare
	    $func->{openblock}=[$declare."{"]

	# ---- close block ----------------------
	$if !$func->{closeblock}
	    my @t
	    push @t, "}";
	    push @t, "NEWLINE";
	    $func->{closeblock}=\@t

	my (@pre, @post);
	$func->{preblock}=\@pre;
	$func->{postblock}=\@post;

	# ---- pre block -----------------------
	my $var_hash=$func->{var_hash};
	my $var_list=$func->{var_list};
	$if @$var_list
	    $foreach my $v in @$var_list
		$if $global_hash->{$v}
		    print "  [warning] In $name: local variable $v has existing global\n"
		my $decl=var_declare($var_hash->{$v})
		push @pre, "$decl;";
	    push @pre, "NEWLINE";

	$foreach my $tl in @{$func->{init}}
	    push @pre, $tl;

	# ---- post block ----------------------- 
	$if !$func->{has_return}
	    $cur_function=$func
	    # func_var_release(\@post);

	$foreach my $tl in @{$func->{finish}}
	    push @post, $tl;


