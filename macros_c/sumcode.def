subcode:: parsecode_func_other
    $elif $func eq  "sumcode"
	# $call sumcode, sum = A[i]
	$call sumcode_parse
	$call sumcode_generate
	MyDef::compileutil::parseblock({source=>\@code, name=>"sumcode"})
	return

#---------------------------------------- 
subcode: sumcode_generate
    my @klist=sort keys %k_hash
    my @allidx=(@left_idx, @right_idx)
    $foreach $k in @klist
	my $pos
	my $i=$#allidx
	$while $i>=0
	    $pos=index($k, $allidx[$i])
	    $if $pos>=0
		break
	    $i--
	my $k0=$allidx[$i]
	$pos--
	$i--
	$while $pos>=0 and substr($k, $pos, 1) eq $allidx[$i]
	    $pos--
	    $i--
	$if $i>=0
	    $k_hash{$k}=$allidx[$i].$k0
	$else
	    $k_hash{$k}="-".$k0

    my @code
    my %loop_hash
    $call sumcode_init_each_k
    &call sumcode_loop, left
	$if @right_idx
	    my $sum
	    $if $left=~/^(\w+)$/
		$sum=$1
		push @code, "$sum = 0"
	    $else
		$sum="sum"
		push @code, "\$my $type sum=0"
	    &call sumcode_loop, right
		push @code, "$sum += $right"
	    $if $left ne $sum
		push @code, "$left = $sum"
	$elif $right
	    push @code, "$left = $right"
	$else
	    push @code, $left

subcode: sumcode_loop(left)
    $(allow_recurse:10)
    $foreach $i in @$(left)_idx
	$loop_hash{$i}=1
	push @code, "\$for i_$i=0:$dim_hash{$i}"
	push @code, "SOURCE_INDENT"
	$call sumcode_set_each_k
    BLOCK
    $foreach $i in reverse @$(left)_idx
	$call sumcode_inc_each_k
	push @code, "SOURCE_DEDENT"

subcode: sumcode_init_each_k
    $foreach $k in @klist
	push @code, "\$my int k_$k"
	push @code, "k_$k = 0"

subcode: sumcode_set_each_k
    $foreach $k in @klist
	$if substr($k_hash{$k}, 0, 1) eq $i
	    $call sumcode_calc_k

subcode: sumcode_inc_each_k
    $foreach $k in @klist
	$if substr($k_hash{$k}, 1, 1) eq $i
	    $call sumcode_inc_k

subcode: sumcode_inc_k
    $if substr($k, -1, 1) eq $i
	push @code, "k_$k++"
    $else
	my $dim=$dim_hash{$i}
	push @code, "k_$k += $dim"

subcode: sumcode_calc_k
    my $t
    $for $j=0:length($k)-1
	my $ii=substr($k, $j, 1)
	$if $loop_hash{$ii}
	    my $dim=$dim_hash{substr($k, $j+1, 1)}
	    $if !$t
		$t = "i_$ii*$dim"
	    $else
		$t = "($t+_$ii)*$dim"
    my $ii=substr($k, -1, 1)
    $if $loop_hash{$ii}
	$t.="+i_$ii"
    push @code, "k_$k = $t"


#---------------------------------------- 
subcode: sumcode_parse
    my ($left, $right)
    $if $param=~/(.*?)\s*=\s*(.*)/
	($left, $right)=($1, $2)
    $else
	$left=$param

    my $type
    my %k_hash
    my %var_hash
    my %dim_hash
    my (@left_idx, @right_idx)
    $call sumcode_get_idx, left
    $if $right
	$call sumcode_get_idx, right

subcode: sumcode_get_idx(left)
    my @segs=split /(\w+\[[ijklmn,]*?\])/, $$(left)
    $foreach $s in @segs
	$if $s=~/^(\w+)\[([ijklmn,]*?)\]$/
	    $if $var_hash{$s}
		$s=$var_hash{$s}
	    $else
		$call sumcode_var
		$var_hash{$s}=$t
		$s=$t
    $$(left)=join '', @segs
    $$(left)=~s/\b([ijklmn])\b/i_\1/g

subcode: sumcode_var
    my $t
    my ($v, $idx)=($1, $2)
    my $var=find_var($v)
    $if !$type
	$type=pointer_type($var->{type})

    my @idxlist=split /,/, $idx
    $if @idxlist==1
	$call sumcode_idx, $idx, 1
	$t="$v\[i_$idx\]"
    $else
	my $k=join('', @idxlist)
	$k_hash{$k}=1
	$t="$v\[k_$k\]"
	my $i=0
	$foreach $ii in @idxlist
	    $i++
	    $call sumcode_idx, $ii, $i

subcode: sumcode_idx(idx, i)
    my ($dim, $inc)
    $if $var->{"dim$(i)"}
	$dim=$var->{"dim$(i)"}
    $(if:i=1)
	$elif $var->{"dimension"}
	    $dim=$var->{"dimension"}
    $else
	$print "sumcode: var $v missing dimension $(i)"

    $if !$dim_hash{$(idx)}
	push @$(left)_idx, $(idx)
	$dim_hash{$(idx)}=$dim
    $else
	$if $dim_hash{$(idx)} ne $dim
	    $print "sumcode dimesnion mismatch: $dim_hash{$(idx)} != $dim"





