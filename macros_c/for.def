subcode:: parsecode_func_other
    $elsif $func eq "for"
	$call c_parse_for
	return
    $elif $func eq "endfor"
	$call c_parse_for_end

    $elif $func eq "foreach"
	$if $param=~/(\w+)\s+in\s+(\w+)/
	    my ($iv, $v)=($1, $2)
	    return list_foreach($out, $iv, $v)

subcode: c_parse_for
    $global %protected_var
    $if $param=~/(\w+)\s*=\s*(.*?):(.*?)(:.*)?$/
	my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
	$call protect_var, $var
	func_add_var($var, undef, $i0);
	my $stepclause;
	$if $step
	    my $t=substr($step, 1);
	    $if $t eq "-1"
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $elsif $t=~/^-/
		$stepclause="$var=$i0;$var>$i1;$var=$var$t";
	    $elsif $t eq "1"
		$stepclause="$var=$i0;$var<$i1;$var++";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var+=$t";
	$else
	    # CAUTION
	    # I would like to have $i=n:0 be the reverse of $i=0:n
	    # Infact I would to symmetry between $i=$a:$b:$step and $i=$b:$a:-$step, TO BE DONE
	    $if $i1 eq "0"
		$stepclause="$var=$i0-1;$var>=0;$var--";
	    $elif $i1=~/^-?\d+/ and $i0=~/^-?\d+/ and $i1<$i0
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var++";
	my $end="PARSE:\$endfor $var"
	return single_block_pre_post(["for($stepclause){", "INDENT"], ["DEDENT", "}",$end])
    $else
	return single_block("for($param){", "}")

subcode: c_parse_for_end
    $protected_var{$param}--
    return

subcode: protect_var(v)
    $if $protected_var{$var}
	my $curfile=MyDef::compileutil::curfile_curline()
	print "[$curfile] Variable $var protected\n"
	$protected_var{$var}++
    $else
	$protected_var{$var}=1
