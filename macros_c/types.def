subcode:: package_globals
    $global %type_name, %type_prefix
    $global %fntype
    %type_name=(
	c=>"unsigned char",
	i=>"int",
	j=>"int",
	k=>"int",
	m=>"int",
	n=>"int",
	l=>"long",
	f=>"float",
	d=>"double",
	count=>"int",
    );
    %type_prefix=(
	n=>"int",
	n1=>"int8_t",
	n2=>"int16_t",
	n4=>"int32_t",
	n8=>"int64_t",
	ui=>"unsigned int",
	u=>"unsigned int",
	u1=>"uint8_t",
	u2=>"uint16_t",
	u4=>"uint32_t",
	u8=>"uint64_t",
	c=>"unsigned char",
	uc=>"unsigned char",
	b=>"int",
	s=>"char *",
	v=>"unsigned char *",
	f=>"float",
	d=>"double",
	"time"=>"time_t",
	"file"=>"FILE *",
	"strlen"=>"STRLEN",
	"has"=>"int",
	"is"=>"int",
    );

    $global %stock_functions
    %stock_functions=(
	"printf"=>1,
    );

    $global %lib_include, %type_include, %text_include
    %lib_include=(
	glib=>"glib",
    );

    %type_include=(
	time_t=>"time",
	int8_t=>"stdlib",
	int16_t=>"stdlib",
	int32_t=>"stdlib",
	int64_t=>"stdlib",
	uint8_t=>"stdlib",
	uint16_t=>"stdlib",
	uint32_t=>"stdlib",
	uint64_t=>"stdlib",
    );

    # TODO: limit to function call?
    %text_include=(
	"printf|perror"=>"stdio",
	"malloc"=>"stdlib",
	"str(len|dup|cpy)|memcpy"=>"string",
	"\\bopen\\("=>"fcntl",
	"sin|cos|sqrt|pow"=>"math",
	"fstat"=>"sys/stat",
	"assert"=>"assert",
    );

subcode:: c_support_subs
    $sub infer_c_type
	my $val=shift;
	$if $debug eq "type"
	    print "infer_c_type: [$val]\n"
	$if $val=~/^\((float|int|char|unsigned .*|.+\*)\)/
	    return $1
	$elif $val=~/^\((.*)/
	    return infer_c_type($1)
	$elif $val=~/^[+-]?\d+\./
	    return "float"
	$elif $val=~/^[+-]?\d/
	    return "int"
	$elif $val=~/^"/
	    return "char *";
	$elif $val=~/^'/
	    return "char";
	$elif $val=~/^\((\w+)\)\w/
	    return $1
	$elif $val=~/(\w+)\(.*\)/
	    my $func=$functions{$1}
	    return $func->{ret_type}
	$elif $val=~/(\w+)(.*)/
	    my $type=get_var_type($val)
	    return $type

    $sub get_c_type_word
	my $name=shift;
	$if $debug eq "type"
	    print "get_c_type_word: [$name] -> $type_prefix{$name}\n";
	$if $type_prefix{$name}
	    my $type=$type_prefix{$name}
	    return $type
	$elsif substr($name, 0, 1) eq "t"
	    return get_c_type_word(substr($name,1));
	$elsif substr($name, 0, 1) eq "p"
	    return get_c_type_word(substr($name,1)).'*';
	$elsif $name=~/^st(\w+)/
	    return "struct $1";
	$elif $name=~/^([a-z0-9]+)/
	    my $prefix=$1;
	    $if $type_prefix{$prefix}
		return $type_prefix{$prefix};
	    $elif $prefix=~/^(.*?)\d+$/ and $type_prefix{$1}
		return $type_prefix{$1};

    $sub get_c_type
	my $name=shift;
	my $check;
	my $type="void";
	$if $name=~/.*\.([a-zA-Z].+)/
	    #print "ctype: $name->$1\n";
	    $name=$1;
	$if $type_name{$name}
	    $type= $type_name{$name};
	$elsif $name=~/(\w+?)_(.*)/
	    my $t1=$1;
	    my $t2=$2;
	    my $t=get_c_type_word($t1);
	    $if !$t
		$if $t1=~/^\w+$/
		    $type=get_c_type_word($t2);
	    $elsif $t=~/^\*/
		$type=get_c_type_word($t2).$t;
	    $else
		$type=$t;
	$else
	    $type=get_c_type_word($name);

	$if !$type
	    $type="void";
	$elsif $type =~/^\*/
	    $type="void";
	# --
	$if $type_include{$type}
	    $call add_include, $type_include{$type}
	# --
	$while $name=~/\[.*?\]/g
	    $type=pointer_type($type);
	# --
	$if $debug eq "type"
	    print "get_c_type:   $name: $type\n";
	return $type;

    $sub name_with_prefix($name)
	$if $name=~/^(t_?)*(p_?)*([a-zA-Z][a-zA-Z0-9]*)\_/
	    my $prefix=$3
	    $if $debug eq "type"
		print "name_with_prefix: $prefix - $type_prefix{$prefix}\n"
	    $if $type_prefix{$prefix}
		return 1
	return 0

subcode:: c_support_subs
    $sub pointer_type
	my ($t)=@_;
	$t=~s/\s*\*\s*$//;
	return $t;

    $sub get_name_type
	my $t=shift
	$if $t=~/(\S.*\S)\s+(\S+)/
	    return ($1, $2)
	$else
	    return (get_c_type($t), $t)

    # --------------------------------------------
    $sub get_var_fmt($v, $warn)
	my $type=get_var_type($v)
	$if !$type or $type eq "void"
	    $type=get_c_type($v);
	$if $type=~/^char \*/
	    return "\%s";
	$elsif $type=~/\*\s*$/
	    return "\%p";
	$elsif $type=~/^(float|double)/
	    return "\%g"
	$elsif $type=~/(int|long)\s*$/
	    return "\%d";
	$elsif $type=~/^unsigned char/
	    return "\%d";
	$elsif $type=~/char/
	    return "\%c";
	$else
	    $if $warn
		print "get_var_fmt: unhandled $v - $type\n";
	    return undef

# -------------------------------------
subcode:: c_support_subs
    $sub fmt_string($str)
	# $if $str=~/^\w+$/
	#     return (0, $str)
	$if $str=~/^\s*\"(.*)\"\s*,(.*)$/
	    return (1, "\"$1\", $2")
	$elif $str=~/^\s*\"(.*)\"\s*$/
	    $str=$1

	my @segs=split /(\$\w+)/, $str
	my @vlist
	my $vcnt=0
	my $color_escape=0
	$for $j=0:@segs
	    $if $segs[$j]=~/^\$(\w+)/
		my $v=$1
		$call fmt_string_check_escape
		$call fmt_string_check_trailing
		$vcnt++
		$if $v=~/^(red|green|yellow|blue|magenta|cyan)$/
		    my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)
		    $segs[$j]="\\x1b[$colors{$1}m"
		    $color_escape=1
		$else
		    push @vlist, $v
		    $segs[$j]=get_var_fmt($v, 1)
	$if $color_escape
	    push @segs, "\\x1b[0m"
	$if $vcnt>0
	    return ($vcnt, '"'.join('',@segs).'", '.join(', ', @vlist))
	$else
	    return (0, '"'. join('', @segs).'"')

subcode: fmt_string_check_escape
    # print \$something ----
    $if $j>0 and $segs[$j-1]=~/(\\+)$/
	$if length($1)%2==1
	    $segs[$j-1]=~s/\\$//
	    next

subcode: fmt_string_check_trailing
    # print $var-follow ----
    $if $segs[$j+1]=~/^\\-\w/
	$segs[$j+1]=~s/^\\-//

# -------------------------------------
subcode:: c_support_subs
    $sub debug_dump($param, $prefix, $out)
	my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	$foreach my $v in @vlist
	    $if $v=~/^(\w+):(.*)/
		my ($color,$v)=($1,$2)
		push @a2, $v;
		push @a1, "\\x1b[$colors{$color}m" . "$v=".get_var_fmt($v, 1) . "\\x1b[0m"
	    $else
		my $fmt=get_var_fmt($v)
		$if !defined $fmt
		    push @a1, $v
		$else
		    push @a2, $v;
		    push @a1, "$v=".get_var_fmt($v, 1)
	$if $prefix
	    $if $prefix=~/(red|green|yellow|blue|magenta|cyan)/
		push @$out, "printf(\"\x1b[$colors{$prefix}m\");"
		push @$out, "printf(\"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
		push @$out, "printf(\"\x1b[0m\");"
	    $else
		push @$out, "fprintf(stdout, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$else
	    push @$out, "fprintf(stdout, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$includes{"<stdio.h>"}=1;

