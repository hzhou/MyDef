subcode:: package_globals
    $global %type_name, %type_prefix
    $global %fntype
    %type_name=(
	c=>"unsigned char",
	i=>"int",
	j=>"int",
	k=>"int",
	m=>"int",
	n=>"int",
	l=>"long",
	f=>"float",
	d=>"double",
	count=>"int",
    );
    %type_prefix=(
	n=>"int",
	n1=>"int8_t",
	n2=>"int16_t",
	n4=>"int32_t",
	n8=>"int64_t",
	ui=>"unsigned int",
	u=>"unsigned int",
	u1=>"uint8_t",
	u2=>"uint16_t",
	u4=>"uint32_t",
	u8=>"uint64_t",
	c=>"unsigned char",
	uc=>"unsigned char",
	b=>"int",
	s=>"char *",
	v=>"unsigned char *",
	f=>"float",
	d=>"double",
	"time"=>"time_t",
	"file"=>"FILE *",
	"strlen"=>"STRLEN",
	"has"=>"int",
	"is"=>"int",
    );

    $global %stock_functions
    %stock_functions=(
	"printf"=>1,
    );

    $global %lib_include, %type_include, %text_include
    %lib_include=(
	glib=>"glib",
    );

    %type_include=(
	time_t=>"time",
	int8_t=>"stdlib",
	int16_t=>"stdlib",
	int32_t=>"stdlib",
	int64_t=>"stdlib",
	uint8_t=>"stdlib",
	uint16_t=>"stdlib",
	uint32_t=>"stdlib",
	uint64_t=>"stdlib",
    );

    # TODO: limit to function call?
    %text_include=(
	"printf|perror"=>"stdio",
	"malloc"=>"stdlib",
	"str(len|dup|cpy)|memcpy"=>"string",
	"\\bopen\\("=>"fcntl",
	"sin|cos|sqrt|pow"=>"math",
	"fstat"=>"sys/stat",
	"assert"=>"assert",
    );

subcode:: c_support_subs
    $sub infer_c_type
	my $val=shift;
	$if $debug eq "type"
	    print "infer_c_type: [$val]\n"
	$if $val=~/^\((float|int|char|unsigned .*|.+\*)\)/
	    return $1
	$elif $val=~/^\((.*)/
	    return infer_c_type($1)
	$elif $val=~/^[+-]?\d+\./
	    return "float"
	$elif $val=~/^[+-]?\d/
	    return "int"
	$elif $val=~/^"/
	    return "char *";
	$elif $val=~/^'/
	    return "char";
	$elif $val=~/^\((\w+)\)\w/
	    return $1
	$elif $val=~/(\w+)\(.*\)/
	    my $func=$functions{$1}
	    return $func->{ret_type}
	$elif $val=~/(\w+)(.*)/
	    my $type=get_var_type($val)
	    return $type

    $sub type_default($type)
	$if $type=~/\*$/
	    return "NULL"
	$elif $type=~/float|double/
	    return "0.0"
	$elif $type=~/char|signed|int/
	    return "0"
	$else
	    return undef


subcode:: c_support_subs
    $sub get_c_type_word
	my $name=shift;
	$if $debug eq "type"
	    print "get_c_type_word: [$name] -> $type_prefix{$name}\n";
	$if $type_prefix{$name}
	    my $type=$type_prefix{$name}
	    return $type
	$elsif substr($name, 0, 1) eq "t"
	    return get_c_type_word(substr($name,1));
	$elsif substr($name, 0, 1) eq "p"
	    return get_c_type_word(substr($name,1)).'*';
	$elsif $name=~/^st(\w+)/
	    return "struct $1";
	$elif $name=~/^([a-z0-9]+)/
	    my $prefix=$1;
	    $if $type_prefix{$prefix}
		return $type_prefix{$prefix};
	    $elif $prefix=~/^(.*?)\d+$/ and $type_prefix{$1}
		return $type_prefix{$1};

    $sub get_c_type
	my $name=shift;
	my $check;
	my $type="void";
	$if $name=~/.*\.([a-zA-Z].+)/
	    #print "ctype: $name->$1\n";
	    $name=$1;
	$if $type_name{$name}
	    $type= $type_name{$name};
	$elsif $name=~/(\w+?)_(.*)/
	    my $t1=$1;
	    my $t2=$2;
	    my $t=get_c_type_word($t1);
	    $if !$t
		$if $t1=~/^\w+$/
		    $type=get_c_type_word($t2);
	    $elsif $t=~/^\*/
		$type=get_c_type_word($t2).$t;
	    $else
		$type=$t;
	$else
	    $type=get_c_type_word($name);

	$if !$type
	    $type="void";
	$elsif $type =~/^\*/
	    $type="void";
	# --
	$if $type_include{$type}
	    $call add_include, $type_include{$type}
	# --
	$while $name=~/\[.*?\]/g
	    $type=pointer_type($type);
	# --
	$if $debug eq "type"
	    print "get_c_type:   $name: $type\n";
	return $type;

    $sub name_with_prefix($name)
	$if $name=~/^(t_?)*(p_?)*([a-zA-Z][a-zA-Z0-9]*)\_/
	    my $prefix=$3
	    $if $debug eq "type"
		print "name_with_prefix: $prefix - $type_prefix{$prefix}\n"
	    $if $type_prefix{$prefix}
		return 1
	return 0

subcode:: c_support_subs
    $sub pointer_type
	my ($t)=@_;
	$t=~s/\s*\*\s*$//;
	return $t;

    $sub get_name_type
	my $t=shift
	$if $t=~/(\S.*\S)\s+(\S+)/
	    return ($1, $2)
	$else
	    return (get_c_type($t), $t)

    # --------------------------------------------
    $sub get_var_fmt($v, $warn)
	my $type=get_var_type($v)
	$if !$type or $type eq "void"
	    $type=get_c_type($v);
	$if $type=~/^char \*/
	    return "\%s";
	$elsif $type=~/\*\s*$/
	    return "\%p";
	$elsif $type=~/^(float|double)/
	    return "\%g"
	$elsif $type=~/(int|long)\s*$/
	    return "\%d";
	$elsif $type=~/^unsigned char/
	    return "\%d";
	$elsif $type=~/char/
	    return "\%c";
	$else
	    $if $warn
		print "get_var_fmt: unhandled $v - $type\n";
	    return undef

# -------------------------------------
subcode:: c_support_subs
    $sub fmt_string($str)
	# print "fmt_string: [$str]\n"
	my @pre_list
	$if $str=~/^\s*\"(.*)\"\s*,\s*(.*)$/
	    $str=$1
	    @pre_list=MyDef::utils::proper_split($2)
	$elif $str=~/^\s*\"(.*)\"\s*$/
	    $str=$1

	my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)

	my @fmt_list
	my @arg_list

	my @group
	&call parse_loop, $str
	    &call if_lex, %
		&call if_lex, %
		    push @fmt_list, '%%'
		&call if_lex, [-+ #]*[0-9]*(\.\d+)?[diufFeEgGxXoscpaAn]
		    push @arg_list, shift @pre_list
		    push @fmt_list, "%$&"
		$else
		    push @fmt_list, '%%'
	    &call if_lex, \$
		&call if_lex, (red|green|yellow|blue|magenta|cyan)
		    push @fmt_list, "\\x1b[$colors{$1}m"
		    &call if_lex, \{
			push @group, $1
		&call if_lex, (\w+)
		    push @arg_list, $1
		    push @fmt_list, get_var_fmt($1, 1)
		    &call if_lex, -
			# print $var-follow ----
		$else
		    push @fmt_list, '$'
	    &call if_lex, \\\$
		push @fmt_list, '$'
	    &call if_lex, \}
		$if @group
		    pop @group
		    $if !@group
			push @fmt_list, "\\x1b[0m"
		    $else
			my $c=$group[-1]
			push @fmt_list, "\\x1b[$colors{$c}m"
		$else
		    push @fmt_list, '}'
	    &call if_lex, [^%\$\}]+
		push @fmt_list, $&
	    # print "parse_loop pos: ", pos($str), "\n"

	$if @pre_list
	    warn "Extra fmt arg list: ", join(", ", @pre_list), "\n"

	my $tail=$fmt_list[-1]
	$if $tail=~/(.*)-$/
	    $fmt_list[-1]=$1
	$elif $tail!~/\\n$/
	    push @fmt_list, "\\n"

	$if !@arg_list
	    return (0, '"'.join('',@fmt_list).'"')
	$else
	    my $vcnt=@arg_list
	    return ($vcnt, '"'.join('',@fmt_list).'", '.join(', ', @arg_list))

# -------------------------------------
subcode:: c_support_subs
    $sub debug_dump($param, $prefix, $out)
	my %colors=(red=>31,green=>32,yellow=>33,blue=>34,magenta=>35,cyan=>36)
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	$foreach my $v in @vlist
	    $if $v=~/^(\w+):(.*)/
		my ($color,$v)=($1,$2)
		push @a2, $v;
		push @a1, "\\x1b[$colors{$color}m" . "$v=".get_var_fmt($v, 1) . "\\x1b[0m"
	    $else
		my $fmt=get_var_fmt($v)
		$if !defined $fmt
		    push @a1, $v
		$else
		    push @a2, $v;
		    push @a1, "$v=".get_var_fmt($v, 1)
	$if $prefix
	    $if $prefix=~/(red|green|yellow|blue|magenta|cyan)/
		push @$out, "printf(\"\x1b[$colors{$prefix}m\");"
		push @$out, "printf(\"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
		push @$out, "printf(\"\x1b[0m\");"
	    $else
		push @$out, "fprintf(stdout, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$else
	    push @$out, "fprintf(stdout, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$includes{"<stdio.h>"}=1;

