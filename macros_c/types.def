subcode:: package_globals
    our %fntype;
    our %type_name=(
	c=>"unsigned char",
	i=>"int",
	j=>"int",
	k=>"int",
	m=>"int",
	n=>"int",
	l=>"long",
	f=>"float",
	d=>"double",
	count=>"int",
    );
    our %type_prefix=(
	n=>"int",
	n1=>"int8_t",
	n2=>"int16_t",
	n4=>"int32_t",
	n8=>"int64_t",
	ui=>"unsigned int",
	u=>"unsigned int",
	u1=>"uint8_t",
	u2=>"uint16_t",
	u4=>"uint32_t",
	u8=>"uint64_t",
	c=>"unsigned char",
	uc=>"unsigned char",
	b=>"int",
	s=>"char *",
	v=>"unsigned char *",
	f=>"float",
	d=>"double",
	"time"=>"time_t",
	"file"=>"FILE *",
	"strlen"=>"STRLEN",
	"has"=>"int",
	"is"=>"int",
    );

    our %stock_functions=(
	"printf"=>1,
    );

    my %lib_include=(
	glib=>"glib.h",
    );

    my %type_include=(
	time_t=>"time.h",
	int8_t=>"stdlib.h",
	int16_t=>"stdlib.h",
	int32_t=>"stdlib.h",
	int64_t=>"stdlib.h",
	uint8_t=>"stdlib.h",
	uint16_t=>"stdlib.h",
	uint32_t=>"stdlib.h",
	uint64_t=>"stdlib.h",
    );

    my %text_include=(
	"printf|perror"=>"stdio.h",
	"malloc"=>"stdlib.h",
	"str(len|dup|cpy)|memcpy"=>"string.h",
	"\\bopen\\("=>"fcntl.h",
	"sin|cos|sqrt|pow"=>"math.h",
	"fstat"=>"sys/stat.h",
    );

    sub register_type_prefix {
	my ($k, $v)=@_;
	$type_prefix{$k}=$v;
    }

subcode:: c_support_subs
    $sub infer_c_type
	my $val=shift;
	$if $debug eq "type"
	    print "infer_c_type: [$val]\n"
	$if $val=~/^[+-]?\d+\./
	    return "float"
	$elif $val=~/^[+-]?\d/
	    return "int"
	$elif $val=~/^"/
	    return "char *";
	$elif $val=~/^'/
	    return "char";
	$elif $val=~/^\((\w+)\)\w/
	    return $1
	$elif $val=~/(\w+)\(.*\)/
	    my $func=$functions{$1}
	    return $func->{ret_type}
	$elif $val=~/(\w+)(.*)/
	    my $tail=$2;
	    my $type=get_var_type_complex($val)
	    $if !$type
		$type=get_c_type($1)
	    # --
	    my $check_tail=1
	    $while $check_tail
		$check_tail=0
		$if $type=~/struct (\w+)/
		    $if $structs{$1}
			my $s_hash=$structs{$1}->{hash}
			$if $tail=~/^(->|\.)(\w+)/
			    $tail=$';
			    $type=$s_hash->{$2}
			    $check_tail=1
		    $else
			return;
		$if $type=~/\*\s*$/
		    $if $tail=~/^\[.*?\]/
			$tail=$';
			$type=~s/\s*\*\s*$//;
			$check_tail=1
	    return $type

    $sub get_c_type_word
	my $name=shift;
	$if $debug eq "type"
	    print "get_c_type_word: [$name] -> $type_prefix{$name}\n";
	$if $type_prefix{$name}
	    my $type=$type_prefix{$name}
	    return $type
	$elsif substr($name, 0, 1) eq "t"
	    return get_c_type_word(substr($name,1));
	$elsif substr($name, 0, 1) eq "p"
	    return get_c_type_word(substr($name,1)).'*';
	$elsif $name=~/^st(\w+)/
	    return "struct $1";
	$elif $name=~/^([a-z0-9]+)/
	    $prefix=$1;
	    $if $type_prefix{$prefix}
		return $type_prefix{$prefix};
	    $elif $prefix=~/^(.*?)\d+$/ and $type_prefix{$1}
		return $type_prefix{$1};

    $sub get_c_type
	my $name=shift;
	my $check;
	my $type="void";
	$if $name=~/.*\.([a-zA-Z].+)/
	    #print "ctype: $name->$1\n";
	    $name=$1;
	$if $type_name{$name}
	    $type= $type_name{$name};
	$elsif $name=~/(\w+?)_(.*)/
	    my $t1=$1;
	    my $t2=$2;
	    my $t=get_c_type_word($t1);
	    $if !$t
		$if $t1=~/^\w+$/
		    $type=get_c_type_word($t2);
	    $elsif $t=~/^\*/
		$type=get_c_type_word($t2).$t;
	    $else
		$type=$t;
	$else
	    $type=get_c_type_word($name);

	$if !$type
	    $type="void";
	$elsif $type =~/^\*/
	    $type="void";
	# --
	$if $type_include{$type}
	    add_include($type_include{$type});
	# --
	$while $name=~/\[.*?\]/g
	    $type=pointer_type($type);
	# --
	$if $debug eq "type"
	    print "get_c_type:   $name: $type\n";
	return $type;

    $sub pointer_type
	my ($t)=@_;
	$t=~s/\s*\*\s*$//;
	return $t;

    $sub get_name_type
	my $t=shift
	$if $t=~/(\S.*\S)\s+(\S+)/
	    return ($1, $2)
	$else
	    return (get_c_type($t), $t)
    # --------------------------------------------
    $sub get_c_fmt 
	my $name=shift;
	my $type=get_var_type($name);
	$if $type =~/(int|long)$/
	    return "%d";
	$elsif $type eq "char"
	    return "%c";
	$elsif $type eq "char *"
	    return "%s";

    $sub get_var_fmt($v)
	my $type=get_compound_type($v)
	$if !$type
	    $type=get_c_type($v);
	$if $type=~/^char \*/
	    return "\%s";
	$elsif $type=~/\*\s*$/
	    return "\%p";
	$elsif $type=~/^(float|double)/
	    return "\%g"
	$elsif $type=~/(int|long)\s*$/
	    return "\%d";
	$elsif $type=~/^unsigned char/
	    return "\%d";
	$elsif $type=~/char/
	    return "\%c";
	$else
	    print "get_var_fmt: unhandled $v - $type\n";
	    return $v

