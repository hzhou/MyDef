include: macros_util/tool_output.def

subcode:: package_globals
    my %regex_hash

subcode:: c_support_subs
    $sub parse_regex_match($re, $var, $pos, $end)
	#  -- regex pattern -> prefix list -> nfa state list
	my $startstate=build_nfa(parse_regex($re))

	# ---- implement -------------------------------------
	my $straight=build_straight($startstate)
	$if $straight
	    return $straight
	$else
	    my $strstart="$var+$pos";
	    my $strend="$var+$end";
	    $if !$pos
		$strstart=$var
	    $if !$end
		func_add_var("n_regex_limit", "int")
		$strend="$strstart+n_regex_limit"
		push @$out, "n_regex_limit=strlen($strstart);"
	    $call regex_init_code
	    my $strvar=$var;
	    my $size=$end;
	    $if $pos
		$strvar="$var+$pos";
		$size=$end-$pos;
	    my $n=dump_vm_c(build_vm($startstate), $out);
	    return "regex_vm_match(nfa, $n, $strstart, $strend)";

subcode: regex_init_code
    $if !$misc_vars{regex_init}
	$misc_vars{regex_init}=1
	print "regex_init_code\n";
	my $block=MyDef::compileutil::get_named_block("global_init")
	&call replace_output, $block
	    MyDef::compileutil::call_sub("regex_init")

#### Regex Parser ##############################################
subcode:: c_support_subs
    # input: $re: regex pattern
    # output: \@dst
    $sub parse_regex
	my $re=shift;
	my @dst;

	my $natom=0; 
	my $nalt=0;
	my @parenlist;
	my @class;
	my $escape;
	my $inclass;

	$for $i=0:length($re)
	    my $c=substr($re, $i, 1);
	    $if $inclass
		$call parse_regex_inclass
	    $else
		$call parse_regex_normal
	# -----
	$if @parenlist
	    die "REGEX $re: Unmatched parenthesis\n";
	for(my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	for(my $i=0; $i<$nalt; $i++){ push @dst, "]|"; }
	#print join("-", @dst), "\n";
	return \@dst;

subcode: parse_regex_normal
    $if $escape
	$call parse_regex_escape
	$escape=0;

    $if $c eq "\\"
	$escape=1;
    $elsif $c eq '['
	for (my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	if(!$natom){ $natom=1; } else{ $natom=2; }
	@class=();
	$inclass=1;
    $elsif $c eq '('
	for (my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	push @parenlist, {nalt=>$nalt, natom=>$natom};
	$natom=0;
	$nalt=0;
    $elsif $c eq ')'
	for (my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	for(my $i=0; $i<$nalt; $i++){ push @dst, "]|"; }
	my $p=pop @parenlist;
	if(!$p){
	    die "REGEX $re: Unmatched parenthesis\n";
	}
	if(!$natom){
	    die "REGEX $re: Empty parenthesis\n";
	}
	$natom=$p->{natom};
	$nalt=$p->{nalt};
	$natom++;
    $elsif $c eq '|'
	if(!$natom){
	    die "REGEX $re: Empty alternations\n";
	}
	for (my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	$natom=0;
	$nalt++;
    $elsif $c eq '*' or $c eq '+' or $c eq '?'
	if(!$natom){
	    die "REGEX $re: Empty '$c'\n";
	}
	push @dst, "]$c";
    $else
	for (my $i=0; $i<$natom-1; $i++){ push @dst, "]."; }
	$if $c=~/](.+)/
	    $c=$1;
	$elsif $c eq '.'
	    $c = "AnyChar";
	$elsif $c eq '"'
	    $c="\\\""
	push @dst, $c;
	if(!$natom){ $natom=1; } else{ $natom=2; }

subcode: parse_regex_inclass
    my $c2=substr($re, $i+2, 1);
    $if substr($re, $i+1, 1) eq "-"
	push @class, "-$c$c2";
	$i+=2;
    $elsif $escape
	$if $c =~/[tnr']/
	    push @class, "\\$c";
	$elsif $c eq '\\'
	    push @class, "\\\\";
	$else
	    push @class, $c;
	$escape=0;
    $elsif $c eq "\\"
	$escape=1;
    $elsif $c eq ']'
	foreach my $t (@class){
	    push @dst, $t;
	}
	for(my $i=0; $i<@class-1; $i++){
	    push @dst, "]|";
	}
	$inclass=0;
    $else
	push @class, $c;

subcode: parse_regex_escape
    $if $c=~/[tnr']/
	$c="\\$c";
    $elsif $c eq 'd'
	$c="-09";
    $elsif $c =~/[()*+?|.\]\[]/
	$c="]$c";
    $elsif $c eq '\\'
	$c="]\\\\";

# ---------- NFA -----------------------------
subcode:: c_support_subs
    $sub build_nfa($src)
	$if ref($src) ne "ARRAY"
	    die "build_nfa error.\n"
	my @states;
	my @fragstack;
	my $straight=1;
	my $match={idx=>0, c=>"Match"};
	my $state_idx=1;
	$foreach $c in @$src
	    $if $c eq "]."
		$call nfa_concat
	    $elsif $c eq "]|"
		$call nfa_or
	    $elsif $c eq "]?"
		$call nfa_question
	    $elsif $c eq "]*"
		$call nfa_star
	    $elsif $c eq "]+"
		$call nfa_plus
	    $else
		$call nfa_char
	my $e=pop @fragstack;
	$if @fragstack
	    die "Unbalanced fragstack\n"
	$call nfa_frag_connect, $e, $match
	return $e->{start}

subcode: nfa_char
    $call nfa_new_state, $c
    # each fragstack node is a fragment of regex vm
    #     start is the starting state
    #     out is list of exit arrows (state->)
    push @fragstack, {start=>$state, out=>[{state=>$state, arrow=>"out1"}]};

# --
subcode: nfa_frag_connect(e, state)
    $foreach $out in @{$(e)->{out}}
	$out->{state}->{$out->{arrow})= $(state)

subcode: nfa_new_state(name)
    my $state={idx=>$state_idx, c=>$(name)}
    push @states, $state; 
    $state_idx++;

# --
subcode: nfa_concat
    my $e2=pop @fragstack;
    my $e1=pop @fragstack;
    $call nfa_frag_connect, $e1, $e2->{start}
    push @fragstack, {start=>$e1->{start}, out=>$e2->{out}}

subcode: nfa_or
    my $e2=pop @fragstack;
    my $e1=pop @fragstack;
    $call nfa_new_state, "Split"
    $state->{out1}=$e1->{start}
    $state->{out2}=$e2->{start}
    my $eout=$e1->{out};
    push @$eout, @{$e2->{out}}
    push @fragstack, {start=>$state, out=>$eout}

subcode: nfa_question
    my $e=pop @fragstack
    $call nfa_new_state, "Split"
    $state->{out1}=$e->{start}
    my $eout=$e->{out}
    push @$eout, {state=>$state, arrow=>"out2"}
    push @fragstack, {start=>$state, out=>$eout}

subcode: nfa_star_state
    my $e=pop @fragstack;
    $call nfa_new_state, "Split"
    $state->{out1}=$e->{start}
    my $eout=$e->{out};
    $call nfa_frag_connect, $e, $state

subcode: nfa_star
    $call nfa_star_state
    push @fragstack, {start=>$state, out=>[{state=>$state, arrow=>"out2"}]};

subcode: nfa_plus
    $call nfa_star_state
    push @fragstack, {start=>$e->{start}, out=>[{state=>$state, arrow=>"out2"}]};

# ----------------- REGEX VM -----------------------
subcode:: c_support_subs
    # Regex VM is simply a list [opcode, char, n_out1, n_out2]
    $sub build_vm
	my $startstate=shift;
	my @threadstack;
	push @threadstack, $startstate;
	my $count;
	my @vm;
	my %address;
	$while my $state=pop @threadstack
	    $if defined $address{$state}
		next;
	    $while 1
		$if defined $address{$state}
		    push @vm, ["Jmp", undef, $state, undef];
		    last;
		$else
		    $address{$state}=$#vm+1;
		    $if $state->{c} eq "Match"
			push @vm,  ["Match", undef, undef, undef];
			last;
		    $elsif $state->{c} eq "Split"
			push @vm, ["Split", undef, $state->{out1}, $state->{out2}];
			push @threadstack, $state->{out1};
			push @threadstack, $state->{out2};
			last;
		    $elsif $state->{c} eq "AnyChar"
			push @vm,  ["AnyChar", undef, undef, undef];
			$state=$state->{out1};
		    $else
			push @vm,  ["Char", $state->{c}, undef, undef];
			$state=$state->{out1};
		    $count++;
		    $if $count>1000
			die "deadloop\n"
	# -- patch labels
	$foreach my $l  in @vm
	    $if $l->[0] eq "Jmp"
		$l->[2]=$address{$l->[2]};
	    $elsif $l->[0] eq "Split"
		$l->[2]=$address{$l->[2]};
		$l->[3]=$address{$l->[3]};
	return \@vm;

subcode:: c_support_subs
    $sub dump_vm_c($vm, $out)
	# TODO: Need Move to Function init, nfa$i
	my $n=@$vm;
	func_add_var("nfa", "struct VMInst *")
	push @$out, "nfa=(struct VMInst[$n]) {";
	my $i=0;
	$foreach my $l in @$vm
	    $if $l->[0] eq "Match"
		push @$out, "    Match, 0, 0, 0,";
	    $elsif $l->[0] eq "Char"
		my $c="'$l->[1]'";
		push @$out, "    Char, $c, 0, 0,";
	    $elsif $l->[0] eq "Split"
		push @$out, "    Split, 0, $l->[2], $l->[3],";
	    $elsif $l->[0] eq "Jmp"
		push @$out, "    Jmp, 0,  $l->[2], 0,";
	    $elsif $l->[0] eq "AnyChar"
		push @$out, "    AnyChar, 0, 0, 0,";
	    $i++;
	push @$out, "};";
	return $n;

subcode: print_vm(vm)
    $call vm_find_labels, $(vm)
    my $i=0
    $foreach my $l in @$(vm)
	$if $labelhash{$i}
	    print "$i:"

	$if $l->[0] eq "Match"
	    print "\tMatch\n";
	$elsif $l->[0] eq "Char"
	    print "\tChar $l->[1]\n";
	$elsif $l->[0] eq "Split"
	    print "\tSplit $l->[2], $l->[3]\n";
	$elsif $l->[0] eq "Jmp"
	    print "\tJmp $l->[2]\n";
	$elsif $l->[0] eq "AnyChar"
	    print "\tAnyChar\n";
	$i++;

subcode: vm_find_labels(vm)
    my %labelhash
    $foreach $l in @$(vm)
	$if $l->[0] eq "Jmp"
	    $labelhash{$l->[2]}=1
	$elif $l->[0] eq "Split"
	    $labelhash{$l->[2]}=1
	    $labelhash{$l->[3]}=1

#### --------------------------------------------------------------
# ----------- Straight -----------------------------
subcode:: c_support_subs
    $sub build_straight($startstate)
	# -- buildup "and" "or" list
	my @threadstack;
	my $p=["and"]
	push @threadstack, {state=>$startstate, offset=>0, output=>$p};
	my %state_hash
	$while my $thread=pop @threadstack
	    my $state=$thread->{state};
	    my $off=$thread->{offset};
	    my $rout=$thread->{output};
	    $while 1
		my $position
		$call regex_get_position
		my @str_buffer
		$while $state->{c} !~ /^(Match|Split|AnyChar|Class|-..|\\\d)/
		    push @str_buffer, $state->{c}
		    $state=$state->{"out1"};
		$call regex_get_str

		$call straight_hash
		$if $state->{c} eq "Match"
		    last;
		$elsif $state->{c} eq "Split"
		    my ($s1, $s2)=(["and"], ["and"]);
		    push @$rout, ["or", $s1, $s2];
		    push @threadstack, {state=>$state->{"out1"}, offset=>$off, output=>$s1};
		    push @threadstack, {state=>$state->{"out2"}, offset=>$off, output=>$s2};
		    last;
		$elsif $state->{c} eq "AnyChar"
		    $state=$state->{"out1"};
		    $off++;
		$elsif $state->{c} eq "Class"
		    $state=$state->{"out1"};
		    $off++;
		$elif $state->{c} =~/^-(.)(.)/
		    push @$rout, "$var\[$position\]>='$1' && $var\[$position\]<='$2'"
		    $state=$state->{"out1"};
		    $off++;
	return regex_straight($p)

    $sub regex_straight
	my $a=shift;
	$if !ref($a)
	    return $a;
	$elsif ref($a) eq "ARRAY"
	    my $t=shift(@$a);
	    my $sep;
	    my @tlist;
	    $foreach my $b in @$a
		push @tlist, regex_straight($b);
	    $if $t eq "and"
		$if @tlist==1 and $tlist[0]=~/^\((.*)\)$/
		    return $1;
		$else
		    return join(" && ", @tlist);
	    $elsif $t eq "or"
		return "(".join(" || ", @tlist).")";


subcode: straight_hash
    $if $state_hash{$state}
	return undef
    $else
	$state_hash{$state}=1

subcode: regex_get_position
    $if !$pos
	$position=$off;
    $elsif $pos=~/^\d+/
	$position=$pos+$off;
    $elif $off
	$position="$pos+$off";
    $else
	$position=$pos;

subcode: regex_get_str
    my $n=@str_buffer
    $if $n>2
	my $s=join '', @str_buffer
	push @$rout, "strncmp($var+$position, \"$s\", $n)==0"
	$off+=$n
	$call regex_get_position
    $else
	$for $i=0:$n
	    push @$rout, "$var\[$position\]=='$str_buffer[$i]'"
	    $off++
	    $call regex_get_position

subcode:: c_support_subs
