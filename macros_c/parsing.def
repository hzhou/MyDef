subcode:: package_globals
    our $anonymous_count=0
    our %plugin_statement
    our %plugin_condition

subcode: debug_plugin
    $while my ($funcname, $codename)=each %plugin_statement
	print " plugin statement:  $funcname => $codename\n"
    $while my ($funcname, $codename)=each %plugin_condition
	print " plugin condition:  $funcname => $codename\n"


subcode: c_parsecode
    my $should_return=1
    $if $l=~/^SUBBLOCK BEGIN (\d+)/
	push @$out, "DUMP_STUB SUBBLOCK_$1"
	$if $debug eq "DUMP"
	    my ($code, $file, $line)=MyDef::compileutil::get_cur_code()
	    push @$out, "printf(\"subcode: $file - $line - $code->{name}\\n\");";
	open_scope("SUBBLOCK_$1")
    $elif $l=~/^SUBBLOCK END (\d+)/
	close_scope("SUBBLOCK_$1")
    $elif $l=~/^\s*PRINT\s+(.*)$/
	my ($n, $fmt)=fmt_string($1)
	push @$out, "printf($fmt);"
    $elif $l=~/^\s*\$(\w+)\((.*)\)\s+(.*)$/
	# $function(param1) param2 ---------------------------
	my ($func, $param1, $param2)=($1, $2, $3)
	$call parsecode_func_param
    $elif $l=~/^\s*\$(\w+)\s*(.*)$/
	# $function param  -----------------------------------
	my ($func, $param)=($1, $2)
	$call parsecode_func
    $else
	$should_return=0
    $if $should_return
	return
    $call @custom_parse
    $call parsecode_other

subcode: parsecode_func_param
    $if $func eq "allocate"
	allocate($param1, $param2);
    $elif $func eq "local_allocate"
	local_allocate($param1, $param2);
    $elsif $func eq "dump"
	debug_dump($param2, $param1, $out);
    $elsif $func eq "register_prefix"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_prefix{$param1}=$param2;
    $elsif $func eq "register_name"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_name{$param1}=$param2;
    $elsif $func eq "register_include"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_include{$param1}.=",$param2";
    $elif $func eq "get_type"
	my $type=get_var_type($param2);
	MyDef::compileutil::set_current_macro($param1, $type)
	return 
    $elif $func eq "get_pointer_type"
	my $type=pointer_type(get_var_type($param2));
	MyDef::compileutil::set_current_macro($param1, $type)
	return
    $elif $func eq "get_struct_var_prefix"
	my $type=get_var_type($param2)
	$if $type=~/struct (\w+)\s*\*/
	    MyDef::compileutil::set_current_macro($param1, "$param2->")
	$elif $type=~/struct (\w+)/
	    MyDef::compileutil::set_current_macro($param1, "$param2.")
	$else
	    die "get_var_type: $param2 returns type $type\n"
	return
    $elsif $func eq "struct"
	declare_struct($param1, $param2);
    $elsif $func eq "define"
	add_define($param1, $param2)
    $elsif $func eq "enum"
	$if !$enums{$param1}
	    push @enum_list, $param1;
	    $enums{$param1}=$param2;
	    $if $param1=~/^,\s*(\w+)/
		global_add_symbol("int $1")
    $elsif $func eq "enumbase"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t", $base)
	    $base++;
    $elsif $func eq "enumbit"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t",0x1<<$base)
	    $base++;
    $elif $func eq "write_h"
	$call write_h, $param1, $param2
    $elif $func eq "plugin"
	$if $param2=~/_condition$/
	    $plugin_condition{$param1}=$param2
	$else
	    $plugin_statement{$param1}=$param2
    $else
	$should_return=0

subcode: parsecode_func
    ## All the functions
    $if $func eq "block"
	return single_block("$param\{", "}")
    $elif $func eq "allocate"
	allocate(1, $param);
    $elif $func eq "pack"
	data_pack($param)
    $elif $func eq "unpack"
	data_unpack($param)
    $elif $func =~/^except/
	return single_block("$except\{", "}")
    $elif $func =~ /^(switch)$/
	return single_block("$1($param){", "}")
    $elif $func =~ /^(if|while|switch|(el|els|else)if)$/
	my $name=$1;
	$if $2
	    $name="else if";
	my $p=parse_condition($param, $out);
	return single_block("$name($p){", "}")
    $elsif $func =~/^dowhile/
	my $p=parse_condition($param, $out);
	return single_block("do{", "}while($p);")
    $elsif $func =~/^whiletrue/
	push @$out, "while($param);"
	return
    $elsif $func eq "else"
	return single_block("else{", "}");
    $elsif $func eq "for"
	$call c_parse_for
    $elsif $func eq "return_type"
	$cur_function->{ret_type}=$param;
    $elsif $func eq "parameter"
	my @plist=split /,\s*/, $param;
	my $fplist=$cur_function->{param_list};
	$foreach my $p in @plist
	    push @$fplist, $p;
	    $if $p=~/(.*)\s+(\w+)\s*$/
		$cur_function->{var_type}->{$2}=$1;
    $elsif $func eq "include"
	my @flist=split /,\s*/, $param;
	$foreach my $f in @flist
	    $if $f=~/\.\w+$/
		$includes{"\"$f\""}=1;
	    $elif $f=~/^".*"$/
		$includes{$f}=1;
	    $else
		$includes{"<$f.h>"}=1;
    $elsif $func eq "declare"
	$call @do_declare, $param
    $elsif $func eq "define"
	push @$out, "#define $param";
    $elsif $func eq "function"
	$call parse_function
    $elsif $func eq "function_end"
	# automatically generated from compileutil
	$call parse_function_end
    $elsif $func eq "list"
	$call parse_function_list
    $elsif $func eq "enum"
	my $name="ANONYMOUS-$anonymous_count"
	$anonymous_count++
	push @enum_list, $name;
	$enums{$name}=$param;
    $elsif $func eq "uselib"
	my @flist=split /,\s+/, $param;
	$foreach my $f in @flist
	    $objects{"lib$f"}=1;
	    $if $lib_include{$f}
		add_include($lib_include{$f});
    $elsif $func eq "fntype"
	# Similar to type_name, but for funtion pointer types
	$if $param=~/^.*?\(\s*\*\s*(\w+)\s*\)/
	    $fntype{$1}=$param;
    $elsif $func eq "debug_mem"
	push @$out, "debug_mem=1;";
	$misc_vars{"debug_mem"}=1;
    $elsif $func eq "typedef"
	add_typedef($param)
    $elsif $func eq "global" or $func eq "local" or $func eq "my" or $func eq "symbol"
	$call check_autoload_h
	$if $func eq "global" and $autoload_h
	    $func="symbol"

	my @vlist=split /,\s+/, $param;
	$foreach my $v in @vlist
	    $if $func eq "global"
		my $name=global_add_var($v)
		$call add_to_autoload_h, "global-$name"
	    $elif $func eq "symbol"
		global_add_symbol($v)
	    $elif $func eq "my" and !$page->{disable_scope}
		scope_add_var($v)
	    $else
		func_add_var($v, "local");
    $elsif $func eq "globalinit"
	global_add_var($param);
    $elsif $func eq "localinit"
	func_add_var($param, "local");
    $elsif $func eq "myinit"
	$if $page->{disable_scope}
	    func_add_var($param, "local");
	$else
	    scope_add_var($param)
    $elsif $func eq "dump"
	debug_dump($param, undef, $out);
    $elif $func eq "push"
	$if $param=~/(\w+),\s*(.*)/
	    list_push($out, $1, $2);
    $elif $func eq "unshift"
	$if $param=~/(\w+),\s*(.*)/
	    list_unshift($out, $1, $2);
    $elif $func eq "pop"
	$if $param=~/(\w+)/
	    list_pop($out, $1);
    $elif $func eq "shift"
	$if $param=~/(\w+)/
	    list_shift($out, $1);
    $elif $func eq "foreach"
	$if $param=~/(\w+)\s+in\s+(\w+)/
	    return list_foreach($out, $iv, $v)
    $elif $func eq "eval"
	$if $param=~/(\w+)(.*)/
	    $codename=$1
	    $param=$2
	    $param=~s/^\s*,\s*//
	    my $t=MyDef::compileutil::eval_sub($codename)
	    #print "eval [$t]\n\n"
	    eval $t
	    $if $@
		print "Error [$l]: $@\n"
	$should_return=1
    $else
	$should_return=0
	$foreach $funcname in keys %plugin_statement
	    $if $func eq $funcname
		my $codename=$plugin_statement{$funcname}
		my $t=MyDef::compileutil::eval_sub($codename)
		eval $t
		$should_return=1
		last

subcode: parsecode_other
    #print "parsecode residue: [$l]\n";
    $if $l=~/^return\b/
	func_return($l, $out);
    $elsif $l=~/^SOURCE_INDENT/
	$cur_indent++;
    $elsif $l=~/^SOURCE_DEDENT/
	$cur_indent--;

    $call check_exponential
    $call check_functioncall
    $call check_termination

    $if $l=~/^[^'"]*=/
	check_assignment(\$l, $out);
    $if $l
	push @$out, $l;

# ----------------------------------------------
subcode: c_parse_for
    $if $param=~/(\w+)\s*=\s*(.*?):(.*?)(:.*)?$/
	my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
	func_add_var($var, undef, $i0);
	my $stepclause;
	$if $step
	    my $t=substr($step, 1);
	    $if $t eq "-1"
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $elsif $t=~/^-/
		$stepclause="$var=$i0;$var>$i1;$var=$var$t";
	    $elsif $t eq "1"
		$stepclause="$var=$i0;$var<$i1;$var++";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var+=$t";
	$else
	    $if $i1=~/^-?\d+/ and $i0=~/^-?\d+/ and $i1<$i0
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var++";
	return single_block("for($stepclause){", "}");
    $else
	return single_block("for($param){", "}")


subcode:: c_support_subs
    $sub parse_condition($param)
	$if $param=~/^\$(\w+)\s+(.*)/
	    $foreach $funcname in keys %plugin_condition
		$if $1 eq $funcname
		    my $param=$2
		    my $codename=$plugin_condition{$funcname}
		    my $condition
		    my $t=MyDef::compileutil::eval_sub($codename)
		    eval $t
		    return $condition
	$while $param =~ /(\S+)\s+eq\s+"(.*?)"/
	    my ($var, $key)=($1, $2);
	    my $keylen=length($key);
	    $param=$`."strncmp($var, \"$key\", $keylen)==0".$';

	$if $param=~/(\w+)->\{(.*)\}/
	    my $t="\$"."(macro_hash_cond:$1,$2)"
	    MyDef::compileutil::expand_macro_recurse(\$t)
	    return $t
	$elsif $param!~/^\(.*\)$/ and $param=~/[^!><=]=[^=]/
	    print "Assignment in [$param], possible bug?\n"
	    return $param
	$else
	    return $param;

# ----------------------------------------------
subcode: parse_function
    $call check_autoload_h
    $if !$autoload_h and $param=~/(\w+)(.*)/
	my ($fname, $paramline)=($1, $2)
	$if $paramline=~/\((.*)\)/
	    $paramline=$1
	$elif $paramline=~/^\s*,\s*(.*)/
	    $paramline=$1
	my $fidx=open_function($fname, $paramline)
	push @$out, "OPEN_FUNC_$fidx";
	push @$out, "SOURCE_INDENT";
	push @$out, "BLOCK";
	push @$out, "SOURCE_DEDENT";
	$call add_to_autoload_h, "function-$fname"
	return "NEWBLOCK-$function_end";
    $else
	return "SKIPBLOCK"

subcode: parse_function_end
    $cur_function=pop @function_stack

subcode: parse_function_list
    $call check_autoload_h
    $if !$autoload_h
	my @tlist=split /,\s*/, $param
	$foreach $f in @tlist
	    $call parse_function_list_item, $f
	    $call add_to_autoload_h, "function-$f"

subcode: parse_function_list_item(f)
    my $funcname=$(f)
    my $codename=$(f)
    $if $f=~/(\w+)\((\w+)\)/
	$codename=$1
	$funcname=$2
    $funcname=~s/^@//
    my $params=MyDef::compileutil::get_sub_param_list($codename)
    my $paramline=join(",", @$params)
    $if $funcname eq "n_main" or $funcname eq "main2"
	$funcname="main";
    my $fidx=open_function($funcname, $paramline);
    push @$out, "OPEN_FUNC_$fidx";
    $cur_indent=1
    push @$out, "SOURCE_INDENT"
    MyDef::compileutil::call_sub($codename, "\$list")
    push @$out, "SOURCE_DEDENT"
    $cur_function=pop @function_stack

# ---------------------------------------------------
subcode:: support_subs
    $sub data_pack($param)
	$call datapack, pack

    $sub data_unpack($param)
	$call datapack, unpack

subcode: datapack(dir)
    my @t=split /,\s*/, $param
    my $buf=shift @t
    my $fmt=shift @t
    $if !$buf
	warn " datapack ($(dir)): buf empty: $param\n"
    my @vlist=@t
    $if $fmt=~/"(.*)"/
	$fmt=$1
    my $fmt_pos=0
    my $buf_pos=0
    my $fmt_len=length($fmt)
    my $last_var
    $while $fmt_pos<$fmt_len
	my $var=shift @vlist
	my $vartype=get_var_type($var)
	my $c=substr($fmt, $fmt_pos, 1)
	$if $c eq "s"
	    $(if:dir=pack)
		$call datapack_pointer
	    $(else)
		$call dataunpack_pointer
	$elif $c=~/\d/
	    $(if:dir=pack)
		$call datapack_var
	    $(else)
		$call dataunpack_var
	    $buf_pos+=$c
	$fmt_pos++
	$last_var=$var

subcode: datapack_pointer
    push @$out, "memcpy($buf+$buf_pos, (const void *)$var, $last_var);"

subcode: dataunpack_pointer
    push @$out, "$var=($vartype)($buf+$buf_pos);"

subcode: datapack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "*((char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((int *)($buf+$buf_pos))=$var;"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "*((unsigned char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((unsigned short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((unsigned int *)($buf+$buf_pos))=$var;"
    $else
	print "pack: unhandled type $var - $vartype\n"

subcode: dataunpack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "$var=*((char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((int *)($buf+$buf_pos));"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "$var=*((unsigned char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((unsigned short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((unsigned int *)($buf+$buf_pos));"
    $else
	print "unpack: unhandled type $var - $vartype\n"


