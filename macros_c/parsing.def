include: macros_c/parsing_short.def
subcode: c_parsecode
    my $should_return=1
    $if $l=~/^FUNC (\w+)-(.*)/
	my $fname=$1;
	my $t=$2;
	$if $fname eq "n_main"
	    $fname="main";
	my $fidx=open_function($fname, $t);
	push @$out, "OPEN_FUNC_$fidx";
	$cur_indent=0;
	return
    $elif $l=~/^FUNC END/
	$cur_function=pop @function_stack
    $elif $l=~/^\s*PRINT\s+(.*)$/
	$call fmt_print
    $elif $l=~/^\s*\$(\w+)\((.*)\)\s+(.*)$/
	# $function(param1) param2 ---------------------------
	my ($func, $param1, $param2)=($1, $2, $3)
	$call parsecode_func_param
    $elif $l=~/^\s*\$(\w+)\s*(.*)$/
	# $function param  -----------------------------------
	my ($func, $param)=($1, $2)
	$call parsecode_func
    $else
	$should_return=0
    $if $should_return
	return
    $call @custom_parse
    $call parsecode_other

subcode: parsecode_func_param
    $if $func eq "allocate"
	allocate($out, $param1, $param2);
    $elsif $func eq "dump"
	debug_dump($param2, $param1, $out);
    $elsif $func eq "register_prefix"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_prefix{$param1}=$param2;
    $elsif $func eq "register_name"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_name{$param1}=$param2;
    $elsif $func eq "register_include"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_include{$param1}.=",$param2";
    $elsif $func eq "struct"
	declare_struct($param1, $param2);
	$type_prefix{"st$param1"}="struct $param1";
    $elsif $func eq "get_type"
	my $type=get_var_type($param2);
	return "SET:$param1=$type";
    $elsif $func eq "get_pointer_type"
	my $type=pointer_type(get_var_type($param2));
	return "SET:$param1=$type";
    $elsif $func eq "enum"
	$if !$enums{$param1}
	    push @enum_list, $param1;
	    $enums{$param1}=$param2;
    $elsif $func eq "enumbit"
	my $base=0;
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    $defines{"$param1\_$t"}=0x1<<$base;
	    $base++;
    $else
	$should_return=0

subcode: parsecode_func
    ## Pre-Process condition clause
    while($param =~ /(\S+)\s+eq\s+"(.*?)"/){
	my ($var, $key)=($1, $2);
	my $keylen=length($key);
	$param=$`."strncmp($var, \"$key\", $keylen)==0".$';
    }
    ## All the functions
    $if $func eq "block"
	return single_block("$param\{", "}")
    $elsif $func eq "allocate"
	allocate($out, 1, $param);
    $elsif $func =~/^except/
	return single_block("$except\{", "}")
    $elsif $func =~ /^(if|while|switch|(el|els|else)if)$/
	my $name=$1;
	$if $2
	    $name="else if";
	my $p=parse_condition($param, $out);
	return single_block("$name($p){", "}")
    $elsif $func =~/^dowhile/
	my $p=parse_condition($param, $out);
	return single_block("do{", "}while($p);")
    $elsif $func eq "else"
	return single_block("else{", "}");
    $elsif $func eq "for"
	$call c_parse_for
    $elsif $func eq "function"
	$if $param=~/(\w+)\s*\((.*)\)/
	    my $fidx=open_function($1, $2);
	    push @$out, "OPEN_FUNC_$fidx";
	    push @$out, "SOURCE_INDENT";
	    push @$out, "BLOCK";
	    push @$out, "SOURCE_DEDENT";
	    return "NEWBLOCK-FUNC END";
    $elsif $func eq "return_type"
	$cur_function->{ret_type}=$param;
    $elsif $func eq "parameter"
	my @plist=split /,\s*/, $param;
	my $fplist=$cur_function->{param_list};
	$foreach my $p in @plist
	    push @$fplist, $p;
	    $if $p=~/(.*)\s+(\w+)\s*$/
		$cur_function->{var_type}->{$2}=$1;
    $elsif $func eq "mu_skip"
	my @plist=split /,\s*/, $param;
	$foreach my $p in @plist
	    $cur_function->{mu_skip}->{$p}=1;
    $elsif $func eq "mu_enable"
	mu_enable();
    $elsif $func eq "include"
	my @flist=split /,\s+/, $param;
	$foreach my $f in @flist
	    $if $f=~/\.h$/
		$includes{"\"$f\""}=1;
	    $else
		$includes{"<$f.h>"}=1;
    $elsif $func eq "declare"
	push @declare_list, $param
    $elsif $func eq "define"
	push @$out, "#define $param";
    $elsif $func eq "uselib"
	my @flist=split /,\s+/, $param;
	$foreach my $f in @flist
	    $includes{"lib$f"}=1;
	    $if $lib_include{$f}
		add_include($lib_include{$f});
    $elsif $func eq "fntype"
	# Similar to type_name, but for funtion pointer types
	$if $param=~/^.*?\(\s*\*\s*(\w+)\s*\)/
	    $fntype{$1}=$param;
    $elsif $func eq "debug_mem"
	push @$out, "debug_mem=1;";
	$misc_vars{"debug_mem"}=1;
    $elsif $func eq "namespace"
	my @vlist=split /,\s+/, $param;
	$foreach my $v in @vlist
	    global_namespace($v);
    $elsif $func eq "global"
	my @vlist=split /,\s+/, $param;
	$foreach my $v in @vlist
	    global_add_var($v)
    $elsif $func eq "globalinit"
	# just to allow , in initline
	global_add_var($param);
    $elsif $func eq "local"
	my @vlist=split /,\s+/, $param;
	$foreach my $v in @vlist
	    func_add_var($v, "local");
    $elsif $func eq "localinit"
	func_add_var($param, "local");
    $elsif $func eq "new"
	my @plist=split /,\s+/, $param;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		my $type=pointer_type(get_var_type($p));
		$includes{"<stdlib.h>"}=1;
		push @$out, "$p=($type*) malloc(sizeof($type));";
    $elsif $func eq "free"
	my @plist=split /,\s+/, $param;
	$foreach my $p in @plist
	    my $ptype=get_var_type($p);
	    struct_free($out, $ptype, $p);
    $elsif $func eq "dump"
	debug_dump($param, undef, $out);
    $elsif $func eq "getopt"
	my @vlist=split /,\s+/, $param;
	$call c_parse_getopt
    $elsif $func eq "getbits"
	$call c_parse_getbits

    $elif $func eq "push"
	$if $param=~/(\w+),\s*(.*)/
	    list_push($out, $1, $2);
    $elif $func eq "unshift"
	$if $param=~/(\w+),\s*(.*)/
	    list_unshift($out, $1, $2);
    $elif $func eq "pop"
	$if $param=~/(\w+)/
	    list_pop($out, $1);
    $elif $func eq "shift"
	$if $param=~/(\w+)/
	    list_shift($out, $1);
    $elif $func eq "foreach"
	$if $param=~/(\w+)\s+in\s+(\w+)/
	    return list_foreach($out, $iv, $v)
    $else
	$should_return=0

subcode: parsecode_other
    #print "parsecode residue: [$l]\n";
    $if $l=~/^return\b/
	func_return($l, $out);
    $elsif $l=~/^SOURCE_INDENT/
	$cur_indent++;
    $elsif $l=~/^SOURCE_DEDENT/
	$cur_indent--;

    $call check_exponential
    $call check_functioncall
    $call check_termination

    $if $l=~/^[^'"]*=/
	$if $l=~/^(\w+)->\{(.*)\}\s*=\s*(.+)/
	    $l=hash_assign($out, $1, $2, $3);
	$elsif $l=~/^(\w+)\s*=\s*(\w+)->\{(.*)\}/
	    $l=hash_fetch($out, $2, $3, $1);
	$elsif $l=~/^(\w+)\s*=\s*(shift|pop)\s+(\w+)/
	    $if $2 eq "shift"
		$l=array_shift($out, $3, $1);
	    $elif $2 eq "pop"
		$l=array_pop($out, $3, $1);
	check_assignment(\$l, $out);
    $if $l
	push @$out, $l;

# ----------------------------------------------
subcode: c_parse_for
    $if $param=~/(\w+)=(.*?):(.*?)(:.*)?$/
	my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
	func_add_var($var, undef, $i0);
	my $stepclause;
	$if $step
	    my $t=substr($step, 1);
	    $if $t eq "-1"
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $elsif $t=~/^-/
		$stepclause="$var=$i0;$var>$i1;$var=$var$t";
	    $elsif $t eq "1"
		$stepclause="$var=$i0;$var<$i1;$var++";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var+=$t";
	$else
	    $if $i1=~/^-?\d+/ and $i0=~/^-?\d+/ and $i1<$i0
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var++";
	return single_block("for($stepclause){", "}");
    $else
	print "\$for mismatch [$param]\n";

subcode: c_parse_getopt
    $includes{"<stdlib.h>"}=1;
    $includes{"<unistd.h>"}=1;
    my $cstr='';
    $foreach my $v in @vlist
	$if $v=~/(\w+):(\w+)(=.*)?/
	    func_add_var($1);
	    $if substr($1, 0, 2) eq "b_"
		$cstr.=$2;
		push @$out, "$1=0;";
	    $elsif $3
		push @$out, "$1$3;";
		$cstr.="$2::";
	    $else
		$cstr.="$2:";
    push @$out, "opterr = 1;";
    func_add_var("c", "char");
    push @$out, "while ((c=getopt(argc, argv, \"$cstr\"))!=-1){";
    push @$out, "    switch(c){";
    $foreach my $v in @vlist
	$if $v=~/(\w+):(\w+)/
	    push @$out, "        case '$2':";
	    my $type=get_var_type($1);
	    $if substr($1, 0, 2) eq "b_"
		push @$out, "            $1=1;";
	    $elsif $type eq "char *"
		push @$out, "            $1=optarg;";
	    $elsif $type eq "int" or $type eq "long"
		push @$out, "            $1=atoi(optarg);";
	    $elsif $type eq "float" or $type eq "double"
		push @$out, "            $1=atof(optarg);";
	push @$out, "            break;";
    push @$out, "    }";
    push @$out, "}";

subcode: c_parse_getbits
    use integer
    my ($var, $buf, $pos, $bits)=split /,\s+/, $param
    func_add_var($var)
    my ($bufvar, $bufpos)=($buf,0)
    $if $buf=~/(.*)\[(.*)\]/
	$bufvar=$1
	$bufpos=$2
    my @tlist
    my $byte_off=$pos / 8
    my $bits_off=$pos % 8
    $while $bits>0
	my $t=$bufvar
	$if $bufpos and $byte_off>0
	    $t.="[$bufpos+$byte_off]"
	$elif $bufpos
	    $t.="[$bufpos]"
	$else
	    $t.="[$byte_off]"
	$if $bits>8
	    $t="(unsigned int)$t"
	$if $bits_off
	    my $mask=sprintf "0x%02x", 0xff>>$bits_off
	    $t="($t & $mask)"
	$if $bits>8-$bits_off
	    $bits-=8-$bits_off
	    $t="($t<<$bits)"
	$elif $bits<8-$bits_off
	    $bits=8-$bits_off-$bits
	    $t="($t>>$bits)"
	    $bits=0
	$else
	    $bits=0
	push @tlist, $t
	$bits_off=0
	$byte_off++
    push @$out, "$var = ".join("|", @tlist).";"
