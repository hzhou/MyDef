include: macros_c/allocate.def
include: macros_c/for.def
include: macros_c/expression.def
include: macros_c/print.def

subcode:: package_globals
    our $anonymous_count=0

    our $print_type=1

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $call add_include, $v

subcode: parsecode_special
    $if $l=~/^SUBBLOCK BEGIN (\d+) (.*)/
	my ($blk, $scope)=($1, $2)
	push @$out, "DUMP_STUB SUBBLOCK_$blk"
	open_scope("SUBBLOCK_$blk", $scope)
	return
    $elif $l=~/^SUBBLOCK END (\d+) (.*)/
	my ($blk, $scope)=($1, $2)
	close_scope("SUBBLOCK_$blk")
	return
    $elif $l=~/^NOOP POST_MAIN/
	$call parsecode_post
	return
    $elif $l=~/^print\b(.*)$/i
	print "print deprecated, use \$print\n"

subcode: parsecode_func_param
    $if $func eq "dump"
	debug_dump($param2, $param1, $out);
	return
    $elsif $func eq "register_prefix"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_prefix{$param1}=$param2;
	return
    $elsif $func eq "register_name"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_name{$param1}=$param2;
	return
    $elsif $func eq "register_include"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$if $type_include{$param1}
	    $type_include{$param1}.=",$param2";
	$else
	    $type_include{$param1}.="$param2";
	return
    $elif $func eq "get_type"
	my $type=get_var_type($param2);
	MyDef::compileutil::set_current_macro($param1, $type)
	return 
    $elif $func eq "get_pointer_type"
	my $type=pointer_type(get_var_type($param2));
	MyDef::compileutil::set_current_macro($param1, $type)
	return
    $elif $func eq "get_struct_var_prefix"
	my $type=get_var_type($param2)
	$if $type=~/struct (\w+)\s*\*/
	    MyDef::compileutil::set_current_macro($param1, "$param2->")
	$elif $type=~/struct (\w+)/
	    MyDef::compileutil::set_current_macro($param1, "$param2.")
	$else
	    die "get_var_type: $param2 returns type $type\n"
	return
    $elsif $func eq "define"
	add_define($param1, $param2)
	return
    $elsif $func eq "enum"
	$if !$enums{$param1}
	    push @enum_list, $param1;
	    $enums{$param1}=$param2;
	    $if $param1=~/^,\s*(\w+)/
		global_add_symbol("int $1")
	return
    $elsif $func eq "enumbase"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t", $base)
	    $base++;
	return
    $elsif $func eq "enumbit"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t",0x1<<$base)
	    $base++;
	return
    $elif $func eq "write_h"
	$call write_h, $param1, $param2
	return
    $call @parsecode_func_param_other

subcode: parsecode_func
    ## All the functions
    $if $func eq "block"
	return single_block("$param\{", "}", "block")
    $elif $func =~/^except/
	return single_block("$except\{", "}", "else")
    $elif $func =~ /^(while|switch)$/
	my $name=$1;
	$param=parse_condition($param)
	return single_block("$name($param){", "}")
    $elsif $func =~/^dowhile/
	$param=parse_condition($param)
	return single_block("do{", "}while($param);")
    #---------------------------------------- 
    $elif $func eq "pack"
	data_pack($param)
	return
    $elif $func eq "unpack"
	data_unpack($param)
	return
    $elsif $func eq "include"
	$call add_include, $param
	return
    $elsif $func eq "declare"
	$call @do_declare, $param
	return
    $elsif $func eq "define"
	push @$out, "#define $param";
	return
    $elsif $func eq "enum"
	my $name="ANONYMOUS-$anonymous_count"
	$anonymous_count++
	push @enum_list, $name;
	$enums{$name}=$param;
	return
    $elsif $func eq "uselib"
	my @flist=split /,\s+/, $param;
	$foreach my $f in @flist
	    $objects{"lib$f"}=1;
	    $if $lib_include{$f}
		$call add_include, $lib_include{$f}
	return
    $elsif $func eq "fntype"
	# Similar to type_name, but for funtion pointer types
	$if $param=~/^.*?\(\s*\*\s*(\w+)\s*\)/
	    $fntype{$1}=$param;
	return
    $elsif $func eq "debug_mem"
	push @$out, "debug_mem=1;";
	$misc_vars{"debug_mem"}=1;
	return
    $elsif $func eq "typedef"
	add_typedef($param)
	return
    $elsif $func eq "dump"
	debug_dump($param, undef, $out);
	return
    $call @parsecode_func_other

subcode: parsecode_other
    $if $l=~/^return\b/
	func_return($l, $out);
    $elsif $l=~/^SOURCE_INDENT/
	$cur_indent++;
    $elsif $l=~/^SOURCE_DEDENT/
	$cur_indent--;

    #$call check_text_includes
    #$call check_exponential
    #$call check_assignment

    $call check_functioncall
    $l=check_expression($l)
    $if $l
	$call check_termination
    $else
	return

# ----------------------------------------------
# ---- called from output.def -----------------
subcode:: c_support_subs
    $sub parse_condition($param)
	$if $param=~/(\$map\b.*)/
	    my $pre=$`
	    $param=$1
	    $call parse_condition_map
	$elif $param=~/^\$(\w+)\s+(.*)/
	    my ($func, $param)=($1, $2)
	    $call parse_condition_check_plugin

	$while $param =~ /(\S+)\s+eq\s+"(.*?)"/
	    my ($var, $key)=($1, $2);
	    my $keylen=length($key);
	    $param=$`."strncmp($var, \"$key\", $keylen)==0".$';

	$if $param=~/(\w+)->\{(.*)\}/
	    my $t="\$"."(macro_hash_cond:$1,$2)"
	    MyDef::compileutil::expand_macro_recurse(\$t)
	    return $t
	$elif $param=~/^\w+\s*=\s*\w+\(.*\)\s*$/
	    # if $var=fcall_get_var()
	    return $param
	$elif $param!~/^\(.*\)$/ and $param=~/[^!><='"]=[^=]/
	    my $pre=$`
	    $if $pre!~/['"]/
		# ... unless left is quoted
		print "Assignment in [$param], possible bug? pre:[$pre]\n"
	    return $param
	$else
	    return $param;

# ---------------------------------------------------
subcode:: support_subs
    $sub data_pack($param)
	$call datapack, pack

    $sub data_unpack($param)
	$call datapack, unpack

subcode: datapack(dir)
    my @t=split /,\s*/, $param
    my $buf=shift @t
    my $fmt=shift @t
    $if !$buf
	warn " datapack ($(dir)): buf empty: $param\n"
    my @vlist=@t
    $if $fmt=~/"(.*)"/
	$fmt=$1
    my $fmt_pos=0
    my $buf_pos=0
    my $fmt_len=length($fmt)
    my $last_var
    $while $fmt_pos<$fmt_len
	my $var=shift @vlist
	my $vartype=get_var_type($var)
	my $c=substr($fmt, $fmt_pos, 1)
	$if $c eq "s"
	    $(if:dir=pack)
		$call datapack_pointer
	    $(else)
		$call dataunpack_pointer
	$elif $c=~/\d/
	    $(if:dir=pack)
		$call datapack_var
	    $(else)
		$call dataunpack_var
	    $buf_pos+=$c
	$fmt_pos++
	$last_var=$var

subcode: datapack_pointer
    push @$out, "memcpy($buf+$buf_pos, (const void *)$var, $last_var);"

subcode: dataunpack_pointer
    push @$out, "$var=($vartype)($buf+$buf_pos);"

subcode: datapack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "*((char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((int *)($buf+$buf_pos))=$var;"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "*((unsigned char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((unsigned short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((unsigned int *)($buf+$buf_pos))=$var;"
    $else
	print "pack: unhandled type $var - $vartype\n"

subcode: dataunpack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "$var=*((char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((int *)($buf+$buf_pos));"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "$var=*((unsigned char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((unsigned short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((unsigned int *)($buf+$buf_pos));"
    $else
	print "unpack: unhandled type $var - $vartype\n"


