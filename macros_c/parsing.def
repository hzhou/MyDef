subcode:: package_globals
    our $anonymous_count=0

    our $print_type=1

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $call add_include, $v

subcode: parsecode_special
    $if $l=~/^SUBBLOCK BEGIN (\d+)/
	push @$out, "DUMP_STUB SUBBLOCK_$1"
	$if $debug eq "DUMP"
	    my ($code, $file, $line)=MyDef::compileutil::get_cur_code()
	    push @$out, "printf(\"subcode: $file - $line - $code->{name}\\n\");";
	open_scope("SUBBLOCK_$1")
	return
    $elif $l=~/^SUBBLOCK END (\d+)/
	close_scope("SUBBLOCK_$1")
	return
    $elif $l=~/^NOOP POST_MAIN/
	$call parsecode_post
	return
    $elif $l=~/^\s*print\s+(.*)$/i
	my $t=$1
	$if $t=~/usesub:\s*(\w+)/
	    $print_type=$1
	$else
	    my $fmt=$t
	    $if $t!~/^".*"/
		my $n
		($n, $fmt)=fmt_string($t)
	    $if $fmt=~/^"(.*?[^\\])"(.*)/
		my ($t1, $t2)=($1, $2)
		$if $t1!~/\\n$/
		    $fmt="\"$t1\\n\"$t2"
	    $if $print_type==1
		push @$out, "printf($fmt);"
	    $elif $print_type
		MyDef::compileutil::call_sub("$print_type, $fmt")
	return

subcode: parsecode_func_param
    $if $func eq "allocate"
	allocate($param1, $param2);
	return
    $elif $func eq "local_allocate"
	local_allocate($param1, $param2);
	return
    $elif $func eq "global_allocate"
	# at main_exit: DUMP_STUB global_cleanup
	global_allocate($param1, $param2);
	return
    $elsif $func eq "dump"
	debug_dump($param2, $param1, $out);
	return
    $elsif $func eq "register_prefix"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_prefix{$param1}=$param2;
	return
    $elsif $func eq "register_name"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_name{$param1}=$param2;
	return
    $elsif $func eq "register_include"
	$param2=~s/^\s+//;
	$param2=~s/\s+$//;
	$type_include{$param1}.=",$param2";
	return
    $elif $func eq "get_type"
	my $type=get_var_type($param2);
	MyDef::compileutil::set_current_macro($param1, $type)
	return 
    $elif $func eq "get_pointer_type"
	my $type=pointer_type(get_var_type($param2));
	MyDef::compileutil::set_current_macro($param1, $type)
	return
    $elif $func eq "get_struct_var_prefix"
	my $type=get_var_type($param2)
	$if $type=~/struct (\w+)\s*\*/
	    MyDef::compileutil::set_current_macro($param1, "$param2->")
	$elif $type=~/struct (\w+)/
	    MyDef::compileutil::set_current_macro($param1, "$param2.")
	$else
	    die "get_var_type: $param2 returns type $type\n"
	return
    $elsif $func eq "struct"
	declare_struct($param1, $param2);
	return
    $elsif $func eq "define"
	add_define($param1, $param2)
	return
    $elsif $func eq "enum"
	$if !$enums{$param1}
	    push @enum_list, $param1;
	    $enums{$param1}=$param2;
	    $if $param1=~/^,\s*(\w+)/
		global_add_symbol("int $1")
	return
    $elsif $func eq "enumbase"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t", $base)
	    $base++;
	return
    $elsif $func eq "enumbit"
	my $base=0;
	$if $param1=~/(\w*),\s*(\d+)/
	    $param1=$1
	    $base=$2
	$if $param1
	    $param1.="_"
	my @plist=split /,\s+/, $param2;
	$foreach my $t in @plist
	    add_define("$param1$t",0x1<<$base)
	    $base++;
	return
    $elif $func eq "write_h"
	$call write_h, $param1, $param2
	return

subcode: parsecode_func
    ## All the functions
    $if $func eq "block"
	return single_block("$param\{", "}")
    $elif $func eq "allocate"
	allocate(1, $param);
	return
    $elif $func eq "pack"
	data_pack($param)
	return
    $elif $func eq "unpack"
	data_unpack($param)
	return
    $elif $func =~/^except/
	return single_block("$except\{", "}")
    $elif $func =~ /^(while|switch)$/
	my $name=$1;
	$param=parse_condition($param)
	return single_block("$name($param){", "}")
    $elsif $func =~/^dowhile/
	$param=parse_condition($param)
	return single_block("do{", "}while($param);")
    $elsif $func =~/^whiletrue/
	push @$out, "while($param);"
	return
    $elsif $func eq "for"
	$call c_parse_for
	return
    $elif $func eq "endfor"
	$call c_parse_for_end
    $elsif $func eq "return_type"
	$cur_function->{ret_type}=$param;
	return
    $elsif $func eq "parameter"
	my $param_list=$cur_function->{param_list}
	my $var_type=$cur_function->{var_type}
	$call open_function_params
	return
    $elsif $func eq "include"
	$call add_include, $param
	return
    $elsif $func eq "declare"
	$call @do_declare, $param
	return
    $elsif $func eq "define"
	push @$out, "#define $param";
	return
    $elsif $func eq "enum"
	my $name="ANONYMOUS-$anonymous_count"
	$anonymous_count++
	push @enum_list, $name;
	$enums{$name}=$param;
	return
    $elsif $func eq "uselib"
	my @flist=split /,\s+/, $param;
	$foreach my $f in @flist
	    $objects{"lib$f"}=1;
	    $if $lib_include{$f}
		$call add_include, $lib_include{$f}
	return
    $elsif $func eq "fntype"
	# Similar to type_name, but for funtion pointer types
	$if $param=~/^.*?\(\s*\*\s*(\w+)\s*\)/
	    $fntype{$1}=$param;
	return
    $elsif $func eq "debug_mem"
	push @$out, "debug_mem=1;";
	$misc_vars{"debug_mem"}=1;
	return
    $elsif $func eq "typedef"
	add_typedef($param)
	return
    $elsif $func eq "global" or $func eq "local" or $func eq "my" or $func eq "symbol" or $func eq "auto_global"
	$if $func eq "auto_global"
	    $call check_autoload_h_direct
	    $func eq "global"
	$else
	    $call check_autoload_h
	$if $func eq "global" and $autoload_h
	    $func="symbol"

	$param=~s/\s*;\s*$//
	my @vlist=split /,\s+/, $param;
	$foreach $v in @vlist
	    $if $func eq "global"
		my $name=global_add_var($v)
		$call add_to_autoload_h, "global-$name"
	    $elif $func eq "symbol"
		global_add_symbol($v)
	    $elif $func eq "my" and !$page->{disable_scope}
		scope_add_var($v)
	    $else
		func_add_var($v, "local");
	return
    $elsif $func eq "globalinit"
	global_add_var($param);
	return
    $elsif $func eq "localinit"
	func_add_var($param, "local");
	return
    $elsif $func eq "myinit"
	$if $page->{disable_scope}
	    func_add_var($param, "local");
	$else
	    scope_add_var($param)
	return
    $elsif $func eq "dump"
	debug_dump($param, undef, $out);
	return
    $elif $func eq "push"
	$if $param=~/(\w+),\s*(.*)/
	    list_push($out, $1, $2);
	return
    $elif $func eq "unshift"
	$if $param=~/(\w+),\s*(.*)/
	    list_unshift($out, $1, $2);
	return
    $elif $func eq "pop"
	$if $param=~/(\w+)/
	    list_pop($out, $1);
	return
    $elif $func eq "shift"
	$if $param=~/(\w+)/
	    list_shift($out, $1);
	return
    $elif $func eq "foreach"
	$if $param=~/(\w+)\s+in\s+(\w+)/
	    my ($iv, $v)=($1, $2)
	    return list_foreach($out, $iv, $v)
    $call @parsecode_func_other

subcode: parsecode_other
    $if $l=~/^return\b/
	func_return($l, $out);
    $elsif $l=~/^SOURCE_INDENT/
	$cur_indent++;
    $elsif $l=~/^SOURCE_DEDENT/
	$cur_indent--;

    $call check_text_includes
    $call check_exponential
    $call check_functioncall
    $call check_termination

    $if $l=~/^[^'"]*=/
	$call check_assignment

# ----------------------------------------------
subcode: c_parse_for
    $global %protected_var
    $if $param=~/(\w+)\s*=\s*(.*?):(.*?)(:.*)?$/
	my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
	$if $protected_var{$var}
	    my $curfile=MyDef::compileutil::curfile_curline()
	    print "[$curfile] Duplicate for variable $var\n"
	    $protected_var{$var}++
	$else
	    $protected_var{$var}=1
	func_add_var($var, undef, $i0);
	my $stepclause;
	$if $step
	    my $t=substr($step, 1);
	    $if $t eq "-1"
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $elsif $t=~/^-/
		$stepclause="$var=$i0;$var>$i1;$var=$var$t";
	    $elsif $t eq "1"
		$stepclause="$var=$i0;$var<$i1;$var++";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var+=$t";
	$else
	    # CAUTION
	    # I would like to have $i=n:0 be the reverse of $i=0:n
	    # Infact I would to symmetry between $i=$a:$b:$step and $i=$b:$a:-$step, TO BE DONE
	    $if $i1 eq "0"
		$stepclause="$var=$i0-1;$var>=0;$var--";
	    $elif $i1=~/^-?\d+/ and $i0=~/^-?\d+/ and $i1<$i0
		$stepclause="$var=$i0;$var>$i1;$var--";
	    $else
		$stepclause="$var=$i0;$var<$i1;$var++";
	my $end="PARSE:\$endfor $var"
	return single_block_pre_post(["for($stepclause){", "INDENT"], ["DEDENT", "}",$end])
    $else
	return single_block("for($param){", "}")

subcode: c_parse_for_end
    $protected_var{$param}--
    return

# ---- called from output.def -----------------
subcode:: c_support_subs
    $sub parse_condition($param)
	$if $param=~/(\$map\b.*)/
	    my $pre=$`
	    $param=$1
	    $call parse_condition_map
	$elif $param=~/^\$(\w+)\s+(.*)/
	    my ($func, $param)=($1, $2)
	    $call parse_condition_check_plugin

	$while $param =~ /(\S+)\s+eq\s+"(.*?)"/
	    my ($var, $key)=($1, $2);
	    my $keylen=length($key);
	    $param=$`."strncmp($var, \"$key\", $keylen)==0".$';

	$if $param=~/(\w+)->\{(.*)\}/
	    my $t="\$"."(macro_hash_cond:$1,$2)"
	    MyDef::compileutil::expand_macro_recurse(\$t)
	    return $t
	$elif $param=~/^\w+\s*=\s*\w+\(.*\)\s*$/
	    # if $var=fcall_get_var()
	    return $param
	$elif $param!~/^\(.*\)$/ and $param=~/[^!><='"]=[^=]/
	    my $pre=$`
	    $if $pre!~/['"]/
		# ... unless left is quoted
		print "Assignment in [$param], possible bug? pre:[$pre]\n"
	    return $param
	$else
	    return $param;

# ---------------------------------------------------
subcode:: support_subs
    $sub data_pack($param)
	$call datapack, pack

    $sub data_unpack($param)
	$call datapack, unpack

subcode: datapack(dir)
    my @t=split /,\s*/, $param
    my $buf=shift @t
    my $fmt=shift @t
    $if !$buf
	warn " datapack ($(dir)): buf empty: $param\n"
    my @vlist=@t
    $if $fmt=~/"(.*)"/
	$fmt=$1
    my $fmt_pos=0
    my $buf_pos=0
    my $fmt_len=length($fmt)
    my $last_var
    $while $fmt_pos<$fmt_len
	my $var=shift @vlist
	my $vartype=get_var_type($var)
	my $c=substr($fmt, $fmt_pos, 1)
	$if $c eq "s"
	    $(if:dir=pack)
		$call datapack_pointer
	    $(else)
		$call dataunpack_pointer
	$elif $c=~/\d/
	    $(if:dir=pack)
		$call datapack_var
	    $(else)
		$call dataunpack_var
	    $buf_pos+=$c
	$fmt_pos++
	$last_var=$var

subcode: datapack_pointer
    push @$out, "memcpy($buf+$buf_pos, (const void *)$var, $last_var);"

subcode: dataunpack_pointer
    push @$out, "$var=($vartype)($buf+$buf_pos);"

subcode: datapack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "*((char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((int *)($buf+$buf_pos))=$var;"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "*((unsigned char *)($buf+$buf_pos))=$var;"
	$elif $c==2
	    push @$out, "*((unsigned short *)($buf+$buf_pos))=$var;"
	$elif $c==4
	    push @$out, "*((unsigned int *)($buf+$buf_pos))=$var;"
    $else
	print "pack: unhandled type $var - $vartype\n"

subcode: dataunpack_var
    $if $vartype=~/int/
	$if $c==1
	    push @$out, "$var=*((char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((int *)($buf+$buf_pos));"
    $elif $vartype=~/unsigned/
	$if $c==1
	    push @$out, "$var=*((unsigned char *)($buf+$buf_pos));"
	$elif $c==2
	    push @$out, "$var=*((unsigned short *)($buf+$buf_pos));"
	$elif $c==4
	    push @$out, "$var=*((unsigned int *)($buf+$buf_pos));"
    $else
	print "unpack: unhandled type $var - $vartype\n"


