include: macros_c/parsing.def
include: macros_c/last_checks.def
include: macros_c/structure.def
include: macros_c/functions.def
include: macros_c/hash_and_list.def
include: macros_c/types.def
include: macros_c/dump.def
include: macros_c/regex.def

subcode: c_main
    use MyDef::dumpout;

    my $cur_indent;

    my $debug;
    $call package_globals

    ## -------------------------------------------------
    our %misc_vars;
    our $except;

    $call c_support_subs

subcode:: c_init
    $if $MyDef::def->{"macros"}->{"use_double"}
	$type_name{f}="double";
	$type_prefix{f}="double";
    MyDef::dumpout::init_funclist();

############################################

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $if $v=~/(\S+)/
		$includes{"<$1>"}=1

# ---- allocate ----
subcode: allocate_dimension
    my $init_value;
    $if $dim=~/(.*),\s*(.*)/
	$dim=$1;
	$init_value=$2;
    $if $dim=~/[+-]/
	$dim="($dim)";

subcode: allocate_one(out)
    push @$(out), "$p=($type*)malloc(sizeof($type));";
    $if $init
	push @$(out), "$1_constructor($p);";
subcode: allocate_array(out)
    push @$(out), "$p=($type*)malloc($dim*sizeof($type));";
    $if $init
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++)$1_constructor($p\[i]);";
subcode: deallocate_one(out)
    $if $init
	push @$(out), "$1_destructor($p);";
    push @$(out), "free($p);";
subcode: deallocate_array(out)
    $if $init
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++)$1_destructor($p\[i]);";
    push @$(out), "free($p);";

subcode: check_destructor(out)
    $if $misc_vars{mu_enable}
	my $destructor="NULL";
	$if $exit
	    $destructor="&$1_destructor";
	push @$(out), "mu_add((void*)$p, sizeof($type), $dim, $destructor);";
subcode: allocate_debug(out)
    $if $misc_vars{"debug_mem"}==1
	push @$(out), "printf(\"Mem \%d - $p \%d $type [%x]\\n\", mu_lastmem, $dim, $p);";

subcode: check_struct_init_exit
    my ($init, $exit)
    $if $type=~/struct (\w+)/
	$init=@{$structs{$1}->{hash}->{"-init"}}
	$exit=@{$structs{$1}->{hash}->{"-exit"}}

# ----
subcode:: c_support_subs
    $sub allocate($dim, $param2)
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		$cur_function->{var_flag}->{$p}="retained";
		my $type=pointer_type(get_var_type($p));
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one, $out
		$else 
		    $call allocate_array, $out
		$if $global_type->{mu_total_mem}
		    push @$out, "mu_total_mem+=(float)$dim*sizeof($type)/1e6;"
		$if $global_type->{p_memlist}
		    push @$out, "mu_add_pointer((void*)$p, \"$p\", $dim*sizeof($type));"
		$call check_destructor, $out
		$call allocate_debug, $out
	$call allocate_init_value, $out

    $sub local_allocate($dim, $param2)
	my $post=MyDef::compileutil::get_named_block("_post")
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		my $type=pointer_type(get_var_type($p));
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one, $out
		    $call deallocate_one, $post
		$else 
		    $call allocate_array, $out
		    $call deallocate_array, $post
	$call allocate_init_value, $out

subcode: allocate_init_value(out)
    $if defined $init_value and $init_value ne ""
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++){";
	$foreach my $p in @plist
	    $if $p
		push @$(out), "    $p\[i]=$init_value;";
	push @$(out), "}";
# -------------------------------------
subcode:: c_support_subs
    $sub get_var_fmt($v)
	my $type=get_var_type($v)
	$if !$type
	    $type=get_c_type($v);
	$if $type=~/^(float|double)/
	    return "\%g"
	$elsif $type=~/^int/
	    return "\%d";
	$elsif $type=~/^char \*/
	    return "\%s";
	$elsif $type=~/^char/
	    return "\%d";
	$elsif $type=~/^unsigned char/
	    return "\%d";
	$else
	    print "get_var_fmt: unhandled $v - $type\n";
	    return $v

    $sub temp_string($str)
	$if $str=~/\$/
	    func_add_var("ts_temp_buf[100]", "local")
	    my @segs=split /(\$\w+)/, $str
	    my @vlist;
	    $for $j=0:@segs
		$if $segs[$j]=~/^\$(\w+)/
		    push @vlist, $1
		    $segs[$j]=get_var_fmt($1)
	    push @$out, "snprintf(ts_temp_buf, 100, \"".join('', @segs)."\", ".join(', ', @vlist).");"
	    return "ts_temp_buf"
	$else
	    return "\"$str\""


    $sub debug_dump($param, $prefix, $out)
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	$foreach my $v in @vlist
	    push @a2, $v;
	    push @a1, "$v=".get_var_fmt($v)
	$if $prefix
	    push @$out, "fprintf(stdout, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$else
	    push @$out, "fprintf(stdout, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$includes{"<stdio.h>"}=1;

