include: macros_c/globals.def
include: macros_c/parsing.def
include: macros_c/last_checks.def
include: macros_c/structure.def
include: macros_c/functions.def
include: macros_c/hash_and_list.def
include: macros_c/types.def
include: macros_c/dump.def
include: macros_c/regex.def

subcode: c_main
    use MyDef::dumpout;

    my $cur_indent;

    $call package_globals

    ## -------------------------------------------------
    our %misc_vars;
    our $except;

    $call c_support_subs

subcode: c_init
    %includes=();
    $if $MyDef::def->{"macros"}->{"use_double"}
	$type_name{f}="double";
	$type_prefix{f}="double";
    MyDef::dumpout::init_funclist();

############################################

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $if $v=~/(\S+)/
		$includes{"<$1>"}=1

subcode:: c_support_subs
    $sub declare_var($var, $type)
	$cur_function->{var_type}->{$var}=$type

    $sub parse_condition
	my ($param, $out)=@_;
	$if $param=~/^(\S+)\s*(!~|=~)\s*\/(.*)\//
	    my ($var, $eq, $pattern)=($1, $2, $3)
	    my ($pos, $end)
	    $if $var=~/(.*)\[(.*)\]/
		($var, $pos)=($1, $2)
	    $else
		($pos, $end)=(0, 0)
	    my $t= parse_regex_match($pattern, $out, $var, $pos, $end);
	    $if $eq =~/!~/
		return "!($t)"
	    $else
		return $t;

	$elsif $param=~/(\w+)->\{(.*)\}/
	    return hash_check($out, $1, $2);
	$else
	    return $param;

# ---- allocate ----
subcode: allocate_dimension
    my $init_value;
    $if $dim=~/(.*),\s*(.*)/
	$dim=$1;
	$init_value=$2;
    $if $dim=~/[+-]/
	$dim="($dim)";

subcode: allocate_one
    push @$out, "$p=($type*)malloc(sizeof($type));";
    $if $init
	push @$out, "$1_constructor($p);";
subcode: allocate_array
    push @$out, "$p=($type*)malloc($dim*sizeof($type));";
    $if $init
	func_add_var("i", "int");
	push @$out, "for(i=0;i<$dim;i++)$1_constructor($p\[i]);";
subcode: check_destructor
    $if $misc_vars{mu_enable}
	my $destructor="NULL";
	$if $exit
	    $destructor="&$1_destructor";
	push @$out, "mu_add((void*)$p, sizeof($type), $dim, $destructor);";
subcode: allocate_debug
    $if $misc_vars{"debug_mem"}==1
	push @$out, "printf(\"Mem \%d - $p \%d $type [%x]\\n\", mu_lastmem, $dim, $p);";

subcode: check_struct_init_exit
    my ($init, $exit)
    $if $type=~/struct (\w+)/
	$init=@{$structs{$1}->{hash}->{"-init"}}
	$exit=@{$structs{$1}->{hash}->{"-exit"}}

subcode:: c_support_subs
    $sub allocate
	my ($out, $dim, $param2)=@_;
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		$cur_function->{var_flag}->{$p}="retained";
		my $type=pointer_type(get_var_type($p));
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one
		$else 
		    $call allocate_array
		$if $global_type->{mu_total_mem}
		    push @$out, "mu_total_mem+=(float)$dim*sizeof($type)/1e6;"
		$if $global_type->{p_memlist}
		    push @$out, "mu_add_pointer((void*)$p, \"$p\", $dim*sizeof($type));"
		$call check_destructor
		#$call allocate_debug
	$call allocate_init_value

subcode: allocate_init_value
    $if defined $init_value and $init_value ne ""
	func_add_var("i", "int");
	push @$out, "for(i=0;i<$dim;i++){";
	$foreach my $p in @plist
	    $if $p
		push @$out, "    $p\[i]=$init_value;";
	push @$out, "}";
# -------------------------------------
subcode:: c_support_subs
    $sub debug_dump($param, $prefix, $out)
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	$foreach my $v in @vlist
	    push @a2, $v;
	    my $type=get_var_type($v)
	    $if !$type
		$type=get_c_type($v);
	    $if $type=~/^(float|double)/
		push @a1,"$v=\%g";
	    $elsif $type=~/^int/
		push @a1,"$v=\%d";
	    $elsif $type=~/^char \*/
		push @a1, "$v=\%s";
	    $elsif $type=~/^char/
		push @a1,"$v=\%d";
	    $elsif $type=~/^unsigned char/
		push @a1,"$v=\%d";
	    $else
		print "debug_dump: unhandled $v - $type\n";
	$if $prefix
	    push @$out, "fprintf(stdout, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$else
	    push @$out, "fprintf(stdout, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$includes{"<stdio.h>"}=1;

