include: macros_c/parsing.def
include: macros_c/last_checks.def
include: macros_c/structure.def
include: macros_c/functions.def
include: macros_c/hash_and_list.def
include: macros_c/types.def
include: macros_c/dump.def
include: macros_c/dump_h.def
# include: macros_c/regex.def

subcode: c_main
    use MyDef::dumpout;

    my $cur_indent;

    my $debug;
    $call package_globals

    ## -------------------------------------------------
    our %misc_vars;
    our $except;

    $call c_support_subs

subcode:: c_init
    $if $MyDef::def->{"macros"}->{"use_double"}
	$type_name{f}="double";
	$type_prefix{f}="double";
    MyDef::dumpout::init_funclist();

############################################

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $if $v=~/(\S+)/
		$includes{"<$1>"}=1

# ---- allocate ----
subcode: allocate_dimension
    my $init_value;
    $if $dim=~/(.*),\s*(.*)/
	$dim=$1;
	$init_value=$2;
    $if $dim=~/[+-]/
	$dim="($dim)";

subcode: allocate_one(out)
    push @$(out), "$p=($type*)malloc(sizeof($type));";
    $if $init
	push @$(out), "$1_constructor($p);";
subcode: allocate_array(out)
    push @$(out), "$p=($type*)malloc($dim*sizeof($type));";
    $if $init
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++)$1_constructor($p\[i]);";
subcode: deallocate_one(out)
    $if $init
	push @$(out), "$1_destructor($p);";
    push @$(out), "free($p);";
subcode: deallocate_array(out)
    $if $init
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++)$1_destructor($p\[i]);";
    push @$(out), "free($p);";

subcode: check_struct_init_exit
    my ($init, $exit)
    $if $type=~/struct (\w+)/
	$init=@{$structs{$1}->{hash}->{"-init"}}
	$exit=@{$structs{$1}->{hash}->{"-exit"}}

# ----
subcode:: c_support_subs
    $sub allocate($dim, $param2)
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		my $type;
		$if $p=~/^(\w+)$/
		    func_add_var($p)
		    $cur_function->{var_flag}->{$p}="retained"
		    $type=pointer_type(get_var_type($p))
		$else
		    $type=pointer_type(get_compound_type($p))
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one, $out
		$else 
		    $call allocate_array, $out
		$if $global_type->{memtrack_on}
		    MyDef::compileutil::call_sub("\@memtrack, $p")
	$call allocate_init_value, $out

    $sub local_allocate($dim, $param2)
	my $post=MyDef::compileutil::get_named_block("_post")
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		my $type=pointer_type(get_var_type($p));
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one, $out
		    $call deallocate_one, $post
		$else 
		    $call allocate_array, $out
		    $call deallocate_array, $post
	$call allocate_init_value, $out

subcode: allocate_init_value(out)
    $if defined $init_value and $init_value ne ""
	func_add_var("i", "int");
	push @$(out), "for(i=0;i<$dim;i++){";
	$foreach my $p in @plist
	    $if $p
		push @$(out), "    $p\[i]=$init_value;";
	push @$(out), "}";
# -------------------------------------
subcode: fmt_string_check_escape
    $if $j>0 and $segs[$j-1]=~/(\\+)$/
	$if length($1)%2==1
	    $segs[$j-1]=~s/\\$//
	    next

subcode: fmt_string_check_trailing
    $if $segs[$j+1]=~/^\\-\w/
	$segs[$j+1]=~s/^\\-//

subcode:: c_support_subs
    $sub fmt_string($str)
	$if $str=~/^\w+$/
	    return (0, $str)
	$if $str=~/^\s*\"(.*)\"\s*$/
	    $str=$1
	my @segs=split /(\$\w+)/, $str
	my @vlist;
	my $vcnt=0;
	$for $j=0:@segs
	    $if $segs[$j]=~/^\$(\w+)/
		my $v=$1
		$call fmt_string_check_escape
		$call fmt_string_check_trailing
		$vcnt++
		push @vlist, $v
		$segs[$j]=get_var_fmt($v)
	$if $vcnt>0
	    return ($vcnt, '"'.join('',@segs).'", '.join(', ', @vlist))
	$else
	    return (0, '"'. join('', @segs).'"')

    $sub debug_dump($param, $prefix, $out)
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	$foreach my $v in @vlist
	    push @a2, $v;
	    push @a1, "$v=".get_var_fmt($v)
	$if $prefix
	    push @$out, "fprintf(stdout, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$else
	    push @$out, "fprintf(stdout, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	$includes{"<stdio.h>"}=1;

