include: macros_c/globals.def
include: macros_c/parsing.def
include: macros_c/last_checks.def
include: macros_c/structure.def
include: macros_c/functions.def
include: macros_c/hash_and_list.def
include: macros_c/types.def
include: macros_c/dump.def
include: macros_c/regex.def

subcode: c_main
    use MyDef::dumpout;

    my $cur_indent;
    our $cur_function;

    $call package_globals

    ## -------------------------------------------------
    our %misc_vars;
    our $except;

    $call c_support_subs

subcode: c_init
    %includes=();
    $if $MyDef::def->{"macros"}->{"use_double"}
	$type_name{f}="double";
	$type_prefix{f}="double";
    MyDef::dumpout::init_funclist();

subcode: c_main_function
    my $func=$functions{"main"};
    $if $func
	$func->{skip_declare}=1;
	$func->{ret_type}="int";
	$func->{param_list}=["int argc", "char** argv"];
	$func->{init}=["DUMP_STUB main_init"];
	$func->{finish}=["DUMP_STUB main_exit", "return 0;"];

############################################

subcode: check_text_includes
    $while my ($k, $v)=each %text_include
	$if $l=~/$k/
	    $if $v=~/(\S+)/
		$includes{"<$1>"}=1

subcode:: c_support_subs
    sub declare_var {
	my ($var, $type)=@_;
	$cur_function->{var_type}->{$var}=$type;
    }

    sub single_block {
	my ($t, $out)=@_;
	push @$out, "$t\{";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "}";
	return "NEWBLOCK";
    }
    $sub parse_condition
	my ($param, $out)=@_;
	$if $param=~/^(\S+)\s*(!~|=~)\s*\/(.*)\//
	    my ($var, $eq, $pattern)=($1, $2, $3)
	    my ($pos, $end)
	    $if $var=~/(.*)\[(.*)\]/
		($var, $pos)=($1, $2)
	    $else
		($pos, $end)=(0, 0)
	    my $t= parse_regex_match($pattern, $out, $var, $pos, $end);
	    $if $eq =~/!~/
		return "!($t)"
	    $else
		return $t;

	$elsif $param=~/(\w+)->\{(.*)\}/
	    return hash_check($out, $1, $2);
	$else
	    return $param;

# ---- allocate ----
subcode: allocate_dimension
    my $init;
    $if $dim=~/(.*),\s*(.*)/
	$dim=$1;
	$init=$2;
    $if $dim=~/[+-]/
	$dim="($dim)";

subcode: allocate_one
    push @$out, "$p=($type*)malloc(sizeof($type));";
    $if $init
	push @$out, "$1_constructor($p);";
subcode: allocate_array
    push @$out, "$p=($type*)malloc($dim*sizeof($type));";
    $if $init
	func_add_var("i", "int");
	push @$out, "for(i=0;i<$dim;i++)$1_constructor($p\[i]);";
subcode: check_destructor
    $if $misc_vars{mu_enable}
	my $destructor="NULL";
	$if $exit
	    $destructor="&$1_destructor";
	push @$out, "mu_add((void*)$p, sizeof($type), $dim, $destructor);";
subcode: allocate_init
    $if defined $init and $init ne ""
	func_add_var("i", "int");
	push @$out, "for(i=0;i<$dim;i++){";
	$foreach my $p in @plist
	    $if $p
		push @$out, "    $p\[i]=$init;";
	push @$out, "}";
subcode: allocate_debug
    $if $misc_vars{"debug_mem"}==1
	push @$out, "printf(\"Mem \%d - $p \%d $type [%x]\\n\", mu_lastmem, $dim, $p);";

subcode: check_struct_init_exit
    my ($init, $exit)
    $if $type=~/struct (\w+)/
	$init=@{$structs{$1}->{hash}->{"-init"}}
	$exit=@{$structs{$1}->{hash}->{"-exit"}}

subcode:: c_support_subs
    $sub allocate
	my ($out, $dim, $param2)=@_;
	$includes{"<stdlib.h>"}=1;
	$call allocate_dimension
	my @plist=split /,\s+/, $param2;
	$foreach my $p in @plist
	    $if $p
		func_add_var($p);
		$cur_function->{var_flag}->{$p}="retained";
		my $type=pointer_type(get_var_type($p));
		$call check_struct_init_exit
		$if $dim == 1
		    $call allocate_one
		$else 
		    $call allocate_array
		$call check_destructor
		$call allocate_debug
		$call allocate_init

# -------------------------------------
subcode:: c_support_subs
    sub debug_dump {
	my ($param, $prefix, $out)=@_;
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	foreach my $v(@vlist){
	    push @a2, $v;
	    my $type=get_c_type($v);
	    if($type=~/^(float|double)/){
		push @a1,"$v=\%g";
	    }
	    elsif($type=~/^int/){
		push @a1,"$v=\%d";
	    }
	    elsif($type=~/^char \*/){
		push @a1, "$v=\%s";
	    }
	    elsif($type=~/^char/){
		push @a1,"$v=\%d";
	    }
	    else{
		print "debug_dump: unhandled $v - $type\n";
	    }
	}
	if($prefix){
	    push @$out, "fprintf(stderr, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	}
	else{
	    push @$out, "fprintf(stderr, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	}
	$includes{"<stdio.h>"}=1;
    }

