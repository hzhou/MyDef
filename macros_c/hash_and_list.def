subcode:: c_support_subs
    sub hash_check {
	my ($h, $name)=@_;
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	return "p_$h\->s_text";
    }
    sub hash_assign {
	my ($out, $h, $name, $val)=@_;
	my $p="p_$h";
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	push @$out, "if(p_$h\->s_text==NULL){p_$h->s_text=strdup($name);}";
	struct_set("$h\_node", "p_$h", $val, $out);
    }
    sub hash_fetch {
	my ($out, $h, $name, $var)=@_;
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	push @$out, "if(p_$h\->s_text){";
	struct_get("$h\_node", "p_$h", $var, $out);
	push @$out, "}";
	# use $except for the case where key does not exist.
	$except="else";
    }
    # --
    $sub get_list_type
	my ($var)=@_;
	$if my $type = get_var_type($var)
	    $if $type=~/struct (\w+)/
		return $1
	print "Warning: $var not a list type\n"
	return undef

    $map list_push_unshift, push, unshift
    $map list_pop_shift, pop, shift

    $sub list_foreach
	my ($out, $iv, $v)=@_;
	my $name=get_list_type($v);
	func_add_var("$iv", "struct $name\_node *");
	return "PARSE:&call dlist_each, $v, $iv"

subcode: list_push_unshift(push)
    $sub list_$(push)
	my ($out, $v, $val)=@_;
	my $name=get_list_type($v);
	$if $name
	    func_add_var("p_$name\_node", "struct $name\_node *");
	    push @$out, "p_$name\_node=$name\_$(push)($v);";
	    struct_set("$name\_node", "p_$name\_node", $val, $out);

subcode: list_pop_shift(pop)
    $sub list_$(pop)
	my ($out, $v, $var)=@_;
	my $name=get_list_type($v);
	$if $var
	    func_add_var("p_$name\_node", "struct $name\_node *");
	    push @$out, "p_$name\_node=$name\_$(pop)($v);";
	    struct_get("$name\_node", "p_$name\_node", $var, $out);
	$else
	    push @$out, "$name\_$(pop)($v);";
