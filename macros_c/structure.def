
subcode:: c_support_subs
    $sub declare_struct 
	my ($name, $param)=@_;
	$call check_autoload_h
	my ($s_list, $s_hash)
	$if $structs{$name}
	    $s_list=$structs{$name}->{list}
	    $s_hash=$structs{$name}->{hash}
	    $s_init=$s_hash->{"-init"}
	    $s_exit=$s_hash->{"-exit"}
	$else
	    $s_init=[]
	    $s_exit=[]
	    $s_list=[]
	    $s_hash={"-init"=>$s_init, "-exit"=>$s_exit}
	    $structs{$name}={list=>$s_list, hash=>$s_hash}
	    $if !$autoload_h
		push @struct_list, $name

	$call add_to_autoload_h, "struct-$name"
	$type_prefix{"st$name"}="struct $name";

	$call declare_struct_elements

subcode: declare_struct_elements
    my @plist=split /,\s+/, $param;
    $foreach my $p in @plist
	my ($m_name, $type, $needfree);
	$if $p=~/^\s*$/
	    next;
	$elif $p=~/(-\w+)=>(.*)/
	    $s_hash->{$1}=$2
	    next;
	$elif $p=~/class (\w+)/
	    # inheretance
	    my $o=$structs{$1}
	    $if $o
		my $h=$o->{hash}
		my $l=$o->{list}
		$foreach $m in @$l
		    $if !$s_hash->{$m}
			$s_hash->{$m}=$h->{$m}
			push @$s_list, $m
	    next
	$elif $p=~/^@/
	    $needfree=1
	    $p=$';

	$if $p=~/(.*?)(\S+)\s*=\s*(.*)/
	    $p="$1$2";
	    push @$s_init, "p->$2=$3;";

	$if $p=~/(.*\S)\s+(\S+)\s*$/
	    $type=$1;
	    $m_name=$2;
	    $if $m_name=~/^(\*+)(.*)/
		$type.=" $1"
		$m_name=$2
	    $p=$m_name
	$else
	    $m_name=$p;
	    $if $p=~/^(next|prev)$/
		$type="struct $name *"
	    $elif $fntype{$p}
		$type="function";
	    $else
		$type=get_c_type($p);
	$call declare_struct_element_init_exit

subcode: declare_struct_element_init_exit
    # -- init & exit
    $foreach my $fh in @func_var_hooks
	$if $fh->{var_check}->($type)
	    my $init=$fh->{var_init}->($type, "p->$m_name") 
	    $if $init
		push @$s_init, "p->$p=$init;";
	    my $exit=$fh->{var_release}->($type, "p->$m_name", "skipcheck")
	    $if $exit
		$foreach my $l in @$exit
		    push @$s_exit, $l;
    # ----
    $if !$s_hash->{$m_name}
	push @$s_list, $m_name
    $s_hash->{$m_name}=$type
    $if $needfree
	$s_hash->{"$name-needfree"}=1

subcode:: c_support_subs
    $sub get_struct_element_type 
	my ($stype, $evar)=@_;
	$if $stype=~/(\w+)(.*)/
	    $if $typedef_hash{$1}
		$stype=$typedef_hash{$1}.$2
	$if $stype=~/struct\s+(\w+)/
	    my $struc=$structs{$1};
	    my $h=$struc->{hash}
	    $if $h->{$evar}
		return $h->{$evar}
	    $else
		$foreach $k in keys(%$h)
		    $if $k=~/^$evar\[/
			return "$h->{$k} *"
	    $if $debug eq "type"
		$while my ($k, $v)=each %$h
		    print "  :|$k: $v\n"
		print "$evar not defined in struct $1\n"
	return "void"

    $sub struct_free
	my ($out, $ptype, $name)=@_;
	my $type=pointer_type($ptype);
	$if $type=~/struct\s+(\w+)/ and $structs{$1}
	    $s_list=$structs{$1}->{list}
	    $s_hash=$structs{$1}->{hash}
	    $foreach my $p in @$s_list
		$if $s_hash->{"$p-needfree"}
		    struct_free($out, $s_hash->{$p}, "$name->$p")
	push @$out, "free($name);";

    $sub struct_set
	my ($struct_type, $struct_var, $val, $out)=@_;
	my $struct=$structs{$struct_type}->{list}
	my @vals=split /,\s*/, $val;
	for(my $i=0; $i<=$#vals; $i++){
	    my $sname=$struct->[$i];
	    do_assignment("$struct_var\->$sname", $vals[$i], $out);
	}

    $sub struct_get
	my ($struct_type, $struct_var, $var, $out)=@_;
	my $struct=$structs{$struct_type}->{list}
	my @vars=split /,\s*/, $var;
	for(my $i=0; $i<=$#vars; $i++){
	    my $sname=$struct->[$i];
	    do_assignment( $vars[$i],"$struct_var\->$sname", $out);
	}
