subcode:: parsecode_func_other
    $elif $func eq "tuple"
	declare_tuple($param)
	return
    $elif $func eq "union"
        declare_union($param)
        return

subcode:: parsecode_func_param_other
    $elif $func eq "struct"
	declare_struct($param1, $param2)
	return

#-----------------------------------------
#-- $tuple declares anonymous struct with a1, a2, ...
#--   ref: deflib/c/darray.def
fncode: declare_tuple($param) 
    $global %tuple_hash
    my $name
    $if $tuple_hash{$param}
        $name=$tuple_hash{$param}
    $else
        $name=MyDef::utils::uniq_name("T", \%structs)
        $tuple_hash{$param}=$name
    MyDef::compileutil::set_current_macro("T", $name)

    my $s_list=[]
    my $s_hash={}
    $structs{$name}={list=>$s_list, hash=>$s_hash}
    push @struct_list, $name
    my @plist=split /,\s+/, $param;
    my $i=0
    $foreach $p in @plist
        $i++
        my $m_name="a$i"
        push @$s_list, $m_name
        $s_hash->{$m_name}=$p

    return $name

#---------------------------------------- 
#-- $union only supported as structure member
#--     each delcare overwites previous definition
#--     to be used by nearby $struct delcaration
#--      ref: calc
fncode: declare_union($param)
    $global $union_hash
    $if !$param
        $union_hash={}
        return $union_hash
    $elif !defined $union_hash or %$union_hash
        $call warn, "\$union has to be preceded by structure member/n"

    my @plist=split /,\s+/, $param;
    $foreach $p in @plist
        my ($type, $name)
	$if $p=~/(.*\S)\s+(\S+)\s*$/
	    ($type, $name)=($1, $2)
	    $if $name=~/^(\*+)(.*)/
		$type.=" $1"
		$name=$2
	    $p=$name
	$else
	    $name=$p;
            $type=get_c_type($p)

        $union_hash->{$name}=$type

#-----------------------------------------
fncode: declare_struct($name, $param)
    my ($s_list, $s_hash)
    my ($s_init, $s_exit)
    $if $structs{$name}
        $s_list=$structs{$name}->{list}
        $s_hash=$structs{$name}->{hash}
        $s_init=$s_hash->{"-init"}
        $s_exit=$s_hash->{"-exit"}
    $else
        $s_init=[]
        $s_exit=[]
        $s_list=[]
        $s_hash={"-init"=>$s_init, "-exit"=>$s_exit}
        $structs{$name}={list=>$s_list, hash=>$s_hash}
        push @struct_list, $name

    $type_prefix{"st$name"}="struct $name";

    $call declare_struct_elements

subcode:: c_support_subs
    #--- ... for c++ constructor ----
    $sub get_struct_constructor($name)
	my $s_list=$structs{$name}->{list}
	my $s_hash=$structs{$name}->{hash}
	my $s_init=$s_hash->{"-init"}
	$if $s_init and @$s_init
	    my @param_list
	    my @initializer
	    my %init_hash
	    $foreach $l in @$s_init
		$if $l=~/^(\w+)=\$(\w+)/ and $s_hash->{$1}
		    my $dummy=$2
		    push @param_list, $s_hash->{$1}." $dummy"
		    push @initializer, "$1=$dummy"
		    $init_hash{$1}=1
		$elif $l=~/^(\w+)=(.*)/ and $s_hash->{$1}
		    $if $2 eq "\$"
			my $dummy="dummy_$1"
			push @param_list, $s_hash->{$1}." $dummy"
			push @initializer, "$1=$dummy"
		    $else
			push @initializer, "$1=$2"
		    $init_hash{$1}=1
		$else
		    #- not supported
	    $foreach $m in @$s_list
		$if !$init_hash{$m}
		    my $default=type_default($s_hash->{$m})
		    $if $default
			push @initializer, "$m=$default"
	    return (\@param_list, \@initializer)
	$else
	    return (undef, undef)

subcode: declare_struct_elements
    my @plist=split /,\s+/, $param;
    my $i=0
    $foreach $p in @plist
	my ($m_name, $type, $needfree);
	$if $p=~/^\s*$/
	    next;
	$elif $p=~/(-\w+)=>(.*)/
	    #---- {-init}, {-exit}, ...
	    $s_hash->{$1}=$2
	    next;
	$elif $p=~/class (\w+)/
	    # inheretance
	    my $o=$structs{$1}
	    $if $o
		my $h=$o->{hash}
		my $l=$o->{list}
		$foreach $m in @$l
		    $if !$s_hash->{$m}
			$s_hash->{$m}=$h->{$m}
			push @$s_list, $m
	    next
	$elif $p=~/^@/
	    $needfree=1
	    $p=$';

	$i++
	#-- init -------
	$if $p=~/(.*?)(\S+)\s*=\s*(.*)/
	    $p="$1$2";
	    push @$s_init, "$2=$3";

        #-- normal -----
	$if $p=~/(.*\S)\s+(\S+)\s*$/
	    $type=$1;
	    $m_name=$2;
	    $if $m_name=~/^(\*+)(.*)/
		$type.=" $1"
		$m_name=$2
	    $p=$m_name
	$elif $basic_types{$p} or $p=~/\*$/
	    #--- anonymous member --
	    $m_name="a$i"
	    $type=$p
	$else
	    $m_name=$p;
	    $if $p=~/^(next|prev)$/
		#---- linked list ----
		$type="struct $name *"
	    $elif $p=~/^(left|right)$/
		#---- binary tree ----
		$type="struct $name *"
            $elif $p=~/^(u|data)$/
                $type="union"
	    $elif $fntype{$p}
		$type="function";
	    $else
		$type=get_c_type($p);

	#---------------------------------------- 
	$if !$s_hash->{$m_name}
	    push @$s_list, $m_name
	$s_hash->{$m_name}=$type
	$if $needfree
	    $s_hash->{"$name-needfree"}=1

        $if $type eq "union"
            $s_hash->{-union}=declare_union()

subcode:: c_support_subs
    $sub get_struct_element_type 
	my ($stype, $evar)=@_;
	$if $stype=~/(\w+)(.*)/
	    $if $typedef_hash{$1}
		$stype=$typedef_hash{$1}.$2
	$if $stype=~/struct\s+(\w+)/
	    my $struc=$structs{$1};
	    my $h=$struc->{hash}
	    $if $h->{$evar}
		return $h->{$evar}
	    $else
		$foreach $k in keys(%$h)
		    $if $k=~/^$evar\[/
			return "$h->{$k} *"
	    $if $debug eq "type"
		$while my ($k, $v)=each %$h
		    print "  :|$k: $v\n"
		print "$evar not defined in struct $1\n"
	return "void"

    $sub struct_free
	my ($out, $ptype, $name)=@_;
	my $type=pointer_type($ptype);
	$if $type=~/struct\s+(\w+)/ and $structs{$1}
	    my $s_list=$structs{$1}->{list}
	    my $s_hash=$structs{$1}->{hash}
	    $foreach my $p in @$s_list
		$if $s_hash->{"$p-needfree"}
		    struct_free($out, $s_hash->{$p}, "$name->$p")
	push @$out, "free($name);";

    $sub struct_set
	my ($struct_type, $struct_var, $val, $out)=@_;
	my $struct=$structs{$struct_type}->{list}
	my @vals=split /,\s*/, $val;
	for(my $i=0; $i<=$#vals; $i++){
	    my $sname=$struct->[$i];
	    do_assignment("$struct_var\->$sname", $vals[$i], $out);
	}

    $sub struct_get
	my ($struct_type, $struct_var, $var, $out)=@_;
	my $struct=$structs{$struct_type}->{list}
	my @vars=split /,\s*/, $var;
	for(my $i=0; $i<=$#vars; $i++){
	    my $sname=$struct->[$i];
	    do_assignment( $vars[$i],"$struct_var\->$sname", $out);
	}
