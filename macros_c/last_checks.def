subcode: check_termination
    if($l=~/^\s*$/){
    }
    elsif($l=~/(for|while|if|else if)\s*\(.*\)\s*$/){
    }
    elsif($l!~/[:\{\};,]\s*$/){
	$l.=";";
    }

subcode: check_exponential
    # x^4
    $while $l=~/\^([234])/
	my $t_p=$1;
	my $t_tail=$';
	my ($t_head, $t_exp)=last_exp($`);
	my $t_trunk="$t_exp*" x ($t_p-1);
	$t_trunk.=$t_exp;
	$l="$t_head($t_trunk)$t_tail";

subcode: check_functioncall
    $if $l=~/^(\w+)\s+(.*)$/
	# print "check_functioncall: $1\n"
	$if $functions{$1} or $stock_functions{$1}
	    my $fn=$1;
	    my $t=$2;
	    $t=~s/;\s*$//;
	    $t=~s/\s+$//;
	    $l="$fn($t);";

subcode: check_assignment
    $if $debug eq "type"
	print "check_assignment: $l\n"
    $if $cur_function and $l=~/^[^'"\(]*=/
	my $tl=$l;
	$tl=~s/;+\s*$//;
	$if $tl=~/^\s*\((.*?\w)\)\s*=\s*\((.*)\)/
	    # -- multi-assignment --
	    my ($left, $right)=($1, $2);
	    my @left=split /,\s*/, $left;
	    my @right=comma_split($right);
	    $for $i=0:$#left+1
		do_assignment($left[$i], $right[$i], $out);
	    return
	$elif $tl=~/^\s*(.*?\w)\s*=\s*([^=].*)/
	    my ($left, $right)=($1, $2);
	    do_assignment($left, $right, $out);
	    return


subcode:: c_support_subs
    $sub comma_split
	my $l=shift;
	my @t
	my $i0=0
	my $n=length($l);
	my @wait_stack;
	my $cur_wait;
	my %pairlist=("'"=>"'", '"'=>'"', '('=>')', '['=>']', '{'=>'}')
	$for $i=0:$n
	    my $c=substr($l, $i, 1)
	    $if $c eq "\\"
		$i++
		next
	    $if $cur_wait
		$if $c eq $cur_wait
		    $cur_wait=pop @wait_stack
		    next
		$if $c =~ /['"\(\[\{]/ 
		    $cur_wait=$pairlist{$c}
		    push @wait_stack, $cur_wait
		    next
	    $else
		$if $c =~ /['"\(\[\{]/ 
		    $cur_wait=$pairlist{$c}
		    next
		$if $c eq ","
		    $if $i>$i0
			push @t, substr($l, $i0, $i-$i0)
		    $else
			push @t, ""
		    $i0=$i+1
		    next
	$if $n>$i0
	    push @t, substr($l, $i0, $n-$i0)
	return @t
    $sub do_assignment
	my ($left, $right, $out)=@_;
	$if $debug eq "type"
	    print "do_assignment: $left = $right\n"
	my $type;
	$if $left=~/^(.*?)\s+(\S+)$/
	    $type=$1;
	    $left=$2;
	$if $left=~/^\w+$/
	    $if !$global_type->{$left}
		func_add_var($left, $type, $right);
	push @$out, "$left=$right;";

    $sub last_exp($l)
	my $tlen=length($l);
	my $i=$tlen-1;
	$if substr($l, $i, 1) eq ')'
	    my $level=1;
	    while($i>1){
		$i--;
		if(substr($l, $i, 1) eq ')'){$level++;}
		if(substr($l, $i, 1) eq '('){$level--;}
		if($level==0){last;}
	    }
	$else
	    while($i>0){
		if(substr($l, $i, 1) eq ']'){
		    my $level=1;
		    while($i>1){
			$i--;
			if(substr($l, $i, 1) eq ']'){$level++;}
			if(substr($l, $i, 1) eq '['){$level--;}
			if($level==0){last;}
		    }
		    $i--;
		    next;
		}
		elsif(substr($l, $i-1, 2) eq '->'){
		    $i-=2;
		    next;
		}
		elsif(substr($l, $i, 1)=~/[0-9a-zA-Z_.]/){
		    $i--;
		    next;
		}
		last;
	    }
	    if(substr($l, $i, 1)!~/[a-zA-Z_.]/){
		$i++;
	    }

	my $t0=substr($l, 0, $i);
	my $t3=substr($l, $i, $tlen-$i);
	return ($t0, $t3);

# -----------------------
	/*
	    # $type=get_var_type_direct($left);
	    # func_var_assign($type, $left, $right, $out);
	$elsif $left=~/^(\w+\S+)$/
	    # -- complex case --
	    # $type=get_var_type($1)
	    # func_var_assign($type, $left, $right, $out);
	$else
	    push @$out, "$left=$right;";
	    */

