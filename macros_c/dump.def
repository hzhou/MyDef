subcode: c_dump_init
    my @dump_init
    $dump->{block_init}=\@dump_init
    unshift @$out, "INCLUDE_BLOCK block_init"

    $call dump_h_files

    my $dump_out=\@dump_init
    $call dump_includes
    $call dump_defines
    $call dump_enums
    $call dump_typedefs
    $call @dump_classes
    $call dump_structs
    $call dump_function_declares
    $call dump_declares
    $call dump_structs_functions
    $call dump_globals
    $call dump_code_list

subcode: dump_classes
    $global $dump_classes
    $if $dump_classes
	$foreach $l in @$dump_classes
	    push @$dump_out, $l

# ---- Includes ----
subcode:: c_init
    $global %includes, %objects
    %includes=()
    %objects=()

subcode: add_include(l)
    my @flist=split /,\s*/, $(l)
    $call check_autoload_h
    $foreach $f in @flist
	my $key
	$if $f=~/\.\w+$/
	    $key="\"$f\""
	$elif $f=~/^".*"$/
	    $key=$f
	$elif $f=~/^<.*>$/
	    $key=$f
	$else
	    $key="<$f.h>"
	$includes{$key}=1
	$call add_to_autoload_h, "include-$key"

subcode: dump_includes
    my $cnt=0
    $while my ($k, $t)=each %includes
	push @$dump_out, "#include $k\n";
	$cnt++
    $if $cnt>0
	push @$dump_out, "\n";

# ---- Defines ----
subcode:: c_init
    $global $define_id_base, @define_list, %defines
    $define_id_base=1000
    @define_list=()
    %defines=()

subcode:: support_subs
    $sub add_define($name, $var)
	$call check_autoload_h
	$if !$autoload_h
	    $if !defined $defines{$name}
		push @define_list, $name
	    $else
		warn "Duplicate define $name: [$defines{$name}] -> [$var]\n"
	    $defines{$name}=$var
	    $call add_to_autoload_h, "define-$name"

subcode: dump_defines
    my $cnt=0
    $foreach $k in @define_list
	$call dump_define, $k
	$cnt++
    $if $cnt>0
	push @$dump_out, "\n";

subcode: dump_define(k)
    push @$dump_out, "#define $(k) $defines{$(k)}\n";

# ---- TypeDefs ----
subcode:: c_init
    $global @typedef_list, %typedef_hash
    @typedef_list=()
    %typedef_hash=()

subcode:: support_subs
    $sub add_typedef($param)
	$call check_autoload_h
	$if !$autoload_h
	    $if $param=~/(.*)\s+(\w+)\s*$/
		$typedef_hash{$2}=$1
		push @typedef_list, $2
		$call add_to_autoload_h, "typedef-$2"
	    $elif $param=~/\(\*\s*(\w+)\)/
		$typedef_hash{$1}=$param
		push @typedef_list, $1
		$call add_to_autoload_h, "typedef-$1"


subcode: dump_typedefs
    $if @typedef_list
	$foreach $k in @typedef_list
	    $call dump_typedef, $k
	push @$dump_out, "\n";

subcode: dump_typedef(k)
    my $t=$typedef_hash{$(k)}
    $if $t=~/\(\*\s*(\w+)\)/
	push @$dump_out, "typedef $t;"
    $else
	push @$dump_out, "typedef $t $(k);"

# ---- Enums ----
subcode:: c_init
    $global %enums, @enum_list
    %enums=()
    @enum_list=()

subcode: dump_enums
    my $cnt=0
    $foreach $name in @enum_list
	my $t=$enums{$name};
	$if $name=~/^ANONYMOUS/
	    push @$dump_out, "enum {$t};\n";
	$elif $name=~/^,\s*(\w+)/ 
	    push @$dump_out, "enum {$t} $1;\n";
	$else
	    push @$dump_out, "enum $name {$t};\n";
	$cnt++
    $if $cnt>0
	push @$dump_out, "\n";

# ---- Global Variables ----
subcode:: c_init
    $global $global_type, $global_hash, @global_list
    $global_type={}
    $global_hash={}
    @global_list=()

subcode: dump_globals
    my $cnt=0
    $foreach $name in @global_list
	my $v=$global_hash->{$name}
	push @$dump_out, "$v;\n";
	$cnt++
    $if $cnt>0
	push @$dump_out, "\n";

# ---- Function Delcares ----
subcode:: c_init
    $global @function_declare_list
    @function_declare_list=()

subcode: dump_function_declares
    my $cnt=0
    $foreach $t in @function_declare_list
	my $func=$functions{$t}
	$if !$func->{skip_declare}
	    $call dump_function_declare, $func
	    $cnt++
    $if $cnt>0
	push @$dump_out, "\n";

subcode: dump_function_declare(k)
    $(if:k!=$func)
	my $func=$functions{$(k)}
    push @$dump_out, $func->{declare}.";\n"

# ---- Declares ----
subcode:: c_init
    $global @declare_list
    @declare_list=()

subcode:: do_declare(param)
    push @declare_list, $(param)

subcode: dump_declares
    $foreach my $l in @declare_list
	$if $l!~/;\s*$/
	    $l.=";"
	push @$dump_out, "$l\n";
    $if @declare_list
	push @$dump_out, "\n";

# ---- Structures ----
subcode:: c_init
    $global %structs, @struct_list
    %structs=()
    @struct_list=()

subcode: dump_structs
    $foreach $name in @struct_list
	$call dump_struct

subcode: dump_struct
    push @$dump_out, "struct $name {\n";
    my $s_list=$structs{$name}->{list}
    my $s_hash=$structs{$name}->{hash}
    my $i=0;
    $foreach my $p in @$s_list
	$i++;
	$if $s_hash->{$p} eq "function"
	    push @$dump_out, "\t".$fntype{$p}.";\n";
	$else
	    push @$dump_out, "\t$s_hash->{$p} $p;\n";
    push @$dump_out, "};\n\n";

#---- Simple Constructors/Destructors ----------------------------------------
subcode: dump_structs_functions
    my $cnt=0
    $foreach $name in @struct_list
	my ($param, $init)=get_struct_constructor($name)
	$if defined $init
	    $if !@$param
		push @$dump_out, "void $name\_constructor(struct $name* p){\n";
	    $else
		my $param_line=join(", ", @$param)
		push @$dump_out, "void $name\_constructor(struct $name* p, $param_line){\n";

	    $foreach $l in @$init
		push @$dump_out, "    p->$l;\n"
	    push @$dump_out, "}\n";
	    $cnt++
	#------------------------------
	my $s_list=$structs{$name}->{list}
	my $s_hash=$structs{$name}->{hash}
	my $s_exit=$s_hash->{"-exit"}
	$if @$s_exit
	    push @$dump_out, "void $name\_destructor(struct $name* p){\n";
	    foreach my $l(@$s_exit){
		push @$dump_out, "    $l\n";
	    }
	    push @$dump_out, "}\n";
	    $cnt++
	# ------------------------
    $if $cnt>0
	push @$dump_out, "\n";

# ---- Init codes ----
subcode:: c_init
    $global @initcodes
    @initcodes=()

subcode: dump_code_list
    $foreach my $l in @initcodes
	push @$dump_out, "$l\n";
    $if @initcodes
	push @$dump_out, "\n";

