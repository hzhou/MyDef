subcode:: parsecode_func_other
    $elif $func eq "yield"
	$global $yield
	$yield=$param
	return

subcode:: c_support_subs
    $sub check_expression($l, $context)
	my ($assign, $left, $right)
	$call @check_expression_init
	$call check_expression_parse_stack
	$while 1
	    $call check_expression_parse, $l
	    $call check_expression_push
	$if @stack==1 and $types[0] eq "atom-("
	    $right=substr($stack[0], 1, -1)
	$else
	    $right=join("", @stack)

	$if $assign
	    $if $assign eq "="
		$if $context eq "condition"
		    $if $right!~/^\w+\(.*\)$/
			$call warn,  Assignment in [$left = $right], possible bug?
		    return "$left = $right"
		$else
		    do_assignment($left, $right)
		    return
	    $else
		$right= "$left $assign $right"
	$call process_expression_cache, $right
	return $right

#---------------------------------------- 
subcode: check_expression_parse(l)
    my ($token, $type)
    $if $(l)=~/\G$/gc
	last
    #----  atom ------
    $elif $(l)=~/\G("([^"\\]|\\.)*")/gc
	$token=$1
	$type="atom-string"
    $elif $(l)=~/\G('([^'\\]|\\.)*')/gc
	$token=$1
	$type="atom-char"
    $elif $(l)=~/\G(\d[0-9\.a-zA-Z]*)/gc
	$token=$1
	$type="atom-number"
	$if $stack[-1] eq "^" and $token<10 and $token>1
	    $call check_exp_exponential
	$elif $stack[-1] eq "."
	    $call check_exp_tuple_member
    $elif $(l)=~/\G(\w+)/gc
	$token=$1
	$type="atom-identifier"
	$call check_exp_member
    #---- special --------
    $elif $(l)=~/\G\$(\w+)/gc
	my $method=$1
	$if $method=~/^(eq)$/
	    $token=$1
	    $type="operator"
	$else
	    $call check_exp_callsub
    #----  bracket ------
    $elif $(l)=~/\G([\(\[\{])/gc
	$call exp_push, $1, undef
	next
    $elif $(l)=~/\G([\)\]\}])/gc
	$call check_exp_bracket
    #---- skip ----
    $elif $(l)=~/\G(\s+)/gc
	# skip
    #---- operator ----
    $elif $(l)=~/\G=~/gc
	$call check_exp_regex
    $elif $(l)=~/\G([=+\-\*\/%\^\&\|><\?,\.!~:]+)/gc
	$token=$1
	$type="operator"
    $else
	last

#---------------------------------------- 
subcode: check_expression_push
    check_exp_precedence:
    $if !@stack
	$call exp_push, $token, $type
    $elif $type=~/^op/
	$if $token eq "++" or $token eq "--"
	    #---- postfix -----------------
	    $call exp_pop, $exp
	    $call exp_push, "$exp$token", "atom-exp"
	$elif $token eq ":"
	    #---- label -----------------
	    $call exp_pop, $exp
	    $call exp_push, "$exp$token ", "atom-label"
	$elif $token=~/^(.*)=$/ and $1!~/^[><=]$/
	    #---- assignment --------------
	    $assign=$token
	    $if $left
		$call warn,  Chained assignment not supported [left=$left, assign=$assign]!
	    $if !$1 and @stack==1 and $types[0] eq "atom-("
		$left=substr($stack[0], 1, -1)
		$call exp_pop, undef
	    $else
		$left=join("", @stack)
		@stack=()
		@types=()
	    $if $assign eq "="
		$call process_expression_cache, $left
	$else
	    #---- other op ----------------
	    $call exp_push, $token, $type
    $elif $type=~/^atom/
	$if $types[-1] =~/^op/
	    $if $types[-2] !~/^atom/
		#---- unary -------------
		$call exp_pop, $op
		$token=$op.$token
		$type="atom-exp"
		goto check_exp_precedence
	    $else
		#---- binary -------------
		$if $stack[-1] eq ","
		    $stack[-1]="$stack[-1] "
		$elif $stack[-1] eq "eq"
		    $call check_exp_string_op
		$else
		    $stack[-1]=" $stack[-1] "
		$call exp_push, $token, $type
	$elif $types[-1] =~/^atom/
	    $if $stack[-1]=~/\w$/
		#---- e.g. unsigned int, struct something
		$stack[-1].=" $token"
	    $else
		$stack[-1].=$token
		$if $types[-1] eq "atom-("
		    #---- type cast ---- 
		    $types[-1] = "atom"
	$else
	    #---- open bracket ---------
	    $call exp_push, $token, $type

subcode: check_exp_bracket
    my $close=$1
    my $open
    $if $close eq ')'
	$open='('
    $if $close eq ']'
	$open='['
    $if $close eq '}'
	$open='{'

    my $n=@stack
    my $found
    $for $i=$n:0
	$if $stack[$i] eq $open
	    $found=$i
	    break
    $if defined $found and $stack[$found] eq $open
	my $exp=join("", splice(@stack, $found+1))
	pop @stack
	splice(@types, $found)
	$if $types[-1] =~/^atom/ and $stack[-1]!~/^[0-9'"]/
	    $call exp_pop, $primary
	    my $processed
	    $type="atom-exp"
	    $if $open eq '('
		$call check_exp_fcall, $primary, $exp
	    $elif $open eq '['
		$call check_exp_subscript, $primary, $exp
	    $elif $open eq '{'
		$call check_exp_dict, $primary, $exp
	    $if !$processed
		$token=$primary.$open.$exp.$close
	$else
	    $token=$open.$exp.$close
	    $type="atom-$open"
    $else
	$print Error checking expression $(l), unbalanced brackets
	print join(" -- ", @stack), "\n"
	$token=join("", @stack)
	$type="atom-broken"

#---------------------------------------- 
subcode: check_exp_exponential
    $call exp_pop, undef
    $call exp_pop, $primary
    $token=$primary. (" * $primary" x ($token-1))
    $type="atom-exp"

subcode: check_exp_member
    $if $types[-1] =~/^op/ && $stack[-1] eq "." or $stack[-1] eq "->"
	$if $types[-2] !~/^atom/
	    #error
	$token=join("", splice(@stack, -2)).$token
	$type="atom-exp"
	splice(@types, -2)

subcode: check_exp_tuple_member
    $if $types[-2] !~/^atom/
	#error
    $token=join("", splice(@stack, -2))."a$token"
    $type="atom-exp"
    splice(@types, -2)

#---------------------------------------- 
subcode: check_exp_callsub
    $if $stack[-1] eq "." and $stack[-2]
	my $varname=$stack[-2]
	my $arg=$'
	&call if_lex, \((.*)\)
	    $arg=$1
	my $var=find_var($varname)
	$if $var->{class}
	    my $subname=$var->{class}."_".$method
	    my $call_line="$subname, $varname"
	    $arg=~s/^\s+//
	    $if length($arg)>0
		$call_line .= ", $arg"
	    undef $yield
	    MyDef::compileutil::call_sub($call_line)
	    $if $yield
		$call exp_pop, undef
		$call exp_pop, undef
		$call exp_push, $yield, "atom"
		last
	    $else
		return
    $call warn, \$$method not defined
    $call exp_push, "\$$method", "atom-unknown"

#---------------------------------------- 
subcode: check_exp_fcall(primary, token)
    # print "fcall: $(primary)  $(token)\n"

subcode: check_exp_subscript(primary, token)
    # print "subscript: $(primary)  $(token)\n"
    $if $(token)<0
	my $var=find_var($(primary))
	$(token)=-$(token)
	# $print "$yellow$var: class: $var->{class}"
	$if $var and $var->{class}
	    $token="\$($var->{class}_index_negative:$(primary),$(token)\)"
	    MyDef::compileutil::expand_macro_recurse(\$token)
	    $type="atom"
	    $call exp_pop, undef
	    $call exp_pop, undef
	    $processed=1


subcode: check_exp_dict(primary, token)
    $processed=1
    $token=$primary.$open.$exp.$close
    $cache{$token}=1

subcode:: check_expression_init
    #- %cache, for parsing hash: T{key}
    my %cache

subcode: process_expression_cache(t)
    $if %cache
	$foreach $t in keys %cache
	    $if $t=~/(\w+)\{(.*)\}/
		my ($t1, $t2)=($1, $2)
		my $var=find_var($t1)
		$if $var and $var->{class}
		    $(if:t=$left)
			my $call_line=$var->{class}."_lookup_left, $t1, $t2"
		    $(else)
			my $call_line=$var->{class}."_lookup, $t1, $t2"
		    undef $yield
		    MyDef::compileutil::call_sub($call_line)
		    my $pos=-1
		    my $len=length $t
		    $while ($pos=index($(t), $t, $pos))>-1
			substr($(t), $pos, $len)=$yield

#---------------------------------------- 
subcode: check_exp_string_op
    $call exp_pop, undef
    $call exp_pop, $exp
    $if $type eq "atom-string"
	$call exp_push, "strcmp($exp, $token)==0", "atom"
    $else
	my $var=find_var($token)
	$if $var and $var->{strlen}
	    $call exp_push, "strncmp($exp, $token, $var->{strlen})==0", "atom"
	$else
	    $call exp_push, "strcmp($exp, $token)==0", "atom"

#---------------------------------------- 
subcode: check_exp_regex
    $if $types[-1] =~/^atom/
	$call exp_pop, $atom
	my $func="regex"
	my $pat
	$(set:pat=(?:[^\/\\]|\\.)*)
	$if $(l)=~/\G\s*(\/$(pat)\/\w*)/gc
	    $pat=$1
	$elif $(l)=~/\G\s*(s\/$(pat)\/$(pat)\/\w*)/gc
	    $pat=$1
	$else
	    $call warn, =~ missing regex pattern
	my $regex_plugin=$plugin_condition{regex}
	$if !$regex_plugin
	    $call warn, =~ missing regex plugin
	my $param="$atom=~$pat"
	# $print "$green regex $param"
	my $condition
	$call parsecode_run_eval, $regex_plugin
	$token=$condition
	$type="atom-regex"
    $else
	$call warn, =~ missing string variable

#--------------------------------------
subcode: check_expression_parse_stack
    my @stack
    my @types

subcode: exp_push(exp, type)
    push @stack, $(exp)
    push @types, $(type)

subcode: exp_pop(assign)
    $(if:assign=undef)
	pop @stack
	pop @types
    $(else)
	my $(assign)=pop @stack
	pop @types

