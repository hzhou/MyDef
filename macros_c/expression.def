subcode:: parsecode_func_other
    $elif $func eq "yield"
	$global $yield
	$yield=$param
	return

subcode:: c_support_subs
    $sub check_expression($l, $context)
	my ($assign, $left, $right)
	#- %cache, for parsing hash: T{key}
	my %cache
	$call check_expression_parse_stack
	$call check_expression_parse, $l
	$if @stack==1 and $types[0] eq "atom-("
	    $right=substr($stack[0], 1, -1)
	$else
	    $right=join("", @stack)

	$if $assign
	    $if $assign eq "="
		do_assignment($left, $right)
		return
	    $else
		return "$left $assign $right"
	$else
	    return $right

#---------------------------------------- 
subcode: check_expression_parse(l)
    $while 1
	my ($token, $type)
	$if $(l)=~/\G$/gc
	    last
	#----  atom ------
	$elif $(l)=~/\G("([^"\\]|\\.)*")/gc
	    $token=$1
	    $type="atom-string"
	$elif $(l)=~/\G('([^'\\]|\\.)*')/gc
	    $token=$1
	    $type="atom-char"
	$elif $(l)=~/\G(\d[0-9\.a-zA-Z]*)/gc
	    $token=$1
	    $type="atom-number"
	    $if $stack[-1] eq "^" and $token<10 and $token>1
		$call check_exp_exponential
	    $elif $stack[-1] eq "."
		$call check_exp_tuple_member
	$elif $(l)=~/\G(\w+)/gc
	    $token=$1
	    $type="atom-identifier"
	    $call check_exp_member
	#---- special --------
	$elif $(l)=~/\G\$(\w+)/gc
	    my $method=$1
	    $call check_exp_callsub
	#----  bracket ------
	$elif $(l)=~/\G([\(\[\{])/gc
	    $call exp_push, $1, undef
	    next
	$elif $(l)=~/\G([\)\]\}])/gc
	    $call check_exp_bracket
	#---- skip ----
	$elif $(l)=~/\G(\s+)/gc
	    # skip
	#---- operator ----
	$elif $(l)=~/\G([=+\-\*\/%\^\&\|><\?,\.!~]+)/gc
	    $token=$1
	    $type="operator"
	$else
	    last

	#---------------------------------------- 
	check_exp_precedence:
	$if !@stack
	    $call exp_push, $token, $type
	$elif $type=~/^op/
	    $if $token eq "++" or $token eq "--"
		#---- postfix -----------------
		$call exp_pop, $exp
		$call exp_push, "$exp$token", "atom-exp"
	    $elif $token=~/^(.*)=$/
		#---- assignment --------------
		$assign=$token
		$if $left
		    $print $red Chained assignment not supported!
		$if !$1 and @stack==1 and $types[0] eq "atom-("
		    $left=substr($stack[0], 1, -1)
		    $call exp_pop, undef
		$else
		    $left=join("", @stack)
		    @stack=()
		    @types=()
	    $else
		#---- other op ----------------
		$call exp_push, $token, $type
	$elif $type=~/^atom/
	    $if $types[-1] =~/^op/
		$if $types[-2] !~/^atom/
		    #---- unary -------------
		    $call exp_pop, $op
		    $token=$op.$token
		    $type="atom-exp"
		    goto check_exp_precedence
		$else
		    #---- binary -------------
		    $if $stack[-1] eq ","
			$stack[-1]="$stack[-1] "
		    $else
			$stack[-1]=" $stack[-1] "
		    $call exp_push, $token, $type
	    $elif $types[-1] =~/^atom/
		$if $stack[-1]=~/\w$/
		    $stack[-1].=" $token"
		$else
		    $stack[-1].=$token
	    $else
		#---- open bracket ---------
		$call exp_push, $token, $type

subcode: check_exp_bracket
    my $close=$1
    my $open
    $if $close eq ')'
	$open='('
    $if $close eq ']'
	$open='['
    $if $close eq '}'
	$open='{'

    my $n=@stack
    my $found
    $for $i=$n:0
	$if $stack[$i] eq $open
	    $found=$i
	    break
    $if defined $found and $stack[$found] eq $open
	my $exp=join("", splice(@stack, $found+1))
	pop @stack
	splice(@types, $found)
	$if $types[-1] =~/^atom/ and $stack[-1]!~/^[0-9'"]/
	    $call exp_pop, $primary
	    my $processed
	    $type="atom-exp"
	    $if $open eq '('
		$call check_exp_fcall, $primary, $exp
	    $elif $open eq '['
		$call check_exp_subscript, $primary, $exp
	    $elif $open eq '{'
		$call check_exp_dict, $primary, $exp
	    $if !$processed
		$token=$primary.$open.$exp.$close
	$else
	    $token=$open.$exp.$close
	    $type="atom-$open"
    $else
	$print Error checking expression $(l), unbalanced brackets
	print join(" -- ", @stack), "\n"
	$token=join("", @stack)
	$type="atom-broken"

#---------------------------------------- 
subcode: check_exp_exponential
    $call exp_pop, undef
    $call exp_pop, $primary
    $token=$primary. (" * $primary" x ($token-1))
    $type="atom-exp"

subcode: check_exp_member
    $if $types[-1] =~/^op/ && $stack[-1] eq "." or $stack[-1] eq "->"
	$if $types[-2] !~/^atom/
	    #error
	$token=join("", splice(@stack, -2)).$token
	$type="atom-exp"
	splice(@types, -2)

subcode: check_exp_tuple_member
    $if $types[-2] !~/^atom/
	#error
    $token=join("", splice(@stack, -2))."a$token"
    $type="atom-exp"
    splice(@types, -2)

#---------------------------------------- 
subcode: check_exp_callsub
    $if $stack[-1] eq "." and $stack[-2]
	my $varname=$stack[-2]
	my $arg=$'
	&call if_lex, \((.*)\)
	    $arg=$2
	my $var=find_var($varname)
	$if $var->{class}
	    my $subname=$var->{class}."_".$method
	    my $call_line="$subname, $varname"
	    $arg=~s/^\s+//
	    $if length($arg)>0
		$call_line .= ", $arg"
	    undef $yield
	    MyDef::compileutil::call_sub($call_line)
	    $if $yield
		$call exp_pop, undef
		$call exp_pop, undef
		$call exp_push, $yield, "atom"
		last
	    $else
		return

#---------------------------------------- 
subcode: check_exp_fcall(primary, token)
    # print "fcall: $(primary)  $(token)\n"

subcode: check_exp_subscript(primary, token)
    # print "subscript: $(primary)  $(token)\n"
    $if $(token)<0
	my $var=find_var($(primary))
	$(token)=-$(token)
	# $print "$yellow$var: class: $var->{class}"
	$if $var and $var->{class}
	    $token="\$($var->{class}_index_negative:$(primary),$(token)\)"
	    MyDef::compileutil::expand_macro_recurse(\$token)
	    $type="atom"
	    $call exp_pop, undef
	    $call exp_pop, undef
	    $processed=1


subcode: check_exp_dict(primary, token)
    my $var=find_var($(primary))
    # $print "$yellow$var: class: $var->{class}"
    $if $var and $var->{class}
	my $call_line=$var->{class}."_lookup, $(primary), $(token)"
	undef $yield
	MyDef::compileutil::call_sub($call_line)
	$token=$yield
	$type="atom"
	$call exp_pop, undef
	$call exp_pop, undef
	$processed=1

#--------------------------------------
subcode: check_expression_parse_stack
    my @stack
    my @types

subcode: exp_push(exp, type)
    push @stack, $(exp)
    push @types, $(type)

subcode: exp_pop(assign)
    $(if:assign=undef)
	pop @stack
	pop @types
    $(else)
	my $(assign)=pop @stack
	pop @types

