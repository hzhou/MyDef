subcode:: parsecode_func_other
    $elif $func eq "yield"
	$global $yield
	$yield=$param
	return
    $elif $func eq "autolist"
	$global %function_autolist
	my @plist=MyDef::utils::proper_split($param)
	$foreach $name in @plist
	    $function_autolist{$name}=1
	return
    $elif $func eq "set_function_defaults"
	$global %function_defaults
	my @plist=MyDef::utils::proper_split($param)
	my $pattern=shift @plist
	$foreach $name in @plist
	    $function_defaults{$name}=$pattern
	return

subcode:: c_support_subs
    $sub check_expression($l, $context)
	#---- Note: if $l is already terminated with ';', it simply returns $l ----
	# $if $debug eq "expression"
	#     $print "check_expression: $l [$context]"
	$call @check_statement
	my ($assign, $left, $right)
	$call @check_expression_init
	$call check_expression_parse_stack
	$while 1
	    $call check_expression_parse, $l
	    $call check_expression_push
	$if @stack==1 and $types[0] eq "atom-("
	    $right=substr($stack[0], 1, -1)
	$else
	    $right=join("", @stack)

	$if $assign
	    $if $assign eq "="
		$if $context eq "condition"
		    $if $right!~/^\w+\(.*\)$/
			$call warn,  Assignment in [$left = $right], possible bug?
		    return "$left = $right"
		$else
		    do_assignment($left, $right)
		    return
	    $else
		$right= "$left $assign $right"
	$call process_expression_cache, $right
	return $right

subcode: check_statement
    $if $l=~/^return\b\s*(.*)/
	$if length($1)<=0
	    func_return()
	    return "return"
	$else
	    my $t=check_expression($1, $context)
	    func_return($t)
	    return "return $t"
    $elif $l=~/^\s*(if|for|while|switch)/
	# -- vanila C statement ---
	return $l

#---------------------------------------- 
subcode: check_expression_parse(l)
    my ($token, $type)
    $if $(l)=~/\G$/gc
	last
    #----  atom ------
    $elif $(l)=~/\G("([^"\\]|\\.)*")/gc
	$token=$1
	$type="atom-string"
    $elif $(l)=~/\G('([^'\\]|\\.)*')/gc
	$token=$1
	$type="atom-char"
    $elif $(l)=~/\G(\d+[eE]-?\d+|\d*\.\d+([eE]-?\d+)?)/gc
	$token=$1
	$type="atom-number-float"
	$if $types[-1] =~/^atom/ and $token=~/^\.(\d+)/
	    $token=$1
	    $call check_exp_tuple_member
    $elif $(l)=~/\G(\d[0-9a-zA-Z]*)/gc
	$token=$1
	$type="atom-number"
	$if $stack[-1] eq "^" and $token<10 and $token>1
	    $call check_exp_exponential
    $elif $(l)=~/\G(\w+)/gc
	$token=$1
	$type="atom-identifier"
	$call check_exp_member
    #---- special --------
    $elif $(l)=~/\G\$(\w+)/gc
	my $method=$1
	$if $method=~/^(eq|ne|le|ge|lt|gt)$/
	    $token=$1
	    $type="operator"
	$else
	    $call check_exp_callsub
    #----  bracket ------
    $elif $(l)=~/\G([\(\[\{])/gc
	$call exp_push, $1, undef
	next
    $elif $(l)=~/\G([\)\]\}])/gc
	$call check_exp_bracket
    #---- skip ----
    $elif $(l)=~/\G(\s+)/gc
	# skip
    #---- operator ----
    $elif $(l)=~/\G=~/gc
	$call check_exp_regex
    $elif $(l)=~/\G(=[=~]?)/gc
	$if $1 eq "=~"
	    $call check_exp_regex
	$else
	    $token=$1
	    $type="operator"
    $elif $(l)=~/\G([=+\-\*\/%\^\&\|><\?,\.!~:]+)/gc
	$token=$1
	$type="operator"
    $elif $(l)=~/\G;/
	#---- semicolon marks vanilla C statement ----
	return $l
    $else
	#---- comments? ------
	last

#---------------------------------------- 
subcode: check_expression_push
    check_exp_precedence:
    $if !@stack
	$call exp_push, $token, $type
    $elif $type=~/^op/
	$if $token eq "++" or $token eq "--"
	    #---- postfix -----------------
	    $call exp_pop, $exp
	    $call exp_push, "$exp$token", "atom-exp"
	$elif $token eq ":"
	    #---- label -----------------
	    $call exp_pop, $exp
	    $call exp_push, "$exp$token ", "atom-label"
	$elif $token=~/^(.*)=$/ and $1!~/^[!><=]$/
	    #---- assignment --------------
	    $assign=$token
	    $if $left
		$call warn,  Chained assignment not supported [left=$left, assign=$assign]!
	    $if !$1 and @stack==1 and $types[0] eq "atom-("
		$left=substr($stack[0], 1, -1)
		$call exp_pop, undef
	    $else
		$left=join("", @stack)
		@stack=()
		@types=()
	    $if $assign eq "="
		$call process_expression_cache, $left
	$else
	    #---- other op ----------------
	    $call exp_push, $token, $type
    $elif $type=~/^atom/
	$if $types[-1] =~/^op/
	    $if $types[-2] !~/^atom/
		#---- unary -------------
		$call exp_pop, $op
		$token=$op.$token
		$type="atom-exp"
		goto check_exp_precedence
	    $else
		#---- binary -------------
		$if $stack[-1] eq ","
		    $stack[-1]="$stack[-1] "
		$elif $stack[-1]=~/^(eq|ne|lt|le|gt|ge)$/
		    $call check_exp_string_op
		$elif $stack[-1]=~/^\S+$/
		    $stack[-1]=" $stack[-1] "
		$call exp_push, $token, $type
	$elif $types[-1] =~/^atom/
	    $if $stack[-1]=~/\w$/
		#---- e.g. unsigned int, struct something
		$stack[-1].=" $token"
	    $else
		$stack[-1].=$token
		$if $types[-1] eq "atom-("
		    #---- type cast ---- 
		    $types[-1] = "atom"
	$else
	    #---- open bracket ---------
	    $call exp_push, $token, $type

subcode: check_exp_bracket
    my $close=$1
    my $open
    $if $close eq ')'
	$open='('
    $if $close eq ']'
	$open='['
    $if $close eq '}'
	$open='{'

    my $n=@stack
    my $found
    $for $i=$n:0
	$if $stack[$i] eq $open
	    $found=$i
	    break
    $if defined $found and $stack[$found] eq $open
	my $exp=join("", splice(@stack, $found+1))
	pop @stack
	splice(@types, $found)
	$if $types[-1] =~/^atom/ and $stack[-1]!~/^[0-9'"]/
	    $call exp_pop, $primary
	    my $processed
	    $type="atom-exp"
	    $if $open eq '('
		$call check_exp_fcall, $primary, $exp
	    $elif $open eq '['
		$call check_exp_subscript, $primary, $exp
	    $elif $open eq '{'
		$call check_exp_dict, $primary, $exp
	    $if !$processed
		$token=$primary.$open.$exp.$close
		$if $open eq '['
		    $token=~s/ +//g
	$else
	    $token=$open.$exp.$close
	    $type="atom-$open"
    $else
	$call warn, Error checking expression $(l), unbalanced brackets
	print join(" -- ", @stack), "\n"
	$token=join("", @stack)
	$type="atom-broken"

#---------------------------------------- 
subcode: check_exp_exponential
    $call exp_pop, undef
    $call exp_pop, $primary
    $token=$primary. (" * $primary" x ($token-1))
    $type="atom-exp"

subcode: check_exp_member
    $if $types[-1] =~/^op/ && $stack[-1] eq "." or $stack[-1] eq "->"
	$if $types[-2] !~/^atom/
	    #error
	$token=join("", splice(@stack, -2)).$token
	$type="atom-exp"
	splice(@types, -2)

subcode: check_exp_tuple_member
    $call exp_pop, $primary
    $token="$primary.a$token"
    $type="atom-exp"

#---------------------------------------- 
subcode: check_exp_callsub
    $if $stack[-1] eq "." and $stack[-2]
	#---- darray.$push -----
	my $varname=$stack[-2]
	my $arg=$'
	&call if_lex, \((.*)\)
	    $arg=$1
	my $var=find_var($varname)
	$if $var->{class}
	    my $subname=$var->{class}."_".$method
	    my $call_line="$subname, $varname"
	    $arg=~s/^\s+//
	    $if length($arg)>0
		$call_line .= ", $arg"
	    $call exp_callsub
    $elif @stack==1 and $method eq "call"
	my $call_line= $'
	$call_line=~s/^\s*//
	$call exp_callsub

    $call warn, Method \$$method not defined
    $call exp_push, "\$$method", "atom-unknown"

subcode: exp_callsub
    undef $yield
    MyDef::compileutil::call_sub($call_line)
    $if $yield
	$call exp_pop, undef
	$call exp_pop, undef
	$call exp_push, $yield, "atom"
	last
    $else
	return

#---------------------------------------- 
subcode: check_exp_fcall(primary, token)
    # print "fcall: $(primary)  $(token)\n"
    $if $(primary)=~/^(sin|cos|tan|asin|acos|atan|atan2|exp|log|log10|pow|sqrt|ceil|floor|fabs)$/
	$includes{"<math.h>"}=1
	$objects{"libm"}=1
    $elif $(primary)=~/^(mem|str)[a-z]+$/
	$includes{"<string.h>"}=1
    $elif $(primary)=~/^(malloc|free)$/
	$includes{"<stdlib.h>"}=1
    $else
	$if $function_autolist{$(primary)}
	    $call check_autoload_h
	    $call add_list_function, $(primary)
	$if $function_defaults{$(primary)}
            #-- prepend: essentiall implements lexical function parameters
	    $if $function_defaults{$(primary)}=~/^prepend:(.*)/
		$if $(token) eq ""
		    $(token)=$1
		$else
		    $(token)=$1.",".$(token)
	    $elif $function_defaults{$(primary)}=~/^append:(.*)/
		$if $(token) eq ""
		    $(token)=$1
		$else
		    $(token)=$(token).",".$1
	    $else
		# Not Implemented

subcode: check_exp_subscript(primary, token)
    # print "subscript: $(primary)  $(token)\n"
    $if $(token)<0
	my $var=find_var($(primary))
	$if $var and $var->{dimension}
	    $token=$(primary).'['.$var->{dimension}."$(token)".']'
	    #$(token)=-$(token)
	    #$token="\$($var->{class}_index_negative:$(primary),$(token)\)"
	    #MyDef::compileutil::expand_macro_recurse(\$token)
	    $type="atom"
	    $call exp_pop, undef
	    $call exp_pop, undef
	    $processed=1


subcode: check_exp_dict(primary, token)
    $processed=1
    $token=$primary.$open.$exp.$close
    $cache{$token}=1

subcode:: check_expression_init
    #- %cache, for parsing hash: T{key}
    #--        such expression may involve sub call, 
    #--        so mulitiple invocation would be bad
    my %cache

subcode: process_expression_cache(t)
    $if %cache
	$foreach $t in keys %cache
	    $if $t=~/(\w+)\{(.*)\}/
		my ($t1, $t2)=($1, $2)
		my $var=find_var($t1)
		$if $var and $var->{class}
		    $(if:t=$left)
			my $call_line=$var->{class}."_lookup_left, $t1, $t2"
		    $(else)
			my $call_line=$var->{class}."_lookup, $t1, $t2"
		    undef $yield
		    MyDef::compileutil::call_sub($call_line)
		    my $pos=-1
		    my $len=length $t
		    $while ($pos=index($(t), $t, $pos))>-1
			substr($(t), $pos, $len)=$yield

#---------------------------------------- 
subcode: check_exp_string_op
    $call exp_pop, $op
    $call exp_pop, $exp
    my %str_op=(eq=>"==", ne=>"!=", lt=>"<", gt=>">", le=>"<=", ge=>">=")
    my $op=$str_op{$op}
    $if $type eq "atom-string"
	$if $token=~/^"(.*)"/
	    my $len=length($1)
	    $token= "strncmp($exp, $token, $len) $op 0"
	$else
	    $token= "strcmp($exp, $token) $op 0"
	$type="atom"
    $else
	my $var=find_var($token)
	$if $var and $var->{strlen}
	    $token="strncmp($exp, $token, $var->{strlen}) $op 0"
	    $type="atom"
	$else
	    $token="strcmp($exp, $token) $op 0"
	    $type="atom"

#---------------------------------------- 
subcode: check_exp_regex
    $if $types[-1] =~/^atom/
	$call exp_pop, $atom
	my $func="regex"
	my $pat
	$(set:pat=(?:[^\/\\]|\\.)*)
	$if $(l)=~/\G\s*(\/$(pat)\/\w*)/gc
	    $pat=$1
	$elif $(l)=~/\G\s*(s\/$(pat)\/$(pat)\/\w*)/gc
	    $pat=$1
	$else
	    $call warn, =~ missing regex pattern
	my $regex_plugin=$plugin_condition{regex}
	$if !$regex_plugin
	    $call warn, =~ missing regex plugin
	my $param="$atom=~$pat"
	# $print "$green regex $param"
	my $condition
	$call parsecode_run_eval, $regex_plugin
	$token=$condition
	$type="atom-regex"
    $else
	$call warn, =~ missing string variable

#--------------------------------------
subcode: check_expression_parse_stack
    my @stack
    my @types

subcode: exp_push(exp, type)
    push @stack, $(exp)
    push @types, $(type)

subcode: exp_pop(assign)
    $(if:assign=undef)
	pop @stack
	pop @types
    $(else)
	my $(assign)=pop @stack
	pop @types

