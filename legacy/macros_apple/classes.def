include: macros_util/tool_output.def

subcode:: package_global
    my %classes;
    my $cur_class;


# ---- New Class ----
subcode:: support_subs
    $global %classes, @class_list
    $global $cur_class
    $sub new_class($name, $tail)
	$call get_new_class_name
	# ----
	$if $classes{$new_class_name}
	    $cur_class=$classes{$new_class_name}
	    warn "Duplicate class [$new_class_name]\n"
	$else
	    $cur_class={name=>$new_class_name, super=>$name, protocols=>[], properties=>{}, methods=>[], declares=>[]}
	    $classes{$new_class_name} = $cur_class
	    push @class_list, $cur_class

	$call collect_class_field, $name
	$cur_class->{field}=$field
	# ----
	my $class=$field->{class};
	$if !$class
	    $class=$name;
	$cur_class->{interface}="$class";

	my $protocol=$field->{protocol};
	$call implement_protocol
	return $new_class_name

subcode: get_new_class_name
    my $new_class_name;
    $if $tail=~/,\s*(\w+)/
	$new_class_name=$1
    $elif $tail=~/,\s*_(\w+)/
	$new_class_name="$name\_$1"
    $else
	$new_class_name=$name

subcode: implement_protocol
    $if $protocol
	my $plist=$cur_class->{protocols}
	my $exist=0;
	$foreach my $p in @$plist
	    $if $p eq $protocol
		$exist=1;
	$if !$exist
	    push @$plist, $protocol;
	    res_collect($cur_class->{field}, $class_default->{$protocol})

# ---- New Method ----
subcode:: support_subs
    $sub new_method($name, $param)
	# --- as a function ---
	my $fidx=$(C)open_function($name, $param)
	my $func=MyDef::dumpout::get_function($fidx)
	$func->{"skip_declare"}=1

	# --- inherit the declaration
	my $declare
	my $method=$cur_class->{field}->{$name}
	$if !ref($method)
	    $declare=$method
	$else
	    $if $method->{declare}
		$declare=$method->{declare}
	    $else
		$declare=$method->{_name}
	$if $declare
	    $func->{declare}=$declare

	# --- member variables ---
	my $var_type=$func->{var_type};

	my $prop=$cur_class->{properties};
	$foreach $v in keys %$prop
	    $var_type->{$v}=$prop->{$v}

	push @{$cur_class->{methods}}, $fidx

	# ---- method block ---------------------------
	my $block=MyDef::compileutil::get_named_block("METHOD-$fidx")
	my $tempout=$MyDef::compileutil::out
	$MyDef::compileutil::out=$block
	$(Cout)=$block
	    push @$block, "OPEN_FUNC_$fidx";
	    push @$block, "SOURCE_INDENT"
	    # -- pre --
	    $call push_method_block, pre
	    # ---------- Method Block ------------------
	    push @$block, "BLOCK"
	    # -- post --
	    $call push_method_block, post
	    push @$block, "SOURCE_DEDENT"
	$MyDef::compileutil::out=$tempout
	$(Cout)=$tempout

	return $block

subcode: push_method_block(name)
    $if ref($method) eq "HASH" and $method->{$(name)}
	$if !ref($method->{$(name)})
	    MyDef::compileutil::parseblock([$method->{$(name)}])
	$else
	    MyDef::compileutil::parseblock($method->{$(name)}->{_list})

# ----
subcode: add_property(t, attr)
    my @plist=split /,\s*/, $(t);
    $foreach my $p in @plist
	$call get_name_type, $p
	$if $cur_class
	    $if $(attr)
		$cur_class->{properties}->{$name}="($(attr)) $type"
	    $else
		$cur_class->{properties}->{$name}=$type;
	    $call declare_var

subcode: get_name_type(t)
    my $name=$(t)
    my $type
    $if $(t)=~/(.*)\s+(\w+)$/
	$type=$1
	$name=$2
    $else
	$type=$(C)get_c_type($name)

subcode: declare_var
    $if $$(C)cur_function
	my $var_type=$$(C)cur_function->{var_type}
	$var_type->{$name}=$type
############################################
subcode:: on_init
    $global $class_default
    $class_default=$MyDef::def->{resource}->{"class_default"}
    $if !$class_default
	warn "resource: class_default not found!\n"

subcode: collect_class_field(name)
    my $field={}
    my $super_field=$class_default->{$(name)}
    $while $super_field
	res_collect($field, $super_field)
	$if $super_field->{super}
	    $super_field=$class_default->{$super_field->{super}}
	$else
	    undef $super_field
    res_collect($field, $class_default->{Default})

subcode:: support_subs
    $sub res_collect($field, $from)
	$if $from
	    $while my ($k, $v)=each %$from
		$if !$field->{$k}
		    $field->{$k}=$v
		$else
		    $if $k eq "imports"
			$field->{$k}="$v, $field->{$k}"

subcode:: support_subs
    my $animate_block_depth=0;
    my $animate_need_completion=0;

    my %viewitems;

    ############################################
    sub parse_animation_param {
	my $param=shift;
	my @plist=split /,\s*/, $param;
	if(@plist>1){
	    $animate_need_completion++;
	    my @options;
	    for(my $i=1; $i<@plist; $i++){
		push @options, "UIViewAnimationOption$plist[$i]";
	    }
	    $param="$plist[0] delay:0 options:".join('|', @options);

	}
	return $param;
    }

    sub nsstring {
	my $s=shift;
	if($s=~/^"(.*)"/){
	    return "@\"$1\"";
	}
	elsif($s =~/^nss_/){
	    return $s;
	}
	else{
	    return "@\"$s\"";
	}
    }
    sub nsnumber {
	my $s=shift;
	if($s=~/^\d/){
	    if($s=~/\./){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return "[NSNumber numberWithInt:$s]";
	    }
	}
	else{
	    my $type=get_c_type($s);
	    if($type =~/^int$/){
		return "[NSNumber numberWithInt:$s]";
	    }
	    elsif($type =~/^(float|double)$/){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return $s;
	    }
	}
    }
    # ---- GUI VIEW STUFF
    # -- loading custom config file. todo: Generilize into configfile.pm.
    sub load_view_config {
	my ($f, $itemhash)=@_;
	my $item;
	open In, $f or return;
	while(<In>){
	    if(/^#/){
	    }
	    elsif(/^(\w+)/){
		$item={};
		$itemhash->{$1}=$item;
	    }
	    elsif(/^\s+(\w+):\s*(.*)/){
		$item->{$1}=$2;
	    }
	}
	close In;
    }

    # ----
subcode: new_object(v, name, spec)
    #print "new: v=[$(v)], class=[$(name)], spec=[$(spec)]\n";
    my $class_field
    $if $classes{$(name)}
	$class_field=$classes{$(name)}->{field}
    $else
	$call collect_class_field, $(name)
	$class_field=$field

    my $class_name=$(name)
    $if $class_field->{class}
	$class_name=$class_field->{class}
    # ----
    $if $(v)!~/[.]/
	$(C)func_add_var($(v), "$class_name *");

    $if $class_field->{create_spec}
	my $init=$class_field->{create_spec}
	$init=~s/\$0/$class_name/
	$if $init=~/\$\@/
	    $init=~s/\$\@/$(spec)/
	$elif $init=~/\$2/
	    my @spec_list=split /,\s*/, $(spec)
	    $for $i=1:@spec_list
		$init=~s/\$$i/$spec_list[$i-1]/;
	$else
	    $init=~s/\$1/$(spec)/
	push @$(Cout), "$(v) = $init;"
    $else
	warn "class $class_name create_spec not found!\n"

    $if $class_field->{imports}
	my @inc_list=split /,\s*/, $class_field->{imports}
	$foreach $inc in @inc_list
	    $imports{$inc}=1
