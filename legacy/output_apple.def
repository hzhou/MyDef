include: output.def

# Goal: a general class interface for OOP languages
#       seperate implementations for ObjC

include: macros_apple/classes.def
#include: macros_apple/views.def

page: output_apple, inherit_c
    type: pm
    output_dir: lib/MyDef
    ext: m
    init_mode: sub
    package: MyDef::output_apple

subcode:: on_init
    $$(C)type_prefix{"obj"}="id"
    $$(C)global_type->{self}=1
    $global %imports
    $imports{"UIKit/UIKit.h"}=1

subcode: on_dumpout
    # ---- process_function ------------------------
    my $funclist=MyDef::dumpout::get_func_list()
    $foreach $func in @$funclist
        $if $func->{is_method}
            $call process_function_method
            $func->{processed}=1

    # ---- process classes ----
    my $block=MyDef::compileutil::get_named_block("global_init")
    $foreach $class in @class_list
        push @$block, "\@class $class->{name};";
    push @$block, "NEWLINE"

    $foreach $class in @class_list
        my $name=$class->{name}
        my $block=MyDef::compileutil::get_named_block("CLASS-$name")
        print "block CLASS-$name $block\n"
        my $class=$classes{$name}
        $call dump_class_interface, $block
        $call dump_class_implementation, $block

    # ---- imports -----------------------
    my @includes=keys %imports
    $foreach $i in keys %imports
        push @$f, "#import <$i>\n";
    push @$f, "\n";

##--------------------------------------------
subcode: on_parsecode
    $call translate_macros
    $call objc_parsecode

###################################################
subcode: dump_class_interface(block)
    my $interface=$class->{interface};
    $if $class->{protocols} and @{$class->{protocols}}
        my $plist=$class->{protocols}
        $interface.=" <".join(", ", @$plist).">";
    push @$(block), "// ---------- BEGIN CLASS $name -------------"
    push @$(block), "\@interface $name : $interface";


    # -- properties --
    $while my ($pname, $ptype)=each %{$class->{properties}}
        push @$(block), "    \@property $ptype $pname;";

    $foreach $fidx in @{$class->{methods}}
        my $func=MyDef::dumpout::get_function($fidx)
        push @$(block), "    $func->{declare};";

    push @$(block), "\@end";
    push @$(block), "NEWLINE";

subcode: dump_class_implementation(block)
    push @$(block), "\@implementation $name";
    push @$(block), "NEWLINE"
    $while my ($pname, $ptype)=each %{$class->{properties}}
        push @$(block), "\@synthesize $pname;";

    $foreach $fidx in @{$class->{methods}}
        my $func=MyDef::dumpout::get_function($fidx)
        push @$(block), "NEWLINE";
        push @$(block), "DUMP_STUB METHOD-$fidx"
        push @$(block), "NEWLINE";

    push @$(block), "\@end";
    push @$(block), "// ----------- END CLASS $name --------------"
    push @$(block), "NEWLINE";

###################################################
subcode: process_class

subcode: process_function_method
    $(C)process_function_std($func)

    my $declare=$func->{declare}
    $if !$declare
        my $name=$func->{"name"}
        my $ret_type=$func->{'ret_type'};
        $if !$ret_type
            $ret_type="void"
        $declare="- ($ret_type)"

        my $param_list=$func->{'param_list'};
        $if @$param_list
            my @tlist
            my @name_list=split /:/, $name
            $if $#$param_list==$#name_list
                $for $i=0:@name_list
                    $if $param_list->[$i]=~/(.*)\s(\W+)$/
                        push @tlist, "$name_list[$i]:($1)$2"
            $else
                $for $i=0:@name_list
                    $if $param_list->[$i]=~/(.*)\s(\W+)$/
                        push @tlist, "$name_list[$i]:($1)$2"
                $for $i=@name_list:@$param_list
                    $if $param_list->[$i]=~/(.*)\s(\W+)$/
                        push @tlist, "p$i:($1)$2"
            $declare.=join(' ', @tlist)
        $else
            $declare.=$name
        $func->{declare}=$declare

    $func->{openblock}=[$declare."{"]
    $func->{processed}=1

# -------------- Parsing --------------------------
subcode: objc_parsecode
    $if $l=~/^\$class\s+(\w+)(.*)/
        my $name=new_class($1, $2)
        push @$(Cout), "DUMP_STUB CLASS-$name"
        push @$(Cout), "BLOCK"
        push @$(Cout), "PARSE:\$class_end"
        return "NEWBLOCK"
    $elif $l=~/^\$class_end/
        undef $cur_class
        return
    $elsif $l=~/^\$implement\s+(\w+)/
        my $protocol=$1;
        $call implement_protocol
        return
    $elsif $l=~/^\$method\s+(\w+)\s*(.*)/
        my ($name, $tail)=($1, $2)
        $if $tail=~/^\((.*)\)/
            $tail=$1
        return new_method($name, $tail)
    $elif $l=~/^\$MakeController\s+(\w+)/
        create_controller($1)
        return 
    # -------------------------------------------------
    # ---- Properties
    $elsif $l=~/^\s*\$prop\s+(.*)/
        my ($t, $attr)=($1, undef)
        $call add_property, $t, $attr
        return
    $elsif $l=~/^\s*\$prop\((.*)\)\s+(.*)/
        my ($t, $attr)=($2, $1)
        $call add_property, $t, $attr
        return
    # ---- Properties
    $elsif $l=~/^\s*@(\w+)\s*=\s*(.*)/
        my $type=get_c_type($1);
        $if $cur_class
            $cur_class->{properties}->{$1}=$type;
            declare_var($1, $type);
        $l="$1 = $2";
    # ---- Properties
    $elsif $l=~/^\s*@(.*)\s+(\w+)\s*=\s*(.*)/
        my $type=$1;
        if($cur_class){
            $cur_class->{properties}->{$2}=$type;
            declare_var($2, $type);
        }
        $l="$2 = $3";
    ## ---- new -----------------------------------------------
    $elsif $l=~/^(\S+)\s*=\s*new (\w+)(.*)/
        my ($v, $name, $spec)=($1, $2, $3)
        $spec=~s/^,?\s*//
        $call new_object, $v, $name, $spec
        return
    # ---- foreach
    $elsif $l=~/^\s*\$foreach\s+(\w+)\s+in\s+(\w+)/
        func_add_var($1);
        return single_block("for($1 in $2){", "}")
    # ---- Object-C message syntax --------------------------------
    $elsif $l=~/^\s*([a-zA-Z0-9._]+)->(\w+)(\s*)(.*)/
        my ($obj, $mtd, $s, $t)=($1, $2, $3, $4);
        $if !$4
            push @$(Cout), "[$1 $2];";
            return;
        $else
            $if $s=~/\s/
                push @$(Cout), "[$obj $mtd:$t];";
                return;

###################################################################
subcode: translate_macros
    $if $l=~/(RGB|RCT|IMG|FILE|ARRAY|HASH|CSTRING)\((.*?)\)/
        my $pre=$`;
        my $post=$';
        my $fn=$1;
        my $param=$2;
        $if $fn eq "RGB"
            $call translate_macro_RGB
        $elsif $fn eq "RCT"
            $l=$pre."CGRectMake($param)".$post;
        $elsif $fn eq "IMG"
            my $t=nsstring($param);
            $l=$pre."[UIImage imageNamed:$t]".$post;
        $elsif $fn eq "FILE"
            $call translate_macro_FILE
        $elsif $fn eq "ARRAY"
            $call translate_macro_ARRAY
        $elsif $fn eq "HASH"
            $call translate_macro_HASH
        $elsif $fn eq "CSTRING"
            $l=$pre."(char *)[$param cStringUsingEncoding:NSASCIIStringEncoding]". $post;

subcode: translate_macro_RGB
    $if length($param)==6
        my ($r, $g, $b)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)));
        $l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:1]".$post;
    $elif length($param)==8
        my ($r, $g, $b, $a)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)), hex(substr($param, 6, 2)));
        $l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:$a/255.0]".$post;

subcode: translate_macro_FILE
    $if $param=~/(Documents|Library)\/(.*)/i
        my $dir;
        $if lc($1) eq "documents"
            $dir="NSDocumentDirectory";
        $elif lc($1) eq "library"
            $dir="NSLibraryDirectory";
        my $s=nsstring($2);
        $l=$pre."[[NSSearchPathForDirectoriesInDomains($dir, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:$s]".$post;
    $else
        my $s=nsstring($param);
        $l=$pre."[[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:$s]".$post;
subcode: translate_macro_ARRAY
    my @plist=split /, \s*/, $param;
    my @objs;
    foreach my $p(@plist){
        push @objs, nsnumber($p);
    }
    my $objlist=join(", ", @objs);
    $l=$pre."[NSArray arrayWithObjects: $objlist, nil]". $post;

subcode: translate_macro_HASH
    my @plist=split /,\s*/, $param;
    my @objs;
    my @keys;
    $foreach $p in @plist
        my ($key, $val)=split /=>/, $p;
        push @objs, $val;
        push @keys, "@\"$key\""
    my $objlist=join(", ", @objs);
    my $keylist=join(", ", @keys);
    $l=$pre."[NSDictionary dictionaryWithObjects:[arrayWithObjects $objlist, nil] forKeys:[arrayWithObjects $keylist, nil]]". $post;


############################################################
subcode: other_parse
    # -------------------------------------------------
    ## ---- add view
    $elsif $l=~/^\$addview\s+(.+)/
        my @tlist=split /,\s*/, $1;
        foreach my $v(@tlist){
            addview($out, $v);
        }
    ## ---- animation blocks --------------------------------------
    $elsif $l=~/^\$animate_begin\s+(.+)/
        $if $animate_block_depth!=0
            die "animate_block_depth=$animate_block_depth at \$animate_begin\n";
        $animate_block_depth=1;
        my $param=parse_animation_param($1);
        return single_block("[UIView animateWithDuration:$param animations:^{", "}")
    $elsif $l=~/^\$animate_next\s+(.+)/
        $if $animate_block_depth<=0
            die "Missing \$animate_begin?\n";
        $if $animate_need_completion>0
            $animate_need_completion--;
        $animate_block_depth++;
        my $param=parse_animation_param($1);
        return single_block("completion:^(BOOL finished){ [UIView animateWithDuration:$param animations:^{", "}")
    $elsif $l=~/^\$animate_complete/
        $if $animate_need_completion>0
            $animate_need_completion--;
        return single_block("completion:^(BOOL finished){", "}")
    $elsif $l=~/^\$animate_finish/
        $while $animate_block_depth>1
            push @$out, "]}";
            $animate_block_depth--;
        $if $animate_need_completion>0
            $animate_need_completion=0;
            push @$out, "completion:NULL";
        push @$out, "];";
        $animate_block_depth=0;
        return
