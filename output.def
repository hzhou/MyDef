include: macros_util/debug.def

subcode: output_main
    use MyDef::dumpout
    use MyDef::utils

    our $debug;
    our $mode;
    our $page;
    our $out;
    $call @package_globals

    $sub get_interface
	$(if:interface_type)
	    my $interface_type="$(interface_type)"
	$(else)
	    my $interface_type="general"
	return (\&init_page, \&parsecode, \&set_output, \&modeswitch, \&dumpout, $interface_type);

    $sub init_page
	($page)=@_;
	# ---- Set output file extension
	my $ext="$(ext)"
	$if $MyDef::var->{filetype}
	    $ext=$MyDef::var->{filetype}
	$if $page->{type}
	    $ext=$page->{type};
	$call @init_page
	$page->{pageext}=$ext 
	my $init_mode=$page->{init_mode}
	return ($ext, $init_mode)

    $sub set_output
	$out = shift

    # ---- www has php,  html and js mode ----------
    $sub modeswitch
	my ($mode, $in)=@_;
	$call @modeswitch

    # ---- All specialized parsing goes here.
    $sub parsecode
	my $l=shift;
	$if $debug eq "parse"
	    $call dump_line, parsecode
	$if $l=~/^DEBUG (\w+)/
	    $if $1 eq "OFF"
		$debug=0
	    $else
		$debug=$1
	    return
	$call parsecode_eval
	$call parsecode

    # ---- Final output, allows for 2nd pass translation
    $sub dumpout($f, $out, $pagetype)
	my $dump={out=>$out,f=>$f}
	$call @dumpout
	MyDef::dumpout::dumpout($dump);

    $call single_blocks
    $call @support_subs

    1;

# -------------------------
subcode: inherit_c
    use MyDef::output_c
    $(export:C=MyDef::output_c::)
    $(export:Cpage=$MyDef::output_c::page)
    $(export:Cout=$MyDef::output_c::out)

    $call @package_globals

    $sub get_interface
	return (\&init_page, \&parsecode, \&$(C)set_output, \&modeswitch, \&dumpout);

    $sub modeswitch($mode, $in)
	$call @on_modeswitch

    $sub init_page
	my ($page)=@_
	$if !$page->{type}
	    $page->{type}="$(ext)"
	my ($ext, $c_init_mode) = $(C)init_page(@_)
	$call @on_init
	return ($ext, "$(init_mode)");

    $sub parsecode($l)
	$call parsecode_eval
	$call @on_parsecode
	return $(C)parsecode($l)

    $sub dumpout($f, $out, $pagetype)
	$call @on_dumpout
	$(C)dumpout($f, $out, $pagetype)

    $call @support_subs

    1;

# -------------------------
subcode: parsecode
    push @$out, $l

subcode: parsecode_PRINT
    push @$out, $l
    return 0

subcode: parsecode_eval
    $case $l=~/^\$eval\s+(\w+)(.*)/
	my ($codename, $param)=($1, $2)
	$param=~s/^\s*,\s*//
	my $t=MyDef::compileutil::eval_sub($codename)
	#print "eval [$t]\n\n"
	eval $t
	$if $@
	    print "Error [$l]: $@\n"
	    print "  $t\n"
	return

subcode: parsecode_common
    # print "parsecode_common: input [$l]\n"
    $if $MyDef::compileutil::cur_mode eq "PRINT"
	$call @parsecode_PRINT
    $call @parsecode_special
    $elif $l=~/^\s*\$(\w+)\((.*?)\)\s+(.*)$/
	# $function(param1) param2 ---------------------------
	my ($func, $param1, $param2)=($1, $2, $3)
	$call parsecode_plugin
	$call parsecode_func_param
	$call parsecode_check_plugin
    $elif $l=~/^\s*\$(\w+)\s*(.*)$/
	# $function param  -----------------------------------
	my ($func, $param)=($1, $2)
	$if $param !~ /^=/
	    $call parsecode_func
	    $call parsecode_check_plugin

    $call @parsecode_other

    # print "parsecode_common: push out [$l]\n"
    push @$out, $l

subcode: single_blocks
    $sub single_block($t1, $t2)
	push @$out, "$t1";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "$t2";
	return "NEWBLOCK";

    $sub single_block_pre_post($pre, $post)
	$if $pre
	    push @$out, @$pre
	push @$out, "BLOCK";
	$if $post
	    push @$out, @$post
	return "NEWBLOCK";

# ------------------------------------------
subcode: debug_plugin
    $while my ($funcname, $codename)=each %plugin_statement
	print " plugin statement:  $funcname => $codename\n"
    $while my ($funcname, $codename)=each %plugin_condition
	print " plugin condition:  $funcname => $codename\n"

subcode: parsecode_plugin
    $global %plugin_statement
    $global %plugin_condition
    $case $func eq "plugin"
	$if $param2=~/_condition$/
	    $plugin_condition{$param1}=$param2
	$else
	    $plugin_statement{$param1}=$param2
	return

subcode: parsecode_run_eval
    my $codename=$plugin_statement{$func}
    my $t=MyDef::compileutil::eval_sub($codename)
    eval $t
    $if $@
	print "plugin - $func\n"
	print "[$t]\n"
	print "eval error: [$@]\n"

subcode: parsecode_check_plugin
    $if $plugin_statement{$func}
	$call parsecode_run_eval
	return

subcode: parse_condition_check_plugin
    $if $plugin_condition{$func}
	my $condition
	$call parsecode_run_eval
	return $condition

# -------------------------------------------
subcode: parse_condition_map
    my @args=MyDef::utils::proper_split($param)
    my $map=shift @args
    # print "map: [$map]\n"
    $if $map=~/\$map\((.*?),\s+(.*)\)/
	# print "map: sep [$1], template [$2]\n"
	my $sep=$1
	my $template=$2
	my @segs
	$foreach $a in @args
	    my $t=$template
	    $t=~s/\$1/$a/g
	    push @segs, $t
	return $pre . join($sep, @segs)
    $else
	return $pre . $param

# -------------------------------------------
subcode: case_reset
    $global @case_stack
    $global $case_state, $case_wrap
    @case_stack=()
    undef $case_state
    $if $case_wrap
	push @$out, @$case_wrap
	undef $case_wrap

subcode: case_push(state)
    push @$out, "PARSE:CASEPOP"
    push @case_stack, {state=>$(state), wrap=>$case_wrap}

    undef $case_state
    undef $case_wrap
    $call debug_case_push

subcode: case_pop
    $call debug_case_pop
    my $t_case=pop @case_stack
    $if $t_case
	$case_state=$t_case->{state}
	$case_wrap=$t_case->{wrap}

subcode: parsecode_case_support(if, elif, style)
    $global $case_if="$(if)", $case_elif="$(elif)"
    $global @case_stack
    $global $case_state, $case_wrap
    $call debug_case_l

    $if $l=~/^\$(if|elif|elsif|elseif|case)\s+(.*)$/
	my $cond=$2
	my $case
	$if $1 eq "if"
	    $if $case_wrap
		push @$out, @$case_wrap
		undef $case_wrap
	    $case=$case_if
	$elif $1 eq "case"
	    $if !$case_state
		$case=$case_if
	    $else
		$case=$case_elif
	$else
	    $case=$case_elif
	$(if:parse_condition)
	    $cond=parse_condition($cond)
	$call case_$(style)
	$call case_push, "if"
	return "NEWBLOCK"
    $elif $l=~/^\&case\s+(.*)/
	$if !$case_state
	    $call case_flag_if
	$else
	    $call case_flag_elif
	$call case_push, "if"
	return "NEWBLOCK"
    $elif $l=~/^\$else/
	$if !$case_state and $l!~/NoWarn/i
	    my $pos=MyDef::compileutil::curfile_curline()
	    print "[$pos]Dangling \$else \n"
	$call else_$(style)
	$call case_push, undef
	return "NEWBLOCK"
    $elif $l!~/^SUBBLOCK/
	undef $case_state
	$if $l eq "CASEPOP"
	    $call case_pop
	    return 0
	$elif $l=~/^CASEEXIT/
	    push @$out, $case_flag_reset
	    return 0

    $if $case_wrap and !$case_state
	push @$out, @$case_wrap
	undef $case_wrap

# -----
subcode: case_c_style
    push @$out, "$case($cond){"
    push @$out, "INDENT"
    push @$out, "BLOCK"
    push @$out, "DEDENT"
    push @$out, "}"

subcode: else_c_style
    push @$out, "else{"
    push @$out, "INDENT"
    push @$out, "BLOCK"
    push @$out, "DEDENT"
    push @$out, "}"

# -----
subcode: case_flag_if
    push @$out, $case_flag_set
    MyDef::compileutil::call_sub($1, "\$call")
    push @$out, "if($case_flag){"
    push @$out, "INDENT"
    push @$out, "BLOCK"
    push @$out, "DEDENT"
    push @$out, "}"

subcode: case_flag_elif
    push @$out, "else{"
    push @$out, "INDENT"
    push @$out, $case_flag_set
    MyDef::compileutil::call_sub($1, "\$call")
    push @$out, "if($case_flag){"
    push @$out, "INDENT"
    push @$out, "BLOCK"
    push @$out, "DEDENT"
    push @$out, "}"
    push @$out, "DEDENT"

    $if !$case_wrap
	$case_wrap=[]
    push @$case_wrap, "}"

subcode: case_flag_else
    push @$out, "else{"
    push @$out, "INDENT"
    push @$out, "BLOCK"
    push @$out, "DEDENT"
    push @$out, "}"

# -------------------------------------------
subcode: debug_case_push
    $if $debug eq "case"
	my $level=@case_stack
	print "Entering case [$level]: $l\n"
subcode: debug_case_pop
    $if $debug eq "case"
	my $level=@case_stack
	print "    Exit case [$level]\n"
subcode: debug_case_l
    $if $debug eq "case"
	my $level=@case_stack
	print "        $level:[$case_state]$l\n"

