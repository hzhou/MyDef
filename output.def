include: macros_util/debug.def

subcode: output_main
    use MyDef::dumpout;

    our $debug;
    our $mode;
    our $page;
    our $out;
    $call @package_globals

    $sub get_interface
	return (\&init_page, \&parsecode, \&set_output, \&modeswitch, \&dumpout);

    $sub init_page
	($page)=@_;
	# ---- Set output file extension
	my $ext=$page->{ext}
	$if $page->{type}
	    $ext=$page->{type};
	$call @init_page
	$page->{pageext}=$ext 
	my $init_mode=$page->{init_mode}
	return ($ext, $init_mode)

    $sub set_output
	$out = shift

    # ---- www has php,  html and js mode ----------
    $sub modeswitch
	my ($mode, $in)=@_;
	$call @modeswitch

    # ---- All specialized parsing goes here.
    $sub parsecode
	my $l=shift;
	$if $debug eq "parse"
	    $call dump_line, parsecode
	$if $l=~/^DEBUG (\w+)/
	    $if $1 eq "OFF"
		$debug=0
	    $else
		$debug=$1
	    return
	$elif $l=~/^NOOP/
	    return
	$call parsecode

    # ---- Final output, allows for 2nd pass translation
    $sub dumpout
	my $f;
	($f, $out)=@_;
	my $dump={out=>$out,f=>$f}
	$call @dumpout
	MyDef::dumpout::dumpout($dump);

    $call single_blocks
    $call @support_subs

    1;

# -------------------------
subcode: inherit_c
    use MyDef::output_c
    $(export:C=MyDef::output_c::)
    $(export:Cpage=$MyDef::output_c::page)
    $(export:Cout=$MyDef::output_c::out)

    $call @package_globals

    $sub get_interface
	return (\&init_page, \&parsecode, \&$(C)set_output, \&modeswitch, \&dumpout);

    $sub modeswitch($mode, $in)
	$call @on_modeswitch

    $sub init_page
	my ($page)=@_
	$if !$page->{type}
	    $page->{type}="$(ext)"
	my ($ext, $c_init_mode) = $(C)init_page(@_)
	$call @on_init
	return ($ext, "$(init_mode)");

    $sub parsecode($l)
	$call on_parsecode
	return $(C)parsecode($l)

    $sub dumpout($f, $out)
	$call @on_dumpout
	$(C)dumpout($f, $out)

    $call @support_subs

    1;

# -------------------------
subcode: parsecode
    push @$out, $l

subcode: parsecode_common
    my $should_return=1
    $call parsecode_special
    $elif $l=~/^\s*\$(\w+)\((.*)\)\s+(.*)$/
	# $function(param1) param2 ---------------------------
	my ($func, $param1, $param2)=($1, $2, $3)
	$call parsecode_func_param
    $elif $l=~/^\s*\$(\w+)\s*(.*)$/
	# $function param  -----------------------------------
	my ($func, $param)=($1, $2)
	$call parsecode_func
    $else
	$should_return=0

    $if $should_return
	return

subcode: single_blocks
    $sub single_block($t1, $t2)
	push @$out, "$t1";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "$t2";
	return "NEWBLOCK";

    $sub single_block_pre_post($pre, $post)
	$if $pre
	    $foreach my $l in @$pre
		push @$out, $l
	push @$out, "BLOCK";
	$if $post
	    $foreach my $l in @$post
		push @$out, $l
	return "NEWBLOCK";

    $sub case_push
	$case_stack[$case_level]=2
	push @case_stack, 1
	$case_level++
    $sub case_pop
	$if $case_level>1
	    pop @case_stack
	    $case_level--
    $sub case_block($t)
	$if $t=~/^case(.*)/
	    $if $case_stack[$case_level]==0
		$t="$case_if$1"
	    $else
		$t="$case_elif$1"
	case_push()
	push @$out, "$t\{";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "}";
	return "NEWBLOCK-CASEPOP";

subcode: parsecode_case_support(if, elif)
    $global @case_stack=(1), $case_level=0
    $global $case_if="$(if)", $case_elif="$(elif)"
    $if $l eq "CASEPOP"
	case_pop()
	return 0
    $elif $l!~/^SUBBLOCK/ and $case_stack[$case_level]>0
	$case_stack[$case_level]--

    print "[$l]\n"
    print "    case_stack level=$case_level, $case_stack[$case_level]\n"

