include: output.def

page: output_general, output_main
    type: pm
    output_dir: lib/MyDef
    ext: txt
    init_mode: sub

page: output_perl, output_main
    type: pm
    output_dir: lib/MyDef
    ext: pl
    init_mode: sub
    subcode: modeswitch
	$if $mode=~/(\w+)-(.*)/
	    my $fname=$1;
	    my $t=$2;
	    my $openblock=[];
	    my $closeblock=[];
	    my $preblock=[];
	    my $postblock=[];
	    my $func={openblock=>$openblock, closeblock=>$closeblock, preblock=>$preblock, postblock=>$postblock};
	    push @$openblock, "sub $fname {";
	    $if $t
		push @$preblock, "my ($t)=\@_;";
	    push @$closeblock, "}";
	    my $fidx=MyDef::dumpout::add_function($func);
	    push @$out, "OPEN_FUNC_$fidx";
    subcode: parsecode
	$if $l=~/^\s*\$(\w+)\s*(.*)$/
	    my $func=$1;
	    my $param=$2;
	    $if $func =~ /^(if|while)$/
		return single_block("$1($param)", $out);
	    $elif $func =~ /^(el|els|else)if$/
		return single_block("elsif($param)", $out);
	    $elif $func eq "else"
		return single_block("else", $out);
	    $elif $func eq "sub"
		return single_block("sub $param ", $out)
	    $elif $func eq "for" or $func eq "foreach"
		$if $param=~/(\$\w+)=(.*?):(.*?)(:.*)?$/
		    my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
		    my $stepclause;
		    $if $step
			my $t=substr($step, 1);
			$if $t eq "-1"
			    $stepclause="my $var=$i0;$var>$i1;$var--";
			$elif $t=~/^-/
			    $stepclause="my $var=$i0;$var>$i1;$var=$var$t";
			$else
			    $stepclause="my $var=$i0;$var<$i1;$var+=$t";
		    $else
			$stepclause="my $var=$i0;$var<$i1;$var++";
		    return single_block("for($stepclause)", $out);
		$elif $param=~/(\$\w+) in (.*)/
		    my ($var, $list)=($1, $2);
		    return single_block("foreach my $var ($list)", $out)
	    $else
		check_termination(\$l);
		push @$out, $l;
	$else
	    check_termination(\$l);
	    push @$out, $l;
	return 0;
    subcode: dumpout
	my $pagetype=$MyDef::page->{type}
	$if !defined $pagetype or $pagetype eq "pl"
	    push @$f, "#!/usr/bin/perl\n"
    subcode: support_subs
	$sub single_block
	    my ($t, $out)=@_;
	    push @$out, "$t\{";
	    push @$out, "INDENT";
	    push @$out, "BLOCK";
	    push @$out, "DEDENT";
	    push @$out, "}";
	    return "NEWBLOCK";
	$sub check_termination 
	    my $l=shift;
	    #$$l=~s/^\|//;
	    if($$l=~/^\s*$/){
	    }
	    elsif($$l=~/(for|while|if|else if)\s*\(.*\)\s*$/){
	    }
	    elsif($$l=~/^\s*}/){
		# Check the formal blockend
		# Inline blocks will get ; appended.
	    }
	    elsif($$l!~/[,:\(\[\{;]\s*$/){
		#print "[$$l]appending ;\n";
		$$l.=";";
	    }
	    else{
		#print "[$$l]\n";
	    }

