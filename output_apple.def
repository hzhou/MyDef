include: output.def
include: macros_c/cfunctions.def
include: macros_apple/classes.def
include: macros_apple/views.def

page: output_apple, output_main
    type: pm
    output_dir: lib/MyDef
    ext: m
    init_mode: sub
    subcode: package_subs
	$call package_global
	$call apple_functions
	$call c_main
    subcode: init_page
	$call c_init
	register_type_prefix("obj", "id")
	$global_type->{self}=1
	$class_default=$MyDef::def->{resource}->{"class_default"}
    subcode: modeswitch
	$call c_modeswitch
    subcode: parsecode
	$call translate_macros
	$call objc_parsecode
	$call c_parsecode
    subcode: dumpout
	# ----  Main Function -------------------
	my $func=$functions{"main"};
	$if $func
	    $func->{skip_declare}=1;
	    $func->{ret_type}="int";
	    $func->{param_list}=["int argc", "char** argv"];
	    $func->{init}=["DUMP_STUB main_init"];
	    $func->{finish}=["DUMP_STUB main_exit", "return 0;"];
	# ---- process_function ------------------------
	my $funclist=MyDef::dumpout::get_func_list()
	$foreach my $func in @$funclist
	    $call process_function_std

	# ---- process views ----
	$call process_views

	my $block=MyDef::compileutil::get_named_block("global_init")
	# ---- dump classes ----
	my @class_list = sort keys %classes;
	$foreach my $name in @class_list
	    push @$block, "\@class $name;";
	push @$block, "NEWLINE"
	$foreach my $name in @class_list
	    my $class=$classes{$name}
	    $call dump_class_interface, $block
	$foreach my $name in @class_list
	    my $class=$classes{$name}
	    $call dump_class_implementation, $block

	# ----
	$while my ($k, $v)=each %method_hash
	    $dump->{$k}=$v
	# ---- c global stuff -----------------------
	$call objc_dump_includes
	unshift @$out, "DUMP_STUB global_init";
	$call c_dump_init

subcode:: package_global
    my %view_hash;
    my %imports=("UIKit/UIKit.h"=>1);

subcode: objc_dump_includes
    my @includes=keys %imports;
    foreach my $i (@includes){
	push @$f, "#import <$i>\n";
    }
    push @$f, "\n";

# -------------- Parsing --------------------------
subcode: objc_parsecode
    $if $l=~/^\$MakeController\s+(\w+)/
	create_controller($1)
	return 
    $elif $l=~/^\$subclass\s+(\w+)(.*)/
	new_class($1, $2)
	return
    $elsif $l=~/^\$implement\s+(\w+)/
	my $protocol=$1;
	$call implement_protocol
	return
    $elsif $l=~/^\$method\s+(\w+)(.*)/
	my ($name, $tail)=($1, $2)
	$call new_method, $name, BLOCK
	return \@method_block;
    # -------------------------------------------------
    # ---- Properties
    $elsif $l=~/^\s*\$prop\s+(.*)/
	my ($t, $attr)=($1, undef)
	$call add_property, $t, $attr
	return
    $elsif $l=~/^\s*\$prop\((.*)\)\s+(.*)/
	my ($t, $attr)=($2, $1)
	$call add_property, $t, $attr
	return
    # ---- Properties
    $elsif $l=~/^\s*@(\w+)\s*=\s*(.*)/
	my $type=get_c_type($1);
	$if $cur_class
	    $cur_class->{properties}->{$1}=$type;
	    declare_var($1, $type);
	$l="$1 = $2";
    # ---- Properties
    $elsif $l=~/^\s*@(.*)\s+(\w+)\s*=\s*(.*)/
	my $type=$1;
	if($cur_class){
	    $cur_class->{properties}->{$2}=$type;
	    declare_var($2, $type);
	}
	$l="$2 = $3";
    ## ---- add view
    $elsif $l=~/^\$addview\s+(.+)/
	my @tlist=split /,\s*/, $1;
	foreach my $v(@tlist){
	    addview($out, $v);
	}
    ## ---- animation blocks --------------------------------------
    $elsif $l=~/^\$animate_begin\s+(.+)/
	if($animate_block_depth!=0){
	    die "animate_block_depth=$animate_block_depth at \$animate_begin\n";
	}
	$animate_block_depth=1;
	my $param=parse_animation_param($1);
	return single_block("[UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_next\s+(.+)/
	if($animate_block_depth<=0){
	    die "Missing \$animate_begin?\n";
	}
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	$animate_block_depth++;
	my $param=parse_animation_param($1);
	return single_block("completion:^(BOOL finished){ [UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_complete/
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	return single_block("completion:^(BOOL finished)", $out);
    $elsif $l=~/^\$animate_finish/
	while($animate_block_depth>1){
	    push @$out, "]}";
	    $animate_block_depth--;
	}
	if($animate_need_completion>0){
	    $animate_need_completion=0;
	    push @$out, "completion:NULL";
	}
	push @$out, "];";
	$animate_block_depth=0;
	return
    ## ---- new -----------------------------------------------
    $elsif $l=~/^(\S+)\s*=\s*new (\w+)(.*)/
	new_object($out, $1, $2, $3);
	return
    # ---- foreach
    $elsif $l=~/^\s*\$foreach\s+(\w+)\s+in\s+(\w+)/
	func_add_var($1);
	return single_block("for($1 in $2)", $out);
    # ---- Object-C message syntax --------------------------------
    $elsif $l=~/^\s*([a-zA-Z0-9._]+)->(\w+)(\s*)(.*)/
	$if !$4
	    push @$out, "[$1 $2];";
	    return;
	$else
	    my ($obj, $mtd, $s, $t)=($1, $2, $3, $4);
	    $if $s=~/\s/
		push @$out, "[$obj $mtd:$t];";
		return;

###################################################################
subcode: translate_macros
    $if $l=~/(RGB|RCT|IMG|FILE|ARRAY|HASH|CSTRING)\((.*?)\)/
	my $pre=$`;
	my $post=$';
	my $fn=$1;
	my $param=$2;
	$if $fn eq "RGB"
	    $call translate_macro_RGB
	$elsif $fn eq "RCT"
	    $l=$pre."CGRectMake($param)".$post;
	$elsif $fn eq "IMG"
	    my $t=nsstring($param);
	    $l=$pre."[UIImage imageNamed:$t]".$post;
	$elsif $fn eq "FILE"
	    $call translate_macro_FILE
	$elsif $fn eq "ARRAY"
	    $call translate_macro_ARRAY
	$elsif $fn eq "HASH"
	    $call translate_macro_HASH
	$elsif $fn eq "CSTRING"
	    $l=$pre."(char *)[$param cStringUsingEncoding:NSASCIIStringEncoding]". $post;

subcode: translate_macro_RGB
    $if length($param)==6
	my ($r, $g, $b)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)));
	$l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:1]".$post;
    $elif length($param)==8
	my ($r, $g, $b, $a)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)), hex(substr($param, 6, 2)));
	$l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:$a/255.0]".$post;

subcode: translate_macro_FILE
    $if $param=~/(Documents|Library)\/(.*)/i
	my $dir;
	$if lc($1) eq "documents"
	    $dir="NSDocumentDirectory";
	$elif lc($1) eq "library"
	    $dir="NSLibraryDirectory";
	my $s=nsstring($2);
	$l=$pre."[[NSSearchPathForDirectoriesInDomains($dir, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:$s]".$post;
    $else
	my $s=nsstring($param);
	$l=$pre."[[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:$s]".$post;
subcode: translate_macro_ARRAY
    my @plist=split /, \s*/, $param;
    my @objs;
    foreach my $p(@plist){
	push @objs, nsnumber($p);
    }
    my $objlist=join(", ", @objs);
    $l=$pre."[NSArray arrayWithObjects: $objlist, nil]". $post;

subcode: translate_macro_HASH
    my @plist=split /,\s*/, $param;
    my @objs;
    my @keys;
    foreach my $p(@plist){
	my ($key, $val)=split /=>/, $p;
	push @objs, $val;
	push @keys, "@\"$keys\"";
    }
    my $objlist=join(", ", @objs);
    my $keylist=join(", ", @keys);
    $l=$pre."[NSDictionary dictionaryWithObjects:[arrayWithObjects $objlist, nil] forKeys:[arrayWithObjects $keylist, nil]]". $post;

