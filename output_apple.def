include: output.def
include: macros_c/cfunctions.def
include: macros_apple/classes.def
include: macros_apple/views.def

page: output_apple, output_main
    type: pm
    output_dir: lib/MyDef
    ext: m
    init_mode: sub
    subcode: package_subs
	$call package_global
	$call apple_functions
	$call c_main
    subcode: init_page
	$call c_init
    subcode: modeswitch
	$call c_modeswitch
    subcode: parsecode
	$call translate_macros
	$call objc_parsecode
	$call c_parsecode
    subcode: dumpout
	# ----  Main Function -------------------
	my $func=$functions{"main"};
	$if $func
	    $func->{skip_declare}=1;
	    $func->{ret_type}="int";
	    $func->{param_list}=["int argc", "char** argv"];
	    $func->{init}=["DUMP_STUB main_init"];
	    $func->{finish}=["DUMP_STUB main_exit", "return 0;"];
	# ---- process_function ------------------------
	my $funclist=MyDef::dumpout::get_func_list()
	$foreach my $func in @$funclist
	    $call process_function_std

	# ---- process views ----
	$call process_views
	# ---- process_class ------------------------
	my @class_list
	$while my ($name, $class)=each %classes
	    my @class_block;
	    $dump->{"class_$name"}=\@class_block
	    $call process_class
	my $block=MyDef::compileutil::get_named_block("global_init")
	$foreach my $class in @class_list
	    push @$block, "class $class;";
	push @$block, "NEWLINE"
	$foreach my $class in @class_list
	    push @$block, "INCLUDE_BLOCK class_$class"
	    push @$block, "NEWLINE"

	# ---- c global stuff -----------------------
	$call objc_dump_includes
	unshift @$out, "DUMP_STUB global_init";
	$call c_dump_init

subcode:: package_global
    my %view_hash;
    my %imports=("UIKit/UIKit.h"=>1);
    my %classes;
    my $cur_class;

subcode: objc_dump_includes
    my @includes=keys %imports;
    foreach my $i (@includes){
	push @$f, "#import <$i>\n";
    }
    push @$f, "\n";

# -------------- Parsing --------------------------
subcode: objc_parsecode
    $if $l=~/^\$subclass\s+(\w+)(.*)/
	my ($name, $tail)=($1, $2)
	$call new_class
	return
    $elsif $l=~/^\$implement\s+(\w+)/
	my $protocol=$1;
	$call implement_protocol
	return
    $elsif $l=~/^\$method\s+(\w+)(.*)/
	my ($name, $tail)=($1, $2)
	my @method_block;
	$call new_method
	return \@method_block;
    # -------------------------------------------------
    # ---- Properties
    $elsif $l=~/^\s*\$prop\s+(.*)/
	my ($t, $attr)=($1, undef)
	$call add_property
	return
    $elsif $l=~/^\s*\$prop\((.*)\)\s+(.*)/
	my ($t, $attr)=($2, $1)
	$call add_property
	return
    # ---- Properties
    $elsif $l=~/^\s*@(\w+)\s*=\s*(.*)/
	my $type=get_c_type($1);
	$if $cur_class
	    $cur_class->{properties}->{$1}=$type;
	    declare_var($1, $type);
	$l="$1 = $2";
    # ---- Properties
    $elsif $l=~/^\s*@(.*)\s+(\w+)\s*=\s*(.*)/
	my $type=$1;
	if($cur_class){
	    $cur_class->{properties}->{$2}=$type;
	    declare_var($2, $type);
	}
	$l="$2 = $3";
    ## ---- add view
    $elsif $l=~/^\$addview\s+(.+)/
	my @tlist=split /,\s*/, $1;
	foreach my $v(@tlist){
	    addview($out, $v);
	}
    ## ---- animation blocks --------------------------------------
    $elsif $l=~/^\$animate_begin\s+(.+)/
	if($animate_block_depth!=0){
	    die "animate_block_depth=$animate_block_depth at \$animate_begin\n";
	}
	$animate_block_depth=1;
	my $param=parse_animation_param($1);
	return single_block("[UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_next\s+(.+)/
	if($animate_block_depth<=0){
	    die "Missing \$animate_begin?\n";
	}
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	$animate_block_depth++;
	my $param=parse_animation_param($1);
	return single_block("completion:^(BOOL finished){ [UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_complete/
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	return single_block("completion:^(BOOL finished)", $out);
    $elsif $l=~/^\$animate_finish/
	while($animate_block_depth>1){
	    push @$out, "]}";
	    $animate_block_depth--;
	}
	if($animate_need_completion>0){
	    $animate_need_completion=0;
	    push @$out, "completion:NULL";
	}
	push @$out, "];";
	$animate_block_depth=0;
	return
    ## ---- new -----------------------------------------------
    $elsif $l=~/^(\S+)\s*=\s*new (\w+)(.*)/
	new_object($out, $1, $2, $3);
	return
    # ---- foreach
    $elsif $l=~/^\s*\$foreach\s+(\w+)\s+in\s+(\w+)/
	func_add_var($1);
	return single_block("for($1 in $2)", $out);
    # ---- Object-C message syntax --------------------------------
    $elsif $l=~/^\s*([a-zA-Z0-9._]+)->(\w+)(\s*)(.*)/
	# -- Control Target-Action
	if($2 eq "action"){
	    my $control=$1;
	    my ($object, $method)=split /,\s+/, $4;
	    my $event="UIControlEventTouchUpInside";
	    if($control=~/^button/){
		$event="UIControlEventTouchUpInside";
	    }
	    push @$out, "[$control addTarget:$object action:\@selector($method) forControlEvents:$event];";
	    return;
	}
	elsif(!$4){
	    push @$out, "[$1 $2];";
	    return;
	}
	else{
	    my ($obj, $mtd, $s, $t)=($1, $2, $3, $4);
	    if($s=~/\s/){
		push @$out, "[$obj $mtd:$t];";
		return;
	    }
	}

