include: output.def
include: macros_c/cfunctions.def

page: output_apple, output_main
    type: pm
    output_dir: lib/MyDef
    ext: m
    init_mode: sub
    subcode: package_subs
	$call apple_functions
	$call c_main
    subcode: init_page
	$call c_init
    subcode: modeswitch
	$call c_modeswitch
    subcode: parsecode
	$call translate_macros
	$call objc_parsecode
	$call c_parsecode
    subcode: dumpout
	$call c_main_function
	# ---- process_function ------------------------
	my $funclist=MyDef::dumpout::get_func_list()
	$foreach my $func in @$funclist
	    $call process_function_std
	# ---- process_class ------------------------
	$while my ($name, $class)=each %classes
	    my @class_block;
	    $dump->{"class_$name"}=\@class_block
	    $call process_class
	# ---- c global stuff -----------------------
	$call objc_dump_includes
	$call c_dump_init

subcode: process_class
    my $interface=$class->{interface};
    $if $class->{protocols}
	$interface.=" <".$class->{protocols}.">";
    push @class_block, "\@interface $name : $interface";
    $while my ($pname, $ptype)=each %{$class->{properties}}
	push @class_block, "\@property $ptype $pname;";
    $foreach my $declare in @{$class->{declares}}
	push @class_block, "$declare;";
    push @class_block, "\@end";
    push @class_block, "NEWLINE";
    push @class_block, "\@implementation $name";
    $while my ($pname, $ptype)=each %{$class->{properties}}
	push @class_block, "\@synthesize $pname;";
    $foreach my $method in @{$class->{methods}}
	push @class_block, "NEWLINE";
	$foreach my $t in @$method
	    push @class_block, $t;
	push @class_block, "NEWLINE";
    push @class_block, "\@end";
    push @class_block, "NEWLINE";

subcode: objc_dump_includes
    my @includes=keys %imports;
    foreach my $i (@includes){
	push @$f, "#import <$i>\n";
    }
    push @$f, "\n";

# -------------- Parsing --------------------------
subcode: objc_parsecode
    $if $l=~/^\$subclass\s+(\w+)(.*)/
	my ($name, $tail)=($1, $2)
	$call new_class
	push @$out, "INCLUDE_BLOCK class_$newclass"
	return
    $elsif $l=~/^\$implement\s+(\w+)/
	my $protocol=$1;
	$call implement_protocol
	return
    $elsif $l=~/^\$method\s+(\w+)(.*)/
	my ($name, $tail)=($1, $2)
	my @method_block;
	$call new_method
	return \@method_block;
    # -------------------------------------------------
    # ---- Properties
    $elsif $l=~/^\s*\$prop\s+(.*)/
	my ($t, $attr)=($1, undef)
	$call add_property
	return
    $elsif $l=~/^\s*\$prop\((.*)\)\s+(.*)/
	my ($t, $attr)=($2, $1)
	$call add_property
	return
    # ---- Properties
    $elsif $l=~/^\s*@(\w+)\s*=\s*(.*)/
	my $type=get_c_type($1);
	$if $cur_class
	    $cur_class->{properties}->{$1}=$type;
	    declare_var($1, $type);
	$l="$1 = $2";
    # ---- Properties
    $elsif $l=~/^\s*@(.*)\s+(\w+)\s*=\s*(.*)/
	my $type=$1;
	if($cur_class){
	    $cur_class->{properties}->{$2}=$type;
	    declare_var($2, $type);
	}
	$l="$2 = $3";
    ## ---- add view
    $elsif $l=~/^\$addview\s+(.+)/
	my @tlist=split /,\s*/, $1;
	foreach my $v(@tlist){
	    addview($out, $v);
	}
    ## ---- animation blocks --------------------------------------
    $elsif $l=~/^\$animate_begin\s+(.+)/
	if($animate_block_depth!=0){
	    die "animate_block_depth=$animate_block_depth at \$animate_begin\n";
	}
	$animate_block_depth=1;
	my $param=parse_animation_param($1);
	return single_block("[UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_next\s+(.+)/
	if($animate_block_depth<=0){
	    die "Missing \$animate_begin?\n";
	}
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	$animate_block_depth++;
	my $param=parse_animation_param($1);
	return single_block("completion:^(BOOL finished){ [UIView animateWithDuration:$param animations:^", $out);
    $elsif $l=~/^\$animate_complete/
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	return single_block("completion:^(BOOL finished)", $out);
    $elsif $l=~/^\$animate_finish/
	while($animate_block_depth>1){
	    push @$out, "]}";
	    $animate_block_depth--;
	}
	if($animate_need_completion>0){
	    $animate_need_completion=0;
	    push @$out, "completion:NULL";
	}
	push @$out, "];";
	$animate_block_depth=0;
	return
    ## ---- new -----------------------------------------------
    $elsif $l=~/^(\S+)\s*=\s*new (\w+)(.*)/
	new_object($out, $1, $2, $3);
	return
    # ---- foreach
    $elsif $l=~/^\s*\$foreach\s+(\w+)\s+in\s+(\w+)/
	func_add_var($1);
	return single_block("for($1 in $2)", $out);
    # ---- Object-C message syntax --------------------------------
    $elsif $l=~/^\s*([a-zA-Z0-9._]+)->(\w+)(\s*)(.*)/
	# -- Control Target-Action
	if($2 eq "action"){
	    my $control=$1;
	    my ($object, $method)=split /,\s+/, $4;
	    my $event="UIControlEventTouchUpInside";
	    if($control=~/^button/){
		$event="UIControlEventTouchUpInside";
	    }
	    push @$out, "[$control addTarget:$object action:\@selector($method) forControlEvents:$event];";
	    return;
	}
	elsif(!$4){
	    push @$out, "[$1 $2];";
	    return;
	}
	else{
	    my ($obj, $mtd, $s, $t)=($1, $2, $3, $4);
	    if($s=~/\s/){
		push @$out, "[$obj $mtd:$t];";
		return;
	    }
	}

# --------------------
subcode: new_class
    my $newclass;
    $if $tail=~/,\s*(\w+)/
	$newclass=$1
    $elif $tail=~/,\s*_(\w+)/
	$newclass="$name\_$1"
    $else
	$newclass=$name
    # ----
    $cur_class={super=>$name, protocols=>"", name=>$newclass, properties=>{}, declares=>[], methods=>[]};
    $cur_class->{field}=$MyDef::def->{fields}->{$name};
    $classes{$newclass} = $cur_class
    # ----
    $if my $field=$cur_class->{field}
	my $class=$field->{class};
	my $protocol=$field->{protocol};
	$if !$class
	    $class=$name;
	$cur_class->{interface}="$class";
	$if $protocol
	    $cur_class->{protocols}=$protocol;
    $else
	$cur_class->{interface}=$name;

subcode: implement_protocol
    my @plist=split /,\s+/, $cur_class->{protocols};
    my $exist=0;
    $foreach my $p in @plist
	$if $p eq $protocol
	    $exist=1;
    $if !$exist
	push @plist, $protocol;
	$cur_class->{protocols}=join(", ", @plist);

subcode: new_method
    my $declare=find_class_field($cur_class->{field}, $name);
    $if !$declare
	$if $name=~/^\w+_/
	    my $ret_type=get_c_type($name);
	    $declare="- ($ret_type)$name";
	$else
	    $declare="- (void)$name";
    $if $tail=~/^\((.*)\)/
	my @plist=split /,\s*/, $1;
	for(my $i=0; $i<@plist; $i++){
	    my $type=get_c_type($plist[$i]);
	    $if $i>0
		$declare.=" p$i";
	    $declare.=":($type)$plist[$i]";
	}

    my $fidx=open_closure("$declare {", "}");
    my $prop=$cur_class->{properties};
    foreach my $v (keys %$prop){
	declare_var($v, $prop->{$v});
    }
    push @method_block, "OPEN_FUNC_$fidx";
    push @method_block, "SOURCE_INDENT";
    if(my $d=find_class_field($cur_class->{field}, "$name\_pre")){
	if($d!~/^CALL/ and $d!=~/;\s*$/){$d.=";";}
	push @method_block, $d;
    }
    push @method_block, "BLOCK";
    if(my $d=find_class_field($cur_class->{field}, "$name\_post")){
	if($d!~/^CALL/ and $d!=~/;\s*$/){$d.=";";}
	push @method_block, $d;
    }
    push @method_block, "SOURCE_DEDENT";
    push @{$cur_class->{methods}}, \@method_block;
    push @{$cur_class->{declares}}, $declare;

subcode: add_property
    my @plist=split /,\s*/, $t;
    $foreach my $p in @plist
	my ($type, $name)=get_name_type($p)
	$if $cur_class
	    $if $attr
		$cur_class->{properties}->{$name}="($attr) $type"
	    $else
		$cur_class->{properties}->{$name}=$type;
	    declare_var($name, $type);
###################################################################
subcode: translate_macros
    $if $l=~/(RGB|RCT|IMG|FILE|ARRAY|HASH|CSTRING)\((.*?)\)/
	my $pre=$`;
	my $post=$';
	my $fn=$1;
	my $param=$2;
	$if $fn eq "RGB"
	    $call translate_macro_RGB
	$elsif $fn eq "RCT"
	    $l=$pre."CGRectMake($param)".$post;
	$elsif $fn eq "IMG"
	    my $t=nsstring($param);
	    $l=$pre."[UIImage imageNamed:$t]".$post;
	$elsif $fn eq "FILE"
	    $call translate_macro_FILE
	$elsif $fn eq "ARRAY"
	    $call translate_macro_ARRAY
	$elsif $fn eq "HASH"
	    $call translate_macro_HASH
	$elsif $fn eq "CSTRING"
	    $l=$pre."(char *)[$param cStringUsingEncoding:NSASCIIStringEncoding]". $post;

subcode: translate_macro_RGB
    $if length($param)==6
	my ($r, $g, $b)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)));
	$l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:1]".$post;
    $elif length($param)==8
	my ($r, $g, $b, $a)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)), hex(substr($param, 6, 2)));
	$l=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:$a/255.0]".$post;

subcode: translate_macro_FILE
    $if $param=~/(Documents|Library)\/(.*)/i
	my $dir;
	$if lc($1) eq "documents"
	    $dir="NSDocumentDirectory";
	$elif lc($1) eq "library"
	    $dir="NSLibraryDirectory";
	my $s=nsstring($2);
	$l=$pre."[[NSSearchPathForDirectoriesInDomains($dir, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:$s]".$post;
    $else
	my $s=nsstring($param);
	$l=$pre."[[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:$s]".$post;
subcode: translate_macro_ARRAY
    my @plist=split /, \s*/, $param;
    my @objs;
    foreach my $p(@plist){
	push @objs, nsnumber($p);
    }
    my $objlist=join(", ", @objs);
    $l=$pre."[NSArray arrayWithObjects: $objlist, nil]". $post;

subcode: translate_macro_HASH
    my @plist=split /,\s*/, $param;
    my @objs;
    my @keys;
    foreach my $p(@plist){
	my ($key, $val)=split /=>/, $p;
	push @objs, $val;
	push @keys, "@\"$keys\"";
    }
    my $objlist=join(", ", @objs);
    my $keylist=join(", ", @keys);
    $l=$pre."[NSDictionary dictionaryWithObjects:[arrayWithObjects $objlist, nil] forKeys:[arrayWithObjects $keylist, nil]]". $post;

############################################

subcode: apple_functions
    my $animate_block_depth=0;
    my $animate_need_completion=0;

    my %viewitems;

    my %imports=("UIKit/UIKit.h"=>1);
    my %classes;
    my $cur_class;

    sub find_class_field {
	my ($field, $name, $level)=@_;
	if(!$field){
	    return undef;
	}
	elsif($field->{$name}){
	    return $field->{$name};
	}
	else{
	    if($field->{super}){
		my $declare=find_class_field($MyDef::def->{fields}->{$field->{super}, $name, $level+1});
		if($declare){return $declare;}
	    }
	    if(!$level and $cur_class->{protocols}){
		my @plist=split /,\s+/, $cur_class->{protocols};
		foreach my $p(@plist){
		    my $declare=find_class_field($MyDef::def->{fields}->{$p}, $name, $level+1);
		    if($declare){return $declare;}
		}
	    }
	    if(!$level){
		my $declare=find_class_field($MyDef::def->{fields}->{"Default"}, $name, $level+1);
		if($declare){return $declare;}
	    }
	    return undef;
	}
    }

    sub custom_types {
    }
    ############################################
    sub parse_animation_param {
	my $param=shift;
	my @plist=split /,\s*/, $param;
	if(@plist>1){
	    $animate_need_completion++;
	    my @options;
	    for(my $i=1; $i<@plist; $i++){
		push @options, "UIViewAnimationOption$plist[$i]";
	    }
	    $param="$plist[0] delay:0 options:".join('|', @options);

	}
	return $param;
    }

    sub newclass_spec {
	my ($init, $spec)=@_;
	if($init=~/\$2/){
	    my @speclist=split /,\s*/, $spec;
	    for(my $i=1; $i-1<@speclist; $i++){
		$init=~s/\$$i/$speclist[$i-1]/;
	    }
	}
	else{
	    $init=~s/\$1/$spec/;
	}
	return $init;
    }

    sub nsstring {
	my $s=shift;
	if($s=~/^"(.*)"/){
	    return "@\"$1\"";
	}
	elsif($s =~/^nss_/){
	    return $s;
	}
	else{
	    return "@\"$s\"";
	}
    }
    sub nsnumber {
	my $s=shift;
	if($s=~/^\d/){
	    if($s=~/\./){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return "[NSNumber numberWithInt:$s]";
	    }
	}
	else{
	    my $type=get_c_type($s);
	    if($type =~/^int$/){
		return "[NSNumber numberWithInt:$s]";
	    }
	    elsif($type =~/^(float|double)$/){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return $s;
	    }
	}
    }
    # ---- GUI VIEW STUFF
    # -- loading custom config file. todo: Generilize into configfile.pm.
    sub load_view_config {
	my ($f, $itemhash)=@_;
	my $item;
	open In, $f or return;
	while(<In>){
	    if(/^#/){
	    }
	    elsif(/^(\w+)/){
		$item={};
		$itemhash->{$1}=$item;
	    }
	    elsif(/^\s+(\w+):\s*(.*)/){
		$item->{$1}=$2;
	    }
	}
	close In;
    }

    sub addview {
	my ($out, $name, $parent)=@_;
	if(!$viewitems{$name}){
	    warn "Missing layout item $name\n";
	}
	my $main=$viewitems{"main"};
	my $v=$viewitems{$name};
	my $type=$v->{type}?$v->{type}:"UIView";
	my $x=$v->{x};
	my $y=$v->{y};
	my $w=$v->{width};
	my $h=$v->{height};

	new_object($out, $name, $type, "CGRectMake($x, $y, $w, $h)"); 
	if($v->{background}){
	    if($v->{background}=~/\.png/){
		push @$out, "$name.backgroundColor=[UIColor colorWithPatternImage:[UIImage ImageNamed:@\"$v->{background}\"]]";
	    }
	    elsif($v->{background}=~/#(..)(..)(..)(..)/){
		push @$out, "$name.backgroundColor=[UIColor colorWithRed:$1/255.0 green:$2/255.0 blue:$3/255.0 alpha:$4/255.0]";
	    }
	}
	if(!$parent){
	    push @$out, "self.view = $view";
	}
	else{
	    push @$out, "[$parent addSubview:$name]";
	}
	if($v->{children}){
	    my @tlist=split /,\s*/, $v->{children};
	    foreach my $t (@tlist){
		addview($out, $t, $name);
	    }
	}

    }
    # ----
    $sub new_object
	my ($out, $v, $class, $spec)=@_;
	$spec=~s/^,?\s*//;
	#print "new: v=[$v], class=[$class], spec=[$spec]\n";
	my $init="init";
	my $field;
	$if $classes{$class}
	    $field=$MyDef::def->{fields}->{$classes{$class}->{super}};
	$else
	    $field=$MyDef::def->{fields}->{$class};
	    $if $field->{class}
		$class=$field->{class};
	# ----
	if($v=~/^@(.*)/){
	    $v=$1;
	    $cur_class->{properties}->{$1}="$class *";
	}
	elsif($v!~/[.]/){
	    func_add_var($v, "$class *");
	}
	if($field->{create_spec}){
	    my $create=newclass_spec($field->{create_spec}, $spec);
	    push @$out, "$v = [$class $create];";
	}
	else{
	    if(!$spec){
		while($field){
		    if($field->{init_default}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		if($field){
		    $init=$field->{init_default};
		}
	    }
	    else{
		while($field){
		    if($field->{init_spec}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		#print "init_spec: $field->{init_spec}\n";
		if($field){
		    $init=newclass_spec($field->{init_spec}, $spec);
		}
		else{
		    $init=$spec;
		}
	    }
	    push @$out, "$v = [[$class alloc] $init];";
	}
	# -- specific classes --
	$if $class=~/EAGLContext/
	    $imports{"QuartzCore/QuartzCore.h"}=1;
	    $imports{"OpenGLES/EAGL.h"}=1;
	    $if $init=~/OpenGLES1/
		$imports{"OpenGLES/ES1/gl.h"}=1;
		$imports{"OpenGLES/ES1/glext.h"}=1;
	    $if $init=~/OpenGLES2/
		$imports{"OpenGLES/ES2/gl.h"}=1;
		$imports{"OpenGLES/ES2/glext.h"}=1;
