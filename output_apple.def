include: output.def

page: output_apple
    type: pm
    output_dir: lib/MyDef
    ext: m
    subcode: main
	use MyDef::cfunctions;
	$call apple_functions
	$call output_main
    subcode: init_page
	MyDef::cfunctions::init();
    subcode: modeswitch
	MyDef::cfunctions::modeswitch($pmode, $mode, $out);
    subcode: parsecode
	translate_macros(\$l);
	$call parsecode_object_c
	MyDef::cfunctions::parsecode($l, undef, $out);
    subcode: dumpout
	MyDef::cfunctions::process_function(MyDef::dumpout::get_func_list());
	dump_includes($f)
	MyDef::cfunctions::dump_init($f);
    subcode: custom_dump
	$if $$rl =~ /CLASS (\w+)/
	    my $name=$1;
	    my @t;
	    $class=$classes{$name};
	    my $interface=$class->{interface};
	    if($class->{protocols}){
		$interface.=" <".$class->{protocols}.">";
	    }
	    push @t, "\@interface $name : $interface {";
	    while(my ($pname, $ptype)=each %{$class->{properties}}){
		push @t, "    $ptype $pname;";
	    }
	    push @t, "}";
	    foreach my $declare (@{$class->{declares}}){
		push @t, "$declare;";
	    }
	    push @t, "\@end";
	    push @t, "NEWLINE";
	    push @t, "\@implementation $name";
	    foreach my $method (@{$class->{methods}}){
		push @t, "NEWLINE";
		foreach my $t(@$method){
		    push @t, $t;
		}
		push @t, "NEWLINE";
	    }
	    push @t, "\@end";
	    push @t, "NEWLINE";
	    return \@t;

subcode: parsecode_object_c
    if($l=~/^\$subclass\s+(\w+),\s*(\w+)/){
	my $name=$1;
	my $subname=$2;
	my $newname=new_class($name, $subname);
	push @$out, "CLASS $newname";
	return;
    }
    elsif($l=~/^\$implement\s+(\w+)/){
	my $prot=$1;
	my @plist=split /,\s+/, $cur_class->{protocols};
	my $exist=0;
	foreach my $p(@plist){
	    if($p eq $prot){
		$exist=1;
	    }
	}
	if(!$exist){
	    push @plist, $prot;
	    $cur_class->{protocols}=join(", ", @plist);
	}
    }
    elsif($l=~/^\$method\s+(\w+)/){
	my $name=$1;
	my $tail=$';
	my @t;
	my $declare=find_class_field($cur_class->{field}, $name);
	if(!$declare){
	    if($name=~/^\w+_/){
		my $ret_type=MyDef::cfunctions::get_c_type($name);
		$declare="- ($ret_type)$name";
	    }
	    else{
		$declare="- (void)$name";
	    }
	}
	if($tail=~/^\((.*)\)/){
	    my @plist=split /,\s*/, $1;
	    for(my $i=0; $i<@plist; $i++){
		my $type=MyDef::cfunctions::get_c_type($plist[$i]);
		if($i>0){
		    $declare.=" p$i";
		}
		$declare.=":($type)$plist[$i]";
	    }
	}

	my $fidx=MyDef::cfunctions::open_closure("$declare {", "}");
	my $prop=$cur_class->{properties};
	foreach my $v (keys %$prop){
	    MyDef::cfunctions::declare_var($v, $prop->{$v});
	}
	push @t, "OPEN_FUNC_$fidx";
	push @t, "SOURCE_INDENT";
	if(my $d=find_class_field($cur_class->{field}, "$name\_pre")){
	    if($d!~/^CALL/ and $d!=~/;\s*$/){$d.=";";}
	    push @t, $d;
	}
	push @t, "BLOCK";
	if(my $d=find_class_field($cur_class->{field}, "$name\_post")){
	    if($d!~/^CALL/ and $d!=~/;\s*$/){$d.=";";}
	    push @t, $d;
	}
	push @t, "SOURCE_DEDENT";
	push @{$cur_class->{methods}}, \@t;
	push @{$cur_class->{declares}}, $declare;
	return \@t;
    }
    ## ---- add view
    elsif($l=~/^\$addview\s+(.+)/){
	my @tlist=split /,\s*/, $1;
	foreach my $v(@tlist){
	    addview($out, $v);
	}
    }
    ## ---- animation blocks ------------------------------------------
    elsif($l=~/^\$animate_begin\s+(.+)/){
	if($animate_block_depth!=0){
	    die "animate_block_depth=$animate_block_depth at \$animate_begin\n";
	}
	$animate_block_depth=1;
	my $param=parse_animation_param($1);
	return MyDef::cfunctions::single_block("[UIView animateWithDuration:$param animations:^", $out);
    }
    elsif($l=~/^\$animate_next\s+(.+)/){
	if($animate_block_depth<=0){
	    die "Missing \$animate_begin?\n";
	}
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	$animate_block_depth++;
	my $param=parse_animation_param($1);
	return MyDef::cfunctions::single_block("completion:^(BOOL finished){ [UIView animateWithDuration:$param animations:^", $out);
    }
    elsif($l=~/^\$animate_complete/){
	if($animate_need_completion>0){
	    $animate_need_completion--;
	}
	return MyDef::cfunctions::single_block("completion:^(BOOL finished)", $out);
    }
    elsif($l=~/^\$animate_finish/){
	while($animate_block_depth>1){
	    push @$out, "]}";
	    $animate_block_depth--;
	}
	if($animate_need_completion>0){
	    $animate_need_completion=0;
	    push @$out, "completion:NULL";
	}
	push @$out, "];";
	$animate_block_depth=0;
	return;
    }
    ## ---- new -----------------------------------------------
    elsif($l=~/^(\S+)\s*=\s*new (\w+)(.*)/){
	new_object($out, $1, $2, $3);
	return;
    }
    # ---- foreach
    elsif($l=~/^\s*\$foreach\s+(\w+)\s+in\s+(\w+)/){
	MyDef::cfunctions::func_add_var($1);
	return MyDef::cfunctions::single_block("for($1 in $2)", $out);
    }
    # ---- Properties
    elsif($l=~/^\s*\$prop\s+(.*)/){
	my @plist=split /,\s*/, $1;
	foreach my $p(@plist){
	    my $type=MyDef::cfunctions::get_c_type($p);
	    if($cur_class){
		$cur_class->{properties}->{$p}=$type;
		MyDef::cfunctions::declare_var($p, $type);
	    }
	}
    }
    # ---- Properties
    elsif($l=~/^\s*@(\w+)\s*=\s*(.*)/){
	my $type=MyDef::cfunctions::get_c_type($1);
	if($cur_class){
	    $cur_class->{properties}->{$1}=$type;
	    MyDef::cfunctions::declare_var($1, $type);
	}
	$l="$1 = $2";
    }
    # ---- Properties
    elsif($l=~/^\s*@(.*)\s+(\w+)\s*=\s*(.*)/){
	my $type=$1;
	if($cur_class){
	    $cur_class->{properties}->{$2}=$type;
	    MyDef::cfunctions::declare_var($2, $type);
	}
	$l="$2 = $3";
    }
    # ---- Object-C message syntax --------------------------------
    elsif($l=~/^\s*([a-zA-Z0-9._]+)->(\w+)(\s*)(.*)/){
	# -- Control Target-Action
	if($2 eq "action"){
	    my $control=$1;
	    my ($object, $method)=split /,\s+/, $4;
	    my $event="UIControlEventTouchUpInside";
	    if($control=~/^button/){
		$event="UIControlEventTouchUpInside";
	    }
	    push @$out, "[$control addTarget:$object action:\@selector($method) forControlEvents:$event];";
	    return;
	}
	elsif(!$4){
	    push @$out, "[$1 $2];";
	    return;
	}
	else{
	    my ($obj, $mtd, $s, $t)=($1, $2, $3, $4);
	    if($s=~/\s/){
		push @$out, "[$obj $mtd:$t];";
		return;
	    }
	}
    }
subcode: apple_functions
    ############################################
    my $animate_block_depth=0;
    my $animate_need_completion=0;

    ############################################
    my %viewitems;

    ############################################
    my %includes=("UIKit/UIKit.h"=>1);
    my %classes;
    my $cur_class;

    sub new_class {
	my ($name, $subname)=@_;
	my $newname="$subname";
	if(substr($subname, 0, 1) eq "_"){
	    $newname="$name$subname";
	}
	$classes{$newname}={super=>$name, protocols=>"", name=>$newname, properties=>{}, declares=>[], methods=>[]};
	$cur_class=$classes{$newname};
	$cur_class->{field}=$MyDef::def->{fields}->{$name};
	if(my $field=$cur_class->{field}){
	    my $class=$field->{class};
	    my $protocol=$field->{protocol};
	    if(!$class){
		$class=$name;
	    }
	    $cur_class->{interface}="$class";
	    if($protocol){
		$cur_class->{protocols}=$protocol;
	    }
	}
	else{
	    $cur_class->{interface}=$name;
	}
	return $newname;
    }

    sub find_class_field {
	my ($field, $name, $level)=@_;
	if(!$field){
	    return undef;
	}
	elsif($field->{$name}){
	    return $field->{$name};
	}
	else{
	    if($field->{super}){
		my $declare=find_class_field($MyDef::def->{fields}->{$field->{super}, $name, $level+1});
		if($declare){return $declare;}
	    }
	    if(!$level and $cur_class->{protocols}){
		my @plist=split /,\s+/, $cur_class->{protocols};
		foreach my $p(@plist){
		    my $declare=find_class_field($MyDef::def->{fields}->{$p}, $name, $level+1);
		    if($declare){return $declare;}
		}
	    }
	    if(!$level){
		my $declare=find_class_field($MyDef::def->{fields}->{"Default"}, $name, $level+1);
		if($declare){return $declare;}
	    }
	    return undef;
	}
    }

    sub custom_types {
    }
    ############################################
    sub parse_animation_param {
	my $param=shift;
	my @plist=split /,\s*/, $param;
	if(@plist>1){
	    $animate_need_completion++;
	    my @options;
	    for(my $i=1; $i<@plist; $i++){
		push @options, "UIViewAnimationOption$plist[$i]";
	    }
	    $param="$plist[0] delay:0 options:".join('|', @options);

	}
	return $param;
    }

    sub newclass_spec {
	my ($init, $spec)=@_;
	if($init=~/\$2/){
	    my @speclist=split /,\s*/, $spec;
	    for(my $i=1; $i-1<@speclist; $i++){
		$init=~s/\$$i/$speclist[$i-1]/;
	    }
	}
	else{
	    $init=~s/\$1/$spec/;
	}
	return $init;
    }

    sub nsstring {
	my $s=shift;
	if($s=~/^"(.*)"/){
	    return "@\"$1\"";
	}
	elsif($s =~/^nss_/){
	    return $s;
	}
	else{
	    return "@\"$s\"";
	}
    }
    sub nsnumber {
	my $s=shift;
	if($s=~/^\d/){
	    if($s=~/\./){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return "[NSNumber numberWithInt:$s]";
	    }
	}
	else{
	    my $type=MyDef::cfunctions::get_c_type($s);
	    if($type =~/^int$/){
		return "[NSNumber numberWithInt:$s]";
	    }
	    elsif($type =~/^(float|double)$/){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return $s;
	    }
	}
    }
    sub translate_macros {
	my $rl=shift;
	if($$rl=~/(RGB|RCT|IMG|FILE|ARRAY|HASH|CSTRING)\((.*?)\)/){
	    my $pre=$`;
	    my $post=$';
	    my $fn=$1;
	    my $param=$2;
	    if($fn eq "RGB"){
		if(length($param)==6){
		    my ($r, $g, $b)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)));
		    $$rl=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:1]".$post;
		}
		elsif(length($param)==8){
		    my ($r, $g, $b, $a)=(hex(substr($param, 0, 2)), hex(substr($param, 2, 2)), hex(substr($param, 4, 2)), hex(substr($param, 6, 2)));
		    $$rl=$pre."[UIColor colorWithRed:$r/255.0 green:$g/255.0 blue:$b/255.0 alpha:$a/255.0]".$post;
		}
	    }
	    elsif($fn eq "RCT"){
		$$rl=$pre."CGRectMake($param)".$post;
	    }
	    elsif($fn eq "IMG"){
		my $t=nsstring($param);
		$$rl=$pre."[UIImage imageNamed:$t]".$post;
	    }
	    elsif($fn eq "FILE"){
		if($param=~/(Documents|Library)\/(.*)/i){
		    my $dir;
		    if(lc($1) eq "documents"){
			$dir="NSDocumentDirectory";
		    }
		    elsif(lc($1) eq "library"){
			$dir="NSLibraryDirectory";
		    }
		    my $s=nsstring($2);
		    $$rl=$pre."[[NSSearchPathForDirectoriesInDomains($dir, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:$s]".$post;
		}
		else{
		    my $s=nsstring($param);
		    $$rl=$pre."[[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:$s]".$post;
		}
	    }
	    elsif($fn eq "ARRAY"){
		my @plist=split /, \s*/, $param;
		my @objs;
		foreach my $p(@plist){
		    push @objs, nsnumber($p);
		}
		my $objlist=join(", ", @objs);
		$$rl=$pre."[NSArray arrayWithObjects: $objlist, nil]". $post;
	    }
	    elsif($fn eq "HASH"){
		my @plist=split /,\s*/, $param;
		my @objs;
		my @keys;
		foreach my $p(@plist){
		    my ($key, $val)=split /=>/, $p;
		    push @objs, $val;
		    push @keys, "@\"$keys\"";
		}
		my $objlist=join(", ", @objs);
		my $keylist=join(", ", @keys);
		$$rl=$pre."[NSDictionary dictionaryWithObjects:[arrayWithObjects $objlist, nil] forKeys:[arrayWithObjects $keylist, nil]]". $post;
	    }
	    elsif($fn eq "CSTRING"){
		$$rl=$pre."(char *)[$param cStringUsingEncoding:NSASCIIStringEncoding]". $post;
	    }
	}
    }

    # ---- GUI VIEW STUFF
    # -- loading custom config file. todo: Generilize into configfile.pm.
    sub load_view_config {
	my ($f, $itemhash)=@_;
	my $item;
	open In, $f or return;
	while(<In>){
	    if(/^#/){
	    }
	    elsif(/^(\w+)/){
		$item={};
		$itemhash->{$1}=$item;
	    }
	    elsif(/^\s+(\w+):\s*(.*)/){
		$item->{$1}=$2;
	    }
	}
	close In;
    }

    sub addview {
	my ($out, $name, $parent)=@_;
	if(!$viewitems{$name}){
	    warn "Missing layout item $name\n";
	}
	my $main=$viewitems{"main"};
	my $v=$viewitems{$name};
	my $type=$v->{type}?$v->{type}:"UIView";
	my $x=$v->{x};
	my $y=$v->{y};
	my $w=$v->{width};
	my $h=$v->{height};

	new_object($out, $name, $type, "CGRectMake($x, $y, $w, $h)"); 
	if($v->{background}){
	    if($v->{background}=~/\.png/){
		push @$out, "$name.backgroundColor=[UIColor colorWithPatternImage:[UIImage ImageNamed:@\"$v->{background}\"]]";
	    }
	    elsif($v->{background}=~/#(..)(..)(..)(..)/){
		push @$out, "$name.backgroundColor=[UIColor colorWithRed:$1/255.0 green:$2/255.0 blue:$3/255.0 alpha:$4/255.0]";
	    }
	}
	if(!$parent){
	    push @$out, "self.view = $view";
	}
	else{
	    push @$out, "[$parent addSubview:$name]";
	}
	if($v->{children}){
	    my @tlist=split /,\s*/, $v->{children};
	    foreach my $t (@tlist){
		addview($out, $t, $name);
	    }
	}

    }
    # ----
    sub new_object {
	my ($out, $v, $class, $spec)=@_;
	$spec=~s/^,?\s*//;
	#print "new: v=[$v], class=[$class], spec=[$spec]\n";
	my $init="init";
	my $field;
	if($classes{$class}){
	    $field=$MyDef::def->{fields}->{$classes{$class}->{super}};
	}
	else{
	    $field=$MyDef::def->{fields}->{$class};
	    if($field->{class}){
		$class=$field->{class};
	    }
	}
	# ----
	if($v=~/^@(.*)/){
	    $v=$1;
	    $cur_class->{properties}->{$1}="$class *";
	}
	elsif($v!~/[.]/){
	    MyDef::cfunctions::func_add_var($v, "$class *");
	}
	if($field->{create_spec}){
	    my $create=newclass_spec($field->{create_spec}, $spec);
	    push @$out, "$v = [$class $create];";
	}
	else{
	    if(!$spec){
		while($field){
		    if($field->{init_default}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		if($field){
		    $init=$field->{init_default};
		}
	    }
	    else{
		while($field){
		    if($field->{init_spec}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		#print "init_spec: $field->{init_spec}\n";
		if($field){
		    $init=newclass_spec($field->{init_spec}, $spec);
		}
		else{
		    $init=$spec;
		}
	    }
	    push @$out, "$v = [[$class alloc] $init];";
	}
	if($class=~/EAGLContext/){
	    $includes{"QuartzCore/QuartzCore.h"}=1;
	    $includes{"OpenGLES/EAGL.h"}=1;
	    if($init=~/OpenGLES1/){
		$includes{"OpenGLES/ES1/gl.h"}=1;
		$includes{"OpenGLES/ES1/glext.h"}=1;
	    }
	    if($init=~/OpenGLES2/){
		$includes{"OpenGLES/ES2/gl.h"}=1;
		$includes{"OpenGLES/ES2/glext.h"}=1;
	    }
	}
    }
    # ----
    sub dump_includes {
	my ($f)=@_;
	my @includes=keys %includes;
	foreach my $i (@includes){
	    push @$f, "#import <$i>\n";
	}
	push @$f, "\n";
    }

