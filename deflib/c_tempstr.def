# --------------------------------
subcode: tempstr_init
    $global char tempstr_buffer[1024]
    $global int tempstr_size=1024
    $global int tempstr_len=0
    tempstr_len=0
    tempstr_size=sizeof(tempstr_buffer)
    tempstr_buffer[0]=0
    tempstr_buffer[tempstr_size-1]=0

subcode: tempstr_size(n)
    # in case we need bigger tempstr buffer
    $global char tempstr_buffer[$(n)]


subcode: tempstr_add_char(c)
    $if tempstr_len+1<tempstr_size
	tempstr_buffer[tempstr_len++]=$(c)
	tempstr_buffer[tempstr_len]=0

subcode: tempstr_add(s)
    $(if:s~')
	$call tempstr_add_char, $(s)
    $(else)
	tn_len=strlen($(s))
	$if tempstr_len+tn_len<tempstr_size
	    strcpy(tempstr_buffer+tempstr_len, $(s))
	tempstr_len+=tn_len

subcode: tempstr_join(sep, s)
    $if tempstr_len>0
	$(if:sep~')
	    $call tempstr_add_char, $(sep)
	$(elif:sep~")
	    $call tempstr_add, $(sep)
    $call tempstr_add, $(s)

# ---- sprintf ------------
perlcode: parse_fmt
    my ($n, $fmt)=fmt_string($param)
    MyDef::compileutil::set_current_macro("fmt", $fmt)

subcode: sprint(@fmt)
    $eval parse_fmt, $(fmt)
    tempstr_size=sizeof(tempstr_buffer)
    tn_ret=snprintf(tempstr_buffer, tempstr_size-1, $(fmt))
    $(export:tempstr=tempstr_buffer)

subcode: sprint_append(@fmt)
    $eval parse_fmt, $(fmt)
    tempstr_size=sizeof(tempstr_buffer)
    tn_ret=snprintf(tempstr_buffer+tempstr_len, tempstr_size-tempstr_len-1, $(fmt))
    tempstr_len+=tn_ret
    $(export:tempstr=tempstr_buffer)

# ---------------------------------
subcode: tempstr_add_int(n)
    $fcall tempstr_add_int_10($(n))

fncode: tempstr_add_int_10(n)
    &call itoa, n, 10
	$call tempstr_add_char, '0'+tpn_digits[i]

subcode: itoa(n, base)
    $if $(n)==0
	$call tempstr_add_char, '0'
    $else
	$if $(n)<0
	    $(n)=-$(n)
	    tb_negative=1
	$else
	    tb_negative=0

	$local tpn_digits[40]
	i=0
	$while $(n)>0
	    tpn_digits[i++]=$(n) % $(base)
	    $(n)/=$(base)

	i--
	$while i>=0
	    BLOCK
	    i--

# ---------------------------------
macros: 
    ansi_black: \x1b[30m
    ansi_red:   \x1b[31m
    ansi_green: \x1b[32m
    ansi_yellow:\x1b[33m
    ansi_blue:  \x1b[34m
    ansi_magenta: \x1b[35m
    ansi_cyan:  \x1b[36m
    ansi_white: \x1b[37m
    ansi_reset: \x1b[0m

subcode: tempstr_add_ansi_color(color)
    $(if:number:color)
	$call tempstr_add, "\x1b[38;5;$(color)m"
    $(else)
	$call tempstr_add, "$(ansi_$(color))"

