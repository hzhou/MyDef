include: c/lex.def

#---------------------------------------- 
subcode: get_ts_token
    #-- null terminated ----
    ts_token=input_get_str(input)

subcode: get_token(s)
    #-- as is ----
    $local char * $(s), int $(s)_len
    $set_var_attr $(s), strlen=$(s)_len
    $(s)=input->buffer+input->n_start
    $(s)_len=input->n_pos-input->n_start

#----- overload input_buffer.def -----
subcode: local_input(s)
    $local input
    $get_var_attr $(s), strlen
    $(if:!strlen)
        $(set:strlen=strlen($(s)))
    $call local_input_buffer, input, $(s), $(strlen)

#--------------
subcode: input_start
    $call @input_skip
    input->n_start=input->n_pos

subcode: input_restart
    $call input_check_tempchar, input
    input->n_pos=input->n_start

subcode: input_debug
    tn_c=input->buffer[input->n_pos]
    $print "input_debug: %d - %d - %d [%c][%d]", input->n_start, input->n_pos, input->n_end, tn_c, tn_c
    $for i=0:40
        $if input->n_pos+i<input->n_end
            $if input->buffer[input->n_pos+i]=='\n'
                break
            $else
                printf "%c", input->buffer[input->n_pos+i]
    $print "\n"

# ---- overload to customize -----------------------------
subcode: input_skip
    skip_space()

# ---------------------------------
subcode: match_until(cond)
    $while 1
        $call input_get_c, tn_c
        $if tn_c<=0
            return 1
        $if $(cond)
            $call input_back_c
            return 1

# -----------------------------
fncode: skip_space
    lexical: input
    $call match_until, !isspace(tn_c)

fncode: match_non_space
    lexical: input
    $call input_start
    $call match_until, isspace(tn_c)

#---------------------------------------- 
subcode: match_char_class_sub(cond)
    $call input_get_c, tn_c
    $while *s_class
        $if $(cond)
            return 1
        s_class++
    $if tn_c>0
        $call input_back_c
    return 0

#---------------------------------------- 
fncode: match_char_class(s_class)
    lexical: input
    $call match_char_class_sub, tn_c==*s_class

fncode: match_char_class_i(s_class)
    lexical: input
    $call match_char_class_sub, toupper(tn_c)==toupper(*s_class)

#---------------------------------------- 
#-------------------------------
#- hacks for ">=" ">>=" etc.
fncode: match_char_unless(tn_c1, s_tail)
    lexical: input
    $call input_start
    $if match_char(tn_c1)
        $if match_char_class(s_tail)
            $call input_restart
            return 0
        $else
            return 1
    $else
        return 0

fncode: match_keyword_unless(s_key, s_tail)
    lexical: input
    $call input_start
    $if match_keyword(s_key)
        $if match_char_class(s_tail)
            $call input_restart
            return 0
        $else
            return 1
    $else
        return 0

# ---------------------------------
fncode: match_identifier
    lexical: input
    $call input_start
    $call input_get_c, tn_c
    $if isalpha(tn_c) || tn_c=='_'
        $call match_until, !(isalnum(tn_c) || tn_c=='_')
    $else
        $call input_restart
        return 0

# ---------------------------------
fncode: match_bracket(tn_c1)
    lexical: input
    tn_escape='\\'
    $if tn_c1=='{'
        tn_c2='}'
    $elif tn_c1=='['
        tn_c2=']'
    $elif tn_c1=='('
        tn_c2=')'
    $elif tn_c1=='\'' || tn_c1=='"'
        $call match_quote, tn_c1
        return 1
    $else
        # error
        return 0

    tb_flag_escape=0
    $while 1
        $call input_get_c, tn_c
        $if tb_flag_escape
            tb_flag_escape=0
        $elif tn_c=='\'' || tn_c=='"'
            tn_quote=tn_c
            $call match_quote, tn_quote
        $elif tn_c==tn_c1
            match_bracket(tn_c)
        $elif tn_c==tn_c2
            return 1
        $elif tn_c<=0
            return 1

subcode: match_quote(c)
    tn_escape='\\'
    tb_flag_escape=0
    $while 1
        $call input_get_c, tn_c
        $if tb_flag_escape
            tb_flag_escape=0
        $elif tn_c==tn_escape
            tb_flag_escape=1
        $elif tn_c==$(c)
            break


