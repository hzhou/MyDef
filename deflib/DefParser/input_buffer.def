include: DefParser/c_fifo.def

#---- input_buffer ------------------------------------------- 
#-      inherits: fifo

subcode:: _autoload
    $include stdio, string
    $call define_fifo, input_buffer, unsigned char

    $struct(input_buffer) FILE * f, b_tty
    $struct(input_buffer) n_pos, n_tempchar
    $struct(input_buffer) char * s_file, n_line, n_line_start

subcode:: on_fifo_shift
    $(b)->n_pos-=$(b)->n_start

subcode:: on_fifo_create
    $(b)->n_pos=0
    # -- tempchar is for input_get_str
    $(b)->n_tempchar=0

# #### ------------------------------------------
# ----- input reading stream ------
fncode: input_create(FILE * f)
    $local struct input_buffer * b
    $call fifo_create, b, 1024
    $call fifo_attach_file, b, f
    $call @on_input_create, b
    return b

# ----- input from static string ------
fncode: input_from_string(s)
    $local struct input_buffer * b
    $call fifo_create_static, b, s, strlen(s), allocate
    $call @on_input_create, b
    return b

# -----------
fncode: input_delete(struct input_buffer * b)
    $call @on_input_delete, b
    $call fifo_delete, b

# ---- input for local parsing ------------------------
subcode: local_input_buffer(input, s, n)
    $local struct input_buffer local_input_buffer
    $local struct input_buffer * $(input)
    $(input)=&local_input_buffer
    $call fifo_create_static, $(input), $(s), $(n), local

#----------------------------------------------- 
subcode: fifo_attach_file(b, f)
    $if $(f)
	$(b)->f=$(f)
	$(b)->n_eof=0
	$(b)->b_tty=isatty(fileno($(f)))
    $else
	$(b)->f=NULL

#----------------------------------------------- 
#-- 
fncode: input_get_char(struct input_buffer * b)
    $return_type int
    # ---- The Gateway ------------------------
    $call input_check_tempchar, b
    $if b->n_pos==b->n_end
	# ---- read, return eof on eof --------
	$call fifo_input, b
    tn_c=(int)(b->buffer[b->n_pos])
    b->n_pos++
    $call @input_char_filter, b, tn_c
    return tn_c

#----------------------------------------------- 
subcode: fifo_input(b)
    $if $(b)->n_eof
	# ---- eof --------
	$(b)->n_eof+=1
	return EOF
    $elif $(b)->f==NULL
	$call fifo_input_eof
    $else
	$if $(b)->b_tty
	    # ---- interactive input, fgetc --------
	    $call fifo_check_space, $(b), 1, 1
	    tn_c=fgetc($(b)->f)
	    $if tn_c==EOF
		$call fifo_input_eof
	    $(b)->buffer[$(b)->n_end]=(char)tn_c
	    $(b)->n_end++
	$else
	    # ---- input from file, fread --------
	    $(set:space=$(b)->n_size-$(b)->n_end)
	    $if $(space)<128
		$call fifo_check_space, $(b), 128, 1
	    tn_ret=fread($(b)->buffer+$(b)->n_end, 1, $(space), $(b)->f)
	    $if tn_ret==0
		$call fifo_input_eof
	    $else
		$(b)->n_end+=tn_ret

subcode: fifo_input_eof
    $(b)->n_eof=2
    return EOF

#----------------------------------------------- 
fncode: input_back_char(struct input_buffer * b)
    $if b->n_eof>1
	b->n_eof--
    $elif input->n_pos>input->n_start
	input->n_pos--

#----------------------------------------------- 
fncode: input_get_str(struct input_buffer * b)
    # ---- Returns the string scanned so far ------
    $if b->buffer[b->n_pos] && !b->n_tempchar
	b->n_tempchar=b->buffer[b->n_pos]
	b->buffer[b->n_pos]='\0'
    return b->buffer+b->n_start

subcode: input_check_tempchar(b)
    $if $(b)->n_tempchar
	$(b)->buffer[$(b)->n_pos]=$(b)->n_tempchar
	$(b)->n_tempchar=0

#----------------------------------------------- 
#--     (line, col) support
subcode:: on_input_create(b)
    $(b)->s_file=NULL
    $(b)->n_line=1
    $(b)->n_line_start=0

subcode:: on_input_delete(b)
    $if $(b)->s_file
	free($(b)->s_file)
	$(b)->s_file=NULL

subcode:: input_char_filter(b, c)
    $if $(c)=='\n' && $(b)->n_line_start<$(b)->n_pos
	$(b)->n_line++
	$(b)->n_line_start=$(b)->n_pos

subcode: input_set_filepos(b, file, line)
    $(b)->s_file=strdup($(file))
    $(b)->n_line=$(line)
    $(b)->n_line_start=$(b)->n_pos

subcode:: on_fifo_shift
    $(b)->n_line_start-=$(b)->n_start

