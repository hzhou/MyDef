include: std_c.def
include: ext.def

# GUI needs Model View Controller
# think about the editor: 
#    View is the window
#    Model is the text buffer
#    Controller is the code that connects View and Model
subcode: win32_autoload
    $register_prefix(ui) UINT
    $register_prefix(lpstr) LPSTR

    $register_prefix(hwnd) HWND
    $register_prefix(hdc) HDC
    $register_prefix(hmenu) HMENU
    $register_prefix(rect) RECT
    $register_prefix(hfont) HFONT

    $register_prefix(bmph) BITMAPINFOHEADER
    $register_prefix(bmp) DWORD *

subcode: basic_frame
    $call main_fn_list
    $list WinMain

fncode: WinMain
    $call win_main
    $call win_loop

subcode: win_main(mainname)
    $global hwnd_main
    $call register_wndclass, "$(mainname)", WndProc_main
    $call create_window, hwnd_main, "$(mainname)"
    $call win_show, hwnd_main

subcode: win_show(hwnd)
    NEWLINE
    ShowWindow($(hwnd), n_cmdshow)
    UpdateWindow($(hwnd))

subcode: win_loop
    NEWLINE
    $local MSG msg
    $while GetMessage(&msg, NULL, 0, 0)>0
	TranslateMessage(&msg)
	DispatchMessage(&msg)

# ---------
subcode: on_paint
    $local PAINTSTRUCT ps
    $local HDC hdc
    hdc = BeginPaint(hwnd, &ps)
    BLOCK
    EndPaint(hwnd, &ps)
    return 0

###############################################################
subcode:: autoload_symbols
    $symbol s_printf_buffer[100], n_printf_length=0
    
subcode: sprint(@fmt)
    $auto_global s_printf_buffer[100], n_printf_length=0
    $eval parse_fmt, $(fmt)
    n_printf_length=_snprintf(s_printf_buffer, 100, $(fmt))
    $if n_printf_length<0
	s_printf_buffer[99]='\0'
	n_printf_length=99
    $(mexport:s=s_printf_buffer,n=n_printf_length)

# ----------------------------------------------------------------
subcode: init_println
    $local n_cur_text_x, n_cur_text_y, n_text_height
    n_cur_text_x=10
    n_cur_text_y=10
    n_text_height=20
    $call newfont

subcode: move_to(x, y)
    n_cur_text_x=$(x)
    n_cur_text_y=$(y)

subcode: println(@msg)
    $uselib gdi32
    _snprintf(ts_msg_buffer, 200, $(msg))
    TextOut(hdc, n_cur_text_x, n_cur_text_y, ts_msg_buffer, strlen(ts_msg_buffer))
    n_cur_text_y+=n_text_height

subcode: fillrect(left, top, right, bot)
    $local t_rect
    t_rect.left=$(left)
    t_rect.top=$(top)
    t_rect.right=$(right)
    t_rect.bottom=$(bot)
    FillRect(hdc, &t_rect, (HBRUSH)(COLOR_WINDOW+1))
###############################################################
subcode: msgbox(@msg)
    $local ts_msg_buffer[1000]
    sprintf(ts_msg_buffer, $(msg))
    MessageBox(hwnd_main, ts_msg_buffer, "Message Box", MB_OK)

subcode: init_console
    AllocConsole()
    freopen("conout$","w",stdout)
    freopen("conout$","w",stderr)
    printf("Console ready ...\n")     
###############################################################
subcode: openfilename
    $uselib comdlg32
    $register_name(ofn) OPENFILENAME
    $local ofn, ts_file[260], b_result
    ZeroMemory(&ofn, sizeof(ofn))
    ofn.lStructSize=sizeof(ofn)
    ofn.hwndOwner=hwnd_main
    ofn.lpstrFile=ts_file
    ofn.lpstrFile[0]='\0'
    ofn.nMaxFile=sizeof(ts_file)
    ofn.lpstrFilter="All\0*.*\0\0"
    ofn.nFilterIndex=1
    ofn.lpstrFileTitle=NULL
    ofn.nMaxFileTitle=0
    ofn.lpstrInitialDir=NULL
    ofn.Flags=OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    b_result=GetOpenFileName(&ofn)

#### Default Calls ################################################

# ---- Register Window Class ----
subcode: register_wndclass(name, proc)
    $local WNDCLASSEX wc
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hInstance = cur_instance
    wc.cbClsExtra = 0;

    $(if:wc_style!=1)
	wc.style = 0

    $(if:wc_icon!=1)
	wc.hIcon = NULL
	wc.hIconSm = NULL

    $(if:wc_cursor!=1)
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);

    $(if:wc_background!=1)
	wc.hbrBackground = NULL
    $(if:wc_menu!=1)
	wc.lpszMenuName = NULL

    wc.lpszClassName = $(name)

    $(if:proc=DIALOG)
	wc.lpfnWndProc = DefDlgProc
	wc.cbWndExtra = DLGWINDOWEXTRA
    $(elif:proc:8=WndProc_)
	$(block:global_init)
	    $eval wndproc, $(proc)
	wc.lpfnWndProc = $(proc)
	wc.cbWndExtra = 0

    RegisterClassEx(&wc);

subcode: wc_cursor(p)
    $local WNDCLASSEX wc
    $(if:p:4=IDC_)
	wc.hCursor = LoadCursor(NULL, $(p))
	$(export:wc_cursor=1)

subcode: wc_style(p)
    $(if:wc_style!=1)
	wc.style=$(p)
    $(else)
	wc.style |= $(p)
    $(export:wc_style=1)

subcode: wc_icon(p)
    $(if:p:4=IDI_)
	wc.hIcon = LoadImage(cur_instance, MAKEINTRESOURCE($(p)), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR|LR_SHARED);
	wc.hIconSm = LoadImage(cur_instance, MAKEINTRESOURCE($(p)), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR|LR_SHARED);
	$(export:wc_icon=1)

subcode: wc_menu(p)
    wc.lpszMenuName=(LPCTSTR)$(p)
    $(export:wc_menu=1)

subcode: wc_background(p)
    wc.hbrBackground=(HBRUSH)$(p)
    $(export:wc_background=1)

# ---- Create Window ----
subcode: create_window(hwnd, name)
    $(if:!cw_style_ex)
	$(set:cw_style_ex=0)
    $(if:!cw_style)
	$(set:cw_style=WS_OVERLAPPEDWINDOW)
    $(if:!cw_x)
	$(set:cw_x=CW_USEDEFAULT)
    $(if:!cw_y)
	$(set:cw_y=CW_USEDEFAULT)
    $(if:!cw_w)
	$(set:cw_w=CW_USEDEFAULT)
    $(if:!cw_h)
	$(set:cw_h=CW_USEDEFAULT)

    $(hwnd)=CreateWindowEx($(cw_style_ex), $(name), $(name), $(cw_style), $(cw_x), $(cw_y), $(cw_w), $(cw_h), NULL, NULL, cur_instance, NULL)
    
subcode: cw_style_ex(p)
    $(if:!cw_style_ex)
	$(export:cw_style_ex=$(p))
    $(else)
	$(export:cw_style_ex=$(cw_style_ex)|$(p))

subcode: cw_style(p)
    $(if:!cw_style)
	$(export:cw_style=$(p))
    $(else)
	$(export:cw_style=$(cw_style)|$(p))

subcode: cw_size(x, y, w, h)
    $(export:cw_x=$(x))
    $(export:cw_y=$(y))
    $(export:cw_w=$(w))
    $(export:cw_h=$(h))

subcode: cw_dim(x, v)
    $(export:cw_$(x)=$(v))

# ---- WNDPROC -----------------------------------------
#  $(block:global_init)
#      $eval wndproc, WndProc_main
#
perlcode: wndproc
    $if $param=~/(WndProc|DlgProc)_(\w+)/
	my ($type, $name)=($1, $2)
	$if !$functions{"$type\_$name"}
	    my $old_function=$cur_function;
	    my $fidx=open_function("$type\_$name", "HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam")
	    $cur_function->{ret_type}="LRESULT CALLBACK";
	    &call push_open_function
		$call window_proc_core
	    $cur_function=$old_function

subcode: window_proc_core
    my $codes=$MyDef::def->{codes}
    # ---- process window msg ---------------
    MyDef::compileutil::call_sub("\@pre_WndProc_$name")
    push @$out, "switch(msg){";
    &call push_indent_block
	my %msg_hash;
	$foreach $k in sort(keys(%$codes))
	    $if $k=~/$name\_on\_(WM_\w+)/
		my $msg=$1
		$call window_proc_on_msg
	$if !$msg_hash{"WM_DESTROY"} and $name eq "main"
	    MyDef::compileutil::call_sub("msg_destroy")
	    # $call msg_destroy

    push @$out, "}";
    $if $type eq "WndProc"
	push @$out, "return DefWindowProc(hwnd, msg, wparam, lparam);"
    $elif $type eq "DlgProc"
	push @$out, "return FALSE;"

subcode: window_proc_on_msg
    $msg_hash{$msg}=1
    $if $msg eq "WM_ALLKEY"
	push @$out, "case WM_KEYDOWN:"
	push @$out, "case WM_KEYUP:"
	push @$out, "case WM_SYSKEYDOWN:"
	push @$out, "case WM_SYSKEYUP:"
    $elif $msg eq "WM_ALLCOMMAND"
	push @$out, "case WM_COMMAND:"
	push @$out, "case WM_SYSCOMMAND:"
    $else
	push @$out, "case $msg:"
    &call push_indent_block
	# push @$out, "printf(\"$name\_on_$msg\\n\");"
	MyDef::compileutil::call_sub("\@$name\_on_$msg")
	push @$out, "break;"

# -- messages --
subcode: msg_destroy
    case WM_DESTROY:
	PostQuitMessage(0)
	return 1

# ---------------------------------------------------------------
subcode: dialog(name)
    $(block:global_init)
	$eval wndproc, DlgProc_$(name)
    DialogBox(cur_instance, MAKEINTRESOURCE(dialog_$(name)), hwnd, DlgProc_$(name))

subcode: create_dialog(name, var)
    $(block:global_init)
	$eval wndproc, DlgProc_$(name)
    $(var)=CreateDialog(cur_instance, MAKEINTRESOURCE(dialog_$(name)), hwnd, DlgProc_$(name))

# ---------------------------------------------------------------
subcode: SetClassLong(val)
    $(if:val:4=IDC_)
	SetClassLongPtr(hwnd, GCL_HCURSOR, (LONG_PTR)LoadCursor(NULL, MAKEINTRESOURCE($(val))))

# ---------------------------------------------------------------
subcode: create_font(hfont, name, size)
    $(hfont) = CreateFont ($(size), 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FF_DONTCARE, $(name))

# ---------------------------------------------------------------
subcode: quick_gdi(name)
    BLOCK RELEASE
    $local HGDIOBJ t_old_$(name)
    t_old_$(name)=SelectObject(hdc, t_new_$(name))
    $(block:_post)
	SelectObject(hdc, t_old_$(name))
	DeleteObject(t_new_$(name))

# --
subcode: create_pen(var, @plist)
    $local HPEN t_new_pen
    $(mset:ps=PS_SOLID,pw=0,color=0)
    $(ifeach:p:3=PS_)
	$(export:ps=$(p))
    $(ifeach:p~[0-9]+)
	$(export:pw=$(p))
    $(ifeach:p:6=color_)
	$(export:color=$(p))
    t_new_pen=CreatePen($(ps), $(pw), $(color))

subcode: quick_pen(@plist)
    BLOCK RELEASE
    $call create_pen, t_new_pen, $(plist)
    $call quick_gdi, pen

# --
subcode: create_brush(var, @plist)
    $local HBRUSH $(var)
    $(set:color=0)
    $(ifeach:p:6=color_)
	$(export:color=$(p))
    $(var)=CreateSolidBrush($(color))

subcode: local_brush(var, @plist)
    BLOCK RELEASE
    $call create_brush, $(var), $(plist)
    $(block:_post)
	DeleteObject($(var))

subcode: quick_brush(@plist)
    BLOCK RELEASE
    $call create_brush, t_new_brush, $(plist)
    $call quick_gdi, brush

# -------------------------------------------------------------
subcode: AppendMenu(var, name)
    $(ogdl_load:$(name))
    $call AppendMenu_ogdl, $(var)

subcode: AppendMenu_ogdl(var)
    $(allow_recurse:10)
    $(ogdl_each)
	$(if:ogdl_text)
	    $(if:ogdl_attr:_text=----)
		AppendMenu($(var), MF_SEPARATOR, 0, NULL)
	$(elif:ogdl_list)
	    $local HMENU hmenu_sub$(recurse)
	    hmenu_sub$(recurse)=CreatePopupMenu()
	    $call AppendMenu_ogdl, hmenu_sub$(recurse)
	    $(ogdl_get:title=_name,text)
	    $eval tempstr, $(title)
	    AppendMenu($(var), MF_POPUP, (UINT_PTR)hmenu_sub$(recurse), $(tempstr))
	    DestroyMenu(hmenu_sub$(recurse))
	$(else)
	    $(if:ogdl_attr:_name=MENU)
		$call AppendMenu_ogdl_menu_var
	    $(else)
		$call AppendMenu_ogdl_item

subcode: AppendMenu_ogdl_menu_var
    $(if:ogdl_attr:disable!=1)
	$(if:ogdl_attr:var)
	    $(ogdl_get:subvar=var)
	    $(ogdl_get:title=_name,text)
	    $eval tempstr, $(title)
	    AppendMenu($(var), MF_POPUP, (UINT_PTR)$(subvar), $(tempstr))
    $(if:IDM_step)
	$(if:ogdl_attr:reserve)
	    $(ogdl_get:reserve=reserve)
	    $eval split_reserve
	    $define($(name)) $(IDM_base)
	    $(reset:IDM_base+=$(IDM_skip))
subcode: AppendMenu_ogdl_item
    $(ogdl_get:name=_name)
    $(if:name:2!=ID)
	$(set:name=ID_MENU_$(name))
    $(if:ogdl_attr:disable!=1)
	$(ogdl_get:title=_name,text)
	$eval tempstr, $(title)
	AppendMenu($(var), MF_STRING, $(name), $(tempstr))
    $(if:IDM_step)
	$define($(name)) $(IDM_base)
	$(reset:IDM_base+=$(IDM_step))

perlcode: split_reserve
    my $reserve=MyDef::compileutil::get_current_macro("reserve")
    $if $reserve=~/(\w+)\s*--\s*(\d+)/
	MyDef::compileutil::set_current_macro("name", $1)
	my $count=$2
	my $skip="$(IDM_step)"
	MyDef::compileutil::expand_macro_recurse(\$skip)
	$skip=MyDef::compileutil::get_numeric($skip)
	$skip*=$count
	MyDef::compileutil::set_current_macro("IDM_skip", $skip)
	
# -------------------------------------------------------------

