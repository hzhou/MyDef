#include: ref_counting.def

## frame
subcode: basic_frame
    $include stdio
    $include stdlib
    $call @global
    $list main2

##  Memory utilities
subcode: memory_utility
    $global float mu_total_mem=0.0
    $call mu_dlist
    #$call ref_counting, 97, mu, void *

# -----------------------------------------------------------------------
subcode: mu_dlist
    $call dlist memlist | | void * p, const char * name, int size
    $global struct memlist * p_memlist=NULL
    $list mu_add_pointer, mu_del_pointer, mu_clean_up

    $(block:main_init)
	p_memlist=memlist_new()


fncode: mu_add_pointer(void* pointer, const char * name, int size)
    $if !p_memlist
	p_memlist=memlist_new()
    $if pointer
	$push p_memlist, pointer, name, size
    
fncode: mu_del_pointer(void * pointer)
    $local struct memlist_node * p
    $local struct memlist_node * p2
    $if p_memlist
	&call dlist_each_safe, p_memlist, p, p2
	    $if p->p==pointer
		$call dlist_unlink, p_memlist, p
		free(p->p)
		free(p)
		break;

fncode: mu_clean_up
    $local struct memlist_node * p
    $local struct memlist_node * p2
    $if p_memlist
	&call dlist_each_safe, p_memlist, p, p2
	    $call dlist_unlink, p_memlist, p
	    $(if:mu_debug)
		printf("Freeing pointer %s: %x (%x)\n", p->name, p->p, p)
	    free(p->p)
	    free(p)

## Regular Expression

## hash
subcode: text_hash(name, nbuckets)
    unsigned int hash = 0
    char * s =$(name)
    unsigned c
    while(c=*s++) hash=hash*9^c

subcode: make_hash(name, nbuckets, node)
    $struct($(name)_node) $(node), s_text, next
    $(block:main_init)
	$for i=0:$(nbuckets)
	    DEBUG
	    $(name)[i].s_text=NULL
	    $(name)[i].next=NULL
    $(block:global_init)
	struct $(name)_node $(name)[$(nbuckets)]
	struct $(name)_node * hash_lookup_$(name)(char * name){
	    #int hash=text_hash(name) % $(nbuckets);
	    $call text_hash, name, $(nbuckets)
	    struct $(name)_node * p=&$(name)[hash]
	    $while 1
		$if p->s_text == NULL
		    return p
		$else
		    $if strcmp(p->s_text, name)==0
			return p
		    $elif p->next
			p=p->next
		    $else
			break
	    p->next=(struct $(name)_node *)malloc(sizeof(struct $(name)_node))
	    p->next->next=NULL
	    p->next->s_text=NULL
	    return p->next
	}

###############################################################
## doubly linked list
#    $struct(name_node) prop1, prop2, ..., prev, next 
#    $struct(name) prop1, prop2, ..., head
#    the current node is always referred with p
subcode: dlist(name, list, node)
    $struct($(name)_node) $(node), struct $(name)_node * prev, struct $(name)_node * next
    $struct($(name)) $(list), n, struct $(name)_node* head
    $call dlist_support

subcode: dlist_support
    $register_name(plist) struct $(name) *
    $register_name(p) struct $(name)_node *
    $list dlist_new($(name)_new)
    $list dlist_push($(name)_push)
    $list dlist_pop($(name)_pop)
    $list dlist_shift($(name)_shift)
    $list dlist_unshift($(name)_unshift)

fncode: dlist_new
    plist=(struct $(name) *)malloc(sizeof(struct $(name)))
    p=(struct $(name)_node *)malloc(sizeof(struct $(name)_node))
    p->prev=p
    p->next=p
    plist->n=0
    plist->head=p
    return plist

fncode: dlist_push(plist)
    p=(struct $(name)_node *)malloc(sizeof(struct $(name)_node))
    p->next=plist->head
    p->prev=plist->head->prev
    p->prev->next=p
    p->next->prev=p
    plist->n++
    return p

fncode: dlist_pop(plist)
    $if plist->n>0
	p=plist->head->prev
	$call dlist_unlink, plist, p
	return p
    $else
	return NULL

fncode: dlist_shift(plist)
    $if plist->n>0
	p=plist->head->next
	$call dlist_unlink, plist, p
	return p
    $else
	return NULL

fncode: dlist_unshift(plist)
    p=(struct $(name)_node *)malloc(sizeof(struct $(name)_node))
    p->next=plist->head->next
    p->prev=plist->head
    p->next->prev=p
    p->prev->next=p
    plist->n++
    return p

subcode: dlist_unlink(plist, p)
    $(p)->prev->next=$(p)->next
    $(p)->next->prev=$(p)->prev
    $(plist)->n--

subcode: dlist_each(plist, p)
    $(p)=$(plist)->head->next
    $while $(p) != $(plist)->head
        BLOCK
        $(p)=$(p)->next

subcode: dlist_each_safe(plist, p, p2)
    $(p2)=$(plist)->head->next
    $while $(p2) != $(plist)->head
	$(p)=$(p2)
        $(p2)=$(p2)->next
        BLOCK

subcode: dlist_each_inverse(plist, p)
    $(p)=$(plist)->head->prev
    $while $(p) != $(plist)->head
        BLOCK
        $(p)=$(p)->prev

subcode: dlist_each_inverse_safe(plist, p, p2)
    $(p2)=$(plist)->head
    $while $(p2)->prev != $(plist)->head
	$(p)=$(p2)->prev
        BLOCK
        $(p2)=$(p2)->prev

###############################################################
## singly linked list 
subcode: slist_declare(name, list, node)
    $struct($(name)_node) $(node), struct $(name)_node * next
    $struct($(name)_list) $(list), n, struct $(name)_node* head, struct $(name)_node* tail

subcode: slist_init(var, @plist)
    $get_struct_var_prefix(sl) $(var)
    $(sl)head=NULL
    $(sl)tail=NULL
    $(sl)n=0
    $(ifeach:p)
	# list_member = init value;
	$(sl)$(p)

# --
subcode: slist_set_macro
    $get_struct_var_prefix(sl) $(var)
    $get_pointer_type(nodetype) $(sl)head
    $(set:nodename=$(nodetype:6:word))
    $(export:sl, nodetype)
    $(export:p=$(nodename)_temp)
    $(export:p2=$(nodename)_temp2)
# --
subcode: slist_head_pop(var)
    $call slist_set_macro
    $while $(sl)head
	$local $(nodetype) * $(p)
	$(p)=$(sl)head
	BLOCK
	$(sl)head=$(p)->next
	$(sl)n--
	free($p)
    $if !$(sl)head
	$(sl)tail=NULL
    $(export:p)

subcode: slist_clear(var)
    &call slist_head_pop, $(var)
	# NOOP
	
subcode: slist_push(var, @plist)
    $call slist_set_macro
    $local $(nodetype) * $(p)
    $(p)=($(nodetype) *)malloc(sizeof($(nodetype)))
    $(p)->next=NULL
    $if !$(sl)head
	$(sl)head=$(p)
    $else
	$(sl)tail->next=$(p)
    $(sl)tail=$(p)
    $(sl)n++
    $(ifeach:t)
	$(p)->$(t)
    $(export:p)

subcode: slist_shift(var)
    $call slist_set_macro
    $local $(nodetype) * $(p)
    $(p)=$(sl)head
    $(sl)head=$(sl)head->next
    $if !$(sl)head
	$(sl)tail=NULL
    $(sl)n--
    $(export:p)

subcode: slist_unshift(var, @plist)
    $call slist_set_macro
    $local $(nodetype) * $(p)
    $(p)=($(nodetype) *)malloc(sizeof($(nodetype)))
    $(p)->next=$(sl)head
    $(sl)head=$(p)
    $if !$(sl)tail
	$(sl)tail=$(p)
    $(sl)n++
    $(ifeach:t)
	$(p)->$(t)
    $(export:p)

subcode: slist_each(var)
    $call slist_set_macro
    $local $(nodetype) * $(p)
    $(p)=$(sl)head
    $while $(p)
	BLOCK
	$(p)=$(p)->next
    $(export:p, sl)

subcode: slist_each_2(var)
    $call slist_set_macro
    $local $(nodetype) * $(p)
    $local $(nodetype) * $(p2)
    $(p)=$(sl)head
    $(p2)=$(sl)head
    $while $(p)
	tb_deleted=0
	BLOCK
	$if !tb_deleted
	    $(p2)=$(p)
	    $(p)=$(p)->next
    $(export:p, p2, sl)

subcode: slist_insert(@plist)
    $if $(p)==$(sl)head
	$(p)=($(nodetype) *)malloc(sizeof($(nodetype)))
	$(p)->next=$(sl)head
	$(sl)head=$(p)
    $else
	$(p)=($(nodetype) *)malloc(sizeof($(nodetype)))
	$(p)->next=$(p2)->next
	$(p2)->next=$(p)
    $(sl)n++
    $(ifeach:t)
	$(p)->$(t)

subcode: slist_delete
    $if $(sl)head==$(p)
	$(sl)head=$(p)->next
	free($(p))
	$(p)=$(sl)head
	$(p2)=$(sl)head
    $else
	$(p2)->next=$(p)->next
	free($(p))
	$(p)=$(p2)->next
    $(sl)n--
    tb_deleted=1
    $if $(p)==NULL
	$(sl)tail=$(p2)

###############################################################
## Utility
subcode: assert(check)
    $if !($(check))
	printf("Error: !($(check)) at line %d \n", __LINE__)
	exit(1)

## FILE IO
subcode: mmap(filename, strname, strsize)
    $include sys/mman
    $include sys/stat
    $include fcntl
    $include unistd
    tn_fd=open($(filename), O_RDONLY)
    struct stat st
    fstat(tn_fd, &st)
    $(strsize)=st.st_size
    $(strname)=mmap(0, $(strsize), PROT_READ, MAP_SHARED, tn_fd, 0)
    BLOCK
    munmap($(strname), $(strsize))
    close(tn_fd)

# --------------------------------
subcode: open_w(file)
    file_out=fopen($(file), "w")
    $if file_out==NULL
        fprintf(stderr, "Can't write %s\n", $(file))
    $else
        BLOCK
        fclose(file_out)
subcode: open_r(file)
    file_in=fopen($(file), "r")
    $if file_in==NULL
        fprintf(stderr, "Can't open %s\n", $(file))
    $else
        BLOCK
        fclose(file_in)

# --------------------------------
subcode: write_sig(name)
    t_n=fwrite("$(name)", 1, $(name:len), file_out)
subcode: write_var(name)
    t_n=fwrite(&$(name), sizeof($(name)), 1, file_out)

subcode: read_var(name)
    t_n=fread(&$(name), sizeof($(name)), 1, file_in)

