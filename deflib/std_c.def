## frame
subcode: basic_frame
    $include stdio
    $include stdlib
    $call @global
    $list n_main

fncode: n_main
    $call main2

#---------------------------------------- 
macros:
    pi: 3.14159265359
    to_rad: 0.0174532925199
    to_deg: 57.2957795131  

###############################################################
## Utility
subcode: assert(check)
    $if !($(check))
        $call assert_action

subcode: assert_action
    printf("Assert Error: ($(check)) at line %d \n", __LINE__)
    exit(1)

subcode: die(@msg)
    $call warn, $(msg)
    exit(-1)

subcode: warn(@msg)
    $(if:msg~")
        fprintf(stderr, $(msg))
    $(else)
        fprintf(stderr, "$(msg)\n")

#----
subcode: try
    $include setjmp
    $global jmp_buf tryenv
    $local n_exception_code
    n_exception_code=setjmp(tryenv)
    $if n_exception_code==0
        BLOCK

subcode: catch(exception)
    $elif n_exception_code==$(exception)
        BLOCK

subcode: throw(exception)
    longjmp(tryenv, $(exception))

#----
subcode: retry_block
    tn_retry_index=0
    $while 1
        tn_retry_index++
        BLOCK
        break

subcode: retry
    continue

#----
subcode: seq_block
    $dowhile 0
        BLOCK

#----
subcode: on_tn_err(fn)
    $if tn_err
        $print "Error: $(fn): tn_err=$tn_err"
        exit(1)

#---- useful ------------
subcode: swap(a, b)
    $get_type(type) $(a)
    $temp $(type) temp

    $(temp)=$(a)
    $(a)=$(b)
    $(b)=$(temp)

subcode: update_max(max, a)
    $if $(max)<$(a)
        $(max)=$(a)

subcode: update_min(min, a)
    $if $(min)>$(a)
        $(min)=$(a)

subcode: free(v)
    free($(v))

## FILE IO
subcode: mmap(filename, strname, strsize)
    $include sys/mman
    $include sys/stat
    $include fcntl
    $include unistd
    tn_fd=open($(filename), O_RDONLY)
    struct stat st
    fstat(tn_fd, &st)
    $(strsize)=st.st_size
    $(strname)=mmap(0, $(strsize), PROT_READ, MAP_SHARED, tn_fd, 0)
    BLOCK
    munmap($(strname), $(strsize))
    close(tn_fd)

fncode: get_file_s(s_file, pn_size)
    $include sys/stat
    $include fcntl
    $include unistd
    tn_fd=open(s_file, O_RDONLY)
    $if tn_fd<0
        $print get_file_s error
        exit(-1)
    struct stat st
    fstat(tn_fd, &st)
    n=st.st_size
    $local s
    $allocate(n+1) s
    n_read=0
    $while n_read<n
        tn_temp = read(tn_fd, s+n_read, n-n_read)
        $if tn_temp<=0
            break
        $else
            n_read+=tn_temp
    s[n_read]='\0'
    $if pn_size
        *pn_size=n
    return s

# --------------------------------
subcode: open_w(file)
    $include stdio
    file_out=fopen($(file), "wb")
    $if file_out==NULL
        fprintf(stderr, "Can't write %s\n", $(file))
    $else
        BLOCK
        fclose(file_out)

subcode: open_r(file)
    $include stdio
    file_in=fopen($(file), "rb")
    $if file_in==NULL
        fprintf(stderr, "Can't open %s\n", $(file))
    $else
        BLOCK
        fclose(file_in)

subcode: skip_r(n)
    t_n=fseek(file_in, $(n), SEEK_CUR)

subcode: write_sig(name)
    t_n=fwrite("$(name)", 1, $(name:len), file_out)
subcode: write_sig_n(quoted_sig, n)
    t_n=fwrite($(quoted_sig), 1, $(n), file_out)

subcode: read_sig(name, len)
    t_n=fread($(name), 1, $(len), file_in)
    $(name)[$(len)]=0

subcode: write_var(name)
    t_n=fwrite(&$(name), sizeof($(name)), 1, file_out)
subcode: write_int_n(i, n)
    tn_value=$(i)
    t_n=fwrite(&tn_value, $(n), 1, file_out)

subcode: read_var(name)
    t_n=fread(&$(name), sizeof($(name)), 1, file_in)

subcode: write_data(name, size)
    t_n=fwrite($(name), 1, $(size), file_out)

subcode: read_data(name, size)
    t_n=fread($(name), 1, $(size), file_in)

# ---- time -------------------------------------------
subcode: tick_loop
    $include time
    $call tick_reset
    $while 1
        BLOCK

subcode: on_tick(sec)
    $if time(NULL)-time_tick_set>=$(sec)
        BLOCK

subcode: every_tick(sec)
    $if time(NULL)-time_tick_set>=$(sec)
        $call tick_reset
        BLOCK

subcode: tick_reset
    time_tick_set=time(NULL)

subcode: print_time(type)
    $include time
    time_now=time(NULL)
    $my struct tm * p_now
    p_now=localtime(&time_now)
    $(if:type=default)
        printf("%d/%d %02d:%02d ", p_now->tm_mon+1, p_now->tm_mday, p_now->tm_hour, p_now->tm_min)
    $(else)
        printf("%d/%d %02d:%02d ", p_now->tm_mon+1, p_now->tm_mday, p_now->tm_hour, p_now->tm_min)

subcode: bench(n)
    $include time
    $local double time_start, double time_finish
    time_start = (double)clock()/CLOCKS_PER_SEC
    $for i_bench_iter=0:$(n)
        BLOCK
    time_finish = (double)clock()/CLOCKS_PER_SEC
    $print "Bench %d iterations, average %f sec/iter.", $(n), (time_finish-time_start)/$(n)

# ---- sort -------------------------------------
subcode: qsort(list, size, type)
    $function qsort_cmp(const void * a, const void * b)
        $return_type int
        $(set:a=(*($(type)*)a))
        $(set:b=(*($(type)*)b))
        BLOCK
    qsort($(list), $(size), sizeof($(type)), $(lamda))

subcode: numcmp(na, nb)
    $(allow_recurse:10)
    $if $(na)<$(nb)
        return -1
    $elif $(na)>$(nb)
        return 1
    $else
        BLOCK

#---- scanf ------------------------------------ 
fncode: get_s_int(s, int * p_n)
    $return_type char *
    n=0
    $while *s>='0' && *s<='9'
        n*=10
        n+=(*s-'0')
        s++
    *p_n=n
    $while *s==' '
        s++
    return s
