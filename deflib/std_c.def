include: c/slist.def
include: c/tempstr.def

## frame
subcode: basic_frame
    $include stdio
    $include stdlib
    $call @global
    $(if:hascode:n_main)
	$list n_main
    $(if:hascode:main2)
	$list main2

###############################################################
## Utility
subcode: assert(check)
    $if !($(check))
	$call assert_action

subcode: assert_action
    printf("Assert Error: ($(check)) at line %d \n", __LINE__)
    exit(1)

subcode: die(msg)
    fprintf(stderr, $(msg))
    exit(-1)

#---- useful ------------
subcode: swap(a, b)
    $get_type(type) $(a)
    $temp $(type) temp

    $(temp)=$(a)
    $(a)=$(b)
    $(b)=$(temp)

subcode: update_max(max, a)
    $if $(max)<$(a)
	$(max)=$(a)

subcode: update_min(min, a)
    $if $(min)>$(a)
	$(min)=$(a)

## FILE IO
subcode: mmap(filename, strname, strsize)
    $include sys/mman
    $include sys/stat
    $include fcntl
    $include unistd
    tn_fd=open($(filename), O_RDONLY)
    struct stat st
    fstat(tn_fd, &st)
    $(strsize)=st.st_size
    $(strname)=mmap(0, $(strsize), PROT_READ, MAP_SHARED, tn_fd, 0)
    BLOCK
    munmap($(strname), $(strsize))
    close(tn_fd)

# --------------------------------
subcode: open_w(file)
    file_out=fopen($(file), "wb")
    $if file_out==NULL
        fprintf(stderr, "Can't write %s\n", $(file))
    $else
        BLOCK
        fclose(file_out)

subcode: open_r(file)
    file_in=fopen($(file), "rb")
    $if file_in==NULL
        fprintf(stderr, "Can't open %s\n", $(file))
    $else
        BLOCK
        fclose(file_in)

subcode: skip_r(n)
    t_n=fseek(file_in, $(n), SEEK_CUR)

subcode: write_sig(name)
    t_n=fwrite("$(name)", 1, $(name:len), file_out)
subcode: write_sig_n(quoted_sig, n)
    t_n=fwrite($(quoted_sig), 1, $(n), file_out)

subcode: read_sig(name, len)
    t_n=fread($(name), 1, $(len), file_in)
    $(name)[$(len)]=0

subcode: write_var(name)
    t_n=fwrite(&$(name), sizeof($(name)), 1, file_out)
subcode: write_int_n(i, n)
    tn_value=$(i)
    t_n=fwrite(&tn_value, $(n), 1, file_out)

subcode: read_var(name)
    t_n=fread(&$(name), sizeof($(name)), 1, file_in)

subcode: write_data(name, size)
    t_n=fwrite($(name), 1, $(size), file_out)

subcode: read_data(name, size)
    t_n=fread($(name), 1, $(size), file_in)

# ---- time -------------------------------------------
subcode: tick_reset(seconds)
    $include time
    $global time_t time_last_tick=0, f_tick_interval=1.0
    time_last_tick=time(NULL)
    f_tick_interval=$(seconds)

subcode: tick(msg)
    $include time
    $global time_t time_last_tick=0, f_tick_interval
    $local time_t time_tick_temp
    time_tick_temp=time(NULL)
    $if difftime(time_tick_temp, time_last_tick)>f_tick_interval
	print $(msg)
	time_last_tick=time_tick_temp

# ---- sort -------------------------------------
subcode: qsort(list, size, type)
    $function qsort_cmp(const void * a, const void * b)
	$return_type int
	$(set:a=(*($(type)*)a))
	$(set:b=(*($(type)*)b))
	BLOCK
    qsort($(list), $(size), sizeof($(type)), $(lamda))

subcode: numcmp(na, nb)
    $(allow_recurse:10)
    $if $(na)<$(nb)
	return -1
    $elif $(na)>$(nb)
	return 1
    $else
	BLOCK
