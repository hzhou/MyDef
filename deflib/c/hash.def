subcode:: _autoload
    $class hash
    $include stdlib
    $include string

#---------------------------------------- 
#- 1 based array, use 0th element as sentinel when hash is full
#---------------------------------------- 
subcode: hash_init(var, scope, @type)
    $struct(hash_key) unsigned char keylen, unsigned char * key, int next
    $(set:hash=struct hash_key * p_key, n_size, n_top, n_val_size)
    $struct(hash) $(hash), char * p_val

    $(if:type=default)
	$warn Hash missing type. Using default int.
	$(set:type=int)
    $tuple $(type)

    $(set:type_n=$(type:list:n))
    $(if:type_n=1)
	$struct(hash$(T)) $(hash), $(type) * p_val
    $(else)
	$struct(hash$(T)) $(hash), struct $(T) * p_val
	$(set:type=struct $(T))

    $$(scope) struct hash$(T) $(var)
    $set_var_attr $(var), class=hash, member_count=$(type_n)
    $set_var_attr $(var), exit=hash_exit

    memset(&$(var), 0, sizeof($(var)))
    $(var).n_val_size=sizeof($(type))

subcode: hash_exit(var)
    $if $(var).n_size>0
	$for i=1:$(var).n_size+1
	    $if $(var).p_key[i].keylen>0
		free($(var).p_key[i].key)
	free($(var).p_key)
	free($(var).p_val)
    
subcode: hash_iter(var)
    $if $(var).n_size>0
	$for 1:$(var).n_size+1
	    $if $(var).p_key[$(i)].keylen>0
		$(set:key=$(var).p_key[$(i)].key)
		$(set:value=$(var).p_val[$(i)])
		BLOCK

#---------------------------------------- 
subcode: hash_lookup_check_key(key)
    $(if:key~^")
	$(export:keylen=$(key:strlen))
    $(else)
	$get_type(keytype) $(key)
	$(if:keytype!=char *)
	    $(export:key="$(key)")
	    $(export:keylen=$(key:len))
	$(else)
	    $(export:keylen=strlen($(key)))

subcode: hash_lookup(var, key)
    $list f_hash_lookup
    $call hash_lookup_check_key, $(key)

    $(set:k=f_hash_lookup((struct hash *)&$(var), $(keylen), $(key)))
    $yield $(var).p_val[$(k)]

subcode: hash_lookup_left(var, key)
    $list f_hash_lookup_left, f_hash_resize
    $call hash_lookup_check_key, $(key)

    $temp int k
    $(k)=f_hash_lookup_left((struct hash *)&$(var), $(keylen), $(key))
    $yield $(var).p_val[$(k)]

#---------------------------------------- 
subcode: hash_resize(var, n)
    $list f_hash_resize, f_hash_prime
    f_hash_resize($(var), $(n))

fncode: f_hash_resize(struct hash * h, n_size)
    $if n_size==0
	n_size=h->n_size*5/3
    $elif n_size<=h->n_size
	return

    $fcall n_size=f_hash_prime(n_size)

    $local struct hash_key * tp_key=h->p_key
    $local char * tp_val=h->p_val
    tn_old_size=h->n_size
    $(set:n=h->n_val_size)

    h->n_size=n_size
    #---------------------------------------- 
    #---- allocate n_size+1 and use 0 as sentinel
    n_size++
    $allocate(n_size) h->p_key
    $allocate(n_size*$(n)) h->p_val
    memset(h->p_key, 0, n_size*sizeof(struct hash_key))
    memset(h->p_val, 0, n_size*$(n))
    h->n_top=n_size-1

    #---------------------------------------- 
    #---- copy contents --
    $if tn_old_size>0
	$for i=1:tn_old_size+1
	    k=f_hash_lookup(h, tp_key[i].keylen, tp_key[i].key)
	    h->p_key[k].keylen=tp_key[i].keylen
	    h->p_key[k].key=tp_key[i].key
	    tn_off=k*$(n)
	    memcpy(h->p_val+k*$(n), tp_val+i*$(n), $(n))
	free(tp_key)
	free(tp_val)

fncode: f_hash_prime(n)
    $if n<13
	return 13

    $if n%2==0
	n++
    $while 1
	$(for:factor in 3, 5, 7, 11)
	    $if n%$(factor)==0
		n+=2
		continue
	break
    return n

#---------------------------------------- 
fncode: f_hash_lookup(struct hash * h, char keylen, pc_key)
    $return_type int
    $if h->n_size==0
	return -1
    #---------------------------------------- 
    tn_h=0
    tn_prime=h->n_size
    $for i=0:keylen
	tn_h=tn_h<<1+pc_key[i]
	$while tn_h>tn_prime
	    tn_h-=tn_prime
    #---- 1 based index, as 0 is sentinel-----
    tn_h+=1
    #---------------------------------------- 
    $local struct hash_key * p
    p=h->p_key+tn_h
    $while 1
	$if p->keylen==0
	    return p-h->p_key
	$elif p->keylen==keylen && memcmp(p->key, pc_key, keylen)==0
	    return p-h->p_key
	$elif p->next
	    p=h->p_key+p->next
	$else
	    $(set:top=h->p_key[h->n_top])
	    $while $(top).keylen>0 && h->n_top>=0
		h->n_top--
	    p->next=h->n_top
	    return h->n_top

#---------------------------------------- 
#-  _left refer to lvalue in a assignment
fncode: f_hash_lookup_left(struct hash * h, char keylen, pc_key)
    k=0
    $while k<=0
	k=f_hash_lookup(h, keylen, pc_key)

	$if k<=0 || (h->n_size>20 && h->n_top<h->n_size*15/100)  
	    f_hash_resize(h, 0)
	    # $print "f_hash_resize @ %s -> %d", pc_key, h->n_size

    $if h->p_key[k].keylen==0
	h->p_key[k].keylen=keylen
	h->p_key[k].key=malloc(keylen+1)
	memcpy(h->p_key[k].key, pc_key, keylen)
	h->p_key[k].key[keylen]='\0'

    return k

#---------------------------------------- 
subcode: hash_debug(var)
    &call hash_iter, $(var)
	$print "%d: %s => ${$(value)}", $(i), $(key)
