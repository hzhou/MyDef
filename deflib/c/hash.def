subcode:: _autoload
    $class hash
    $include stdlib
    $include string
    $call hash_functions

#---------------------------------------- 
subcode: hash_init(var, scope, @type)
    $struct(hash_key) unsigned char keylen, unsigned char * key, next
    $(set:hash=struct hash_key * p_key, n_size, n_top, n_val_size)
    $struct(hash) $(hash), char * p_val
    $tuple $(type)
    $(if:$(type:list:n)=1)
	$struct(hash$(T)) $(hash), $(type) * p_val
    $(else)
	$struct(hash$(T)) $(hash), struct $(T) * p_val
	$(set:type=struct $(T))

    $$(scope) struct hash$(T) $(var)
    $set_var_attr $(var), class=hash, member_count=$(type:list:n)

    memset(&$(var), 0, sizeof($(var)))
    $(var).n_val_size=sizeof($(type))

#---------------------------------------- 
subcode: hash_lookup(var, key)
    $(if:key~^")
	$(set:keylen=$(key:strlen))
    $(else)
	$(set:keylen=strlen($(key)))
    $(set:k=f_hash_lookup($(var), $(keylen), $(key)))
    $yield $(var).p_val[$(k)]

subcode: hash_lookup_left(var, key)
    $temp int k
    $(k)=-1
    $while $(k)<0
	$(if:key~^")
	    $(set:keylen=$(key:strlen))
	$(else)
	    $temp int l
	    $(l)=strlen($(key))
	    $(set:keylen=$(l))
	$(k)=f_hash_lookup($(var), $(keylen), $(key))

	$if $(k)<0
	    f_hash_resize($(var), 0)

    $if $(var).p_key[$(k)].keylen==0
	$(var).p_key[$(k)].keylen=$(keylen)
	$(var).p_key[$(k)].key=malloc($(keylen))
	memcpy($(var).p_key[$(k)].key, $(key), $(keylen))

    $yield $(var).p_val[$(k)]

#---------------------------------------- 
subcode: hash_resize(var, n)
    f_hash_resize($(var), $(n))

fncode: f_hash_resize(struct hash * h, n_size)
    $if n_size==0
	n_size+=n_size*2/3
    $elif n_size<=h->n_size
	return

    $fcall n_size=f_hash_prime(n_size)

    $local struct hash_key * tp_key=h->p_key
    $local char * tp_val=h->p_val
    tn_old_size=h->n_size
    $(set:n=p->h_val_size)

    $allocate(n_size) h->p_key
    memset(h->p_key, 0, n_size*sizeof(struct hash_key))
    $allocate(n_size*$(n)) h->p_val

    h->n_size=n_size
    h->n_top=n_size-1
    $for i=0:tn_old_size
	tn_i=f_hash_lookup(h, tp_key[i].keylen, tp_key[i].key)
	h->p_key[tn_i].keylen=tp_key[i].keylen
	h->p_key[tn_i].key=tp_key[i].key
	tn_off=tn_i*$(n)
	memcpy(h->p_val+tn_off, tp_val+tn_off, $(n))

fncode: f_hash_lookup(struct hash * h, char keylen, pc_key)
    $return_type int
    tn_h=0
    tn_prime=h->n_size
    $for i=0:keylen
	tn_h=tn_h<<1+pc_key[i]
	$while tn_h>tn_prime
	    tn_h-=tn_prime
    $local struct hash_key * p
    p=h->p_key+tn_h
    $while 1
	$if p->keylen==0
	    return p-h->p_key
	$elif p->keylen==keylen && memcmp(p->key, pc_key, keylen)==0
	    return p-h->p_key
	$elif p->next
	    p=h->p_key+p->next
	$else
	    $(set:top=h->p_key[h->n_top])
	    $while $(top).keylen>0 && h->n_top>=0
		h->n_top--
	    p->next=h->n_top
	    return h->n_top

fncode: f_hash_prime(n)
    $if n<13
	return 13

    $if n%2==0
	n++
    $while 1
	$(for:factor in 3, 5, 7, 11)
	    $if n%$(factor)==0
		n+=2
		continue
    return n

subcode: hash_key_lookup(var, key)

# HASH ----------------------------------------------
subcode: hash_functions
    $struct(hash_entry) s_key, s_val, next
    $struct(hash) struct hash_entry * p_table, n_size, n_prime, n_top
    $list hash_new, 
    $list hash_expand, hash_free
    $list hash_getstr, hash_lookup

subcode: hash_free_val(p)
    $if $(p)->s_val && $(p)->s_val >(char *)100
	free($(p)->s_val)

subcode: hash_free_key(p)
    $if $(p)->s_key
	free($(p)->s_key)

subcode: hash_set_val(p, val)
    $call hash_free_val, $(p)
    $(p)->s_val=strdup($(val))

# -------------------------------------
# p_hash=hash_new(1000)
# -------------------------------------
subcode: hash_set(p_hash, key, val)
    $local struct hash_entry * p
    p=hash_lookup($(p_hash), $(key))
    $call hash_set_val, p, $(val)

# ---- macros ---------------------------------
subcode: local_hash(var)
    $local struct hash * $(var)
    $(var)=hash_new(100)

subcode: global_hash(var)
    $global struct hash * $(var)
    $(var)=hash_new(1000)

# -------------------------------------
fncode: hash_new(tn_initial_size)
    $local struct hash * p_hash
    $allocate p_hash
    $call hash_initialize, tn_initial_size
    return p_hash

subcode: hash_initialize(size)
    $call get_prime, $(size)
    p_hash->n_size=$(size)
    p_hash->n_prime=tn_prime
    p_hash->n_top=$(size)-1
    $allocate($(size)) p_hash->p_table
    memset(p_hash->p_table, 0, $(size)*sizeof(struct hash_entry *))

subcode: get_prime(size)
    tn_prime=$(size)*85/100
    $(set:comp=tn_prime % $1 == 0)
    $if $(comp:2)
	tn_prime++
    $while $(comp:3) || $(comp:5) || $(comp:7)
	tn_prime+=2

# ----
fncode: hash_expand(struct hash * p_hash)
    $local struct hash_entry * p_temp
    $local struct hash_entry * p
    p_temp=p_hash->p_table
    tn_old_size=p_hash->n_size
    tn_size=p_hash->n_size*2
    $call hash_initialize, tn_size
    $for i=0:tn_old_size
	p=p_temp+i
	$if p->s_key
	    $fcall hash_set_direct(p_hash, p->s_key, p->s_val)
    free(p_temp)

fncode: hash_free(struct hash * p_hash)
    tn_size=p_hash->n_size
    $for i=0:tn_size
	$local struct hash_entry * p
	p=p_hash->p_table+i
	$call hash_free_key, p
	$call hash_free_val, p
    free(p_hash->p_table)
    free(p_hash)


# -------------------------------------
fncode: hash_getstr(struct hash * p_hash, ts_key)
    $return_type char *
    $call hash_sub, getstr

fncode: hash_lookup(struct hash * p_hash, ts_key)
    $return_type struct hash_entry *
    $if p_hash->n_top==0
	hash_expand(p_hash)
    $call hash_sub, lookup

fncode: hash_set_direct(struct hash * p_hash, ts_key, ts_val)
    $call hash_sub, setdirect
# --
subcode: hash_sub(type)
    $local struct hash_entry * p
    $call hash_get_code, ts_key
    p=p_hash->p_table+tn_h

    $if ! p->s_key
	$(if:type=getstr)
	    return NULL
	$(elif:type=lookup)
	    p->s_key=strdup(ts_key)
	    return p
	$(elif:type=setdirect)
	    p->s_key=ts_key
	    p->s_val=ts_val
	    return p
    $else
	$while 1
	    $if strcmp(ts_key, p->s_key)==0
		$(if:type=getstr)
		    return p->s_val
		$(elif:type=lookup)
		    return p
		$(else)
		    return p
	    $elif p->next
		p=p->next
	    $else
		$(if:type=getstr)
		    return NULL
		$(elif:type=lookup)
		    $call hash_find_next
		    p->s_key=strdup(ts_key)
		    return p
		$(elif:type=setdirect)
		    p->s_key=ts_key
		    p->s_val=ts_val
		    return p

# --
subcode: hash_find_next
    $while p_hash->p_table[p_hash->n_top].s_key
	p_hash->n_top--
    p->next=p_hash->p_table+p_hash->n_top
    p=p->next

subcode: hash_get_code(key)
    $local unsigned char * s=(unsigned char *)$(key)
    tn_h=*s++
    tn_prime=p_hash->n_prime
    $while *s
	tn_h+=*s
	$if tn_h>tn_prime
	    tn_h-=tn_prime
	s++
