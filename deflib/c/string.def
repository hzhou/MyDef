subcode:: _autoload
    $class string
#---------------------------------------- 
macros:
    string_param: 
    string_ref: $1, &$1_len, &$1_size

subcode: libstring
    $list f_string_resize
    $list f_string_append
    $list f_string_append_char
    $list f_string_append_hex
    $list f_string_append_int
    $list f_string_append_float

#---- init ------------------------------------ 
subcode: string_init(var, scope, @type)
    $include string
    $$(scope) char * $(var)=NULL
    $set_var_attr $(var), class=string, dimension=$(var)_len
    $set_var_attr $(var), exit=string_exit
    $set_var_attr $(var), strlen=$(var)_len
    $$(scope) int $(var)_len=0
    $$(scope) int $(var)_size=0
    $(if:type!=default)
	$call string_add, $(var), $(type)

subcode: string_exit(var)
    $if $(var)_size>0
	free($(var))

subcode: string_empty(var)
    $(var)_len=0
    $if $(var)_size>0
	memset($(var), 0, $(var)_size)

subcode: string_clear(var)
    $call string_empty, $(var)

subcode: string_resize(var, n)
    $(set:string=$(var), &$(var)_len, &$(var)_size)
    $fcall $(var)=f_string_resize($(string), $(n))

fncode: f_string_resize(s, pn_len, pn_size, n)
    $(mset:len=*pn_len, size=*pn_size)
    $if n==0
	$if $(size)>0
	    free(s)
	    s=NULL
	    $(len)=0
	    $(size)=0
    $else
	$if $(size)<n
	    $(size)=n
	    s=realloc(s, $(size))
	    # $call @assert, s
	    memset(s+$(len), 0, $(size)-$(len))
	$elif $(len)>n
	    $(len)=n
	    memset(s+$(len), 0, $(size)-$(len))
    return s

#---------------------------------------- 
subcode: string_append(var, s)
    $(set:string=$(var), &$(var)_len, &$(var)_size)
    $(if:s~")
	$fcall $(var)=f_string_append($(string), (char *)$(s),$(s:strlen))
    $(elif:s~')
	$fcall $(var)=f_string_append_char($(string), $(s))
    $(else)
	$get_type(type) $(s)
	$(if:type=int or type=char or type=unsigned)
	    $fcall $(var)=f_string_append_int($(string), $(s))
	$(elif:type=float)
	    $fcall $(var)=f_string_append_float($(string), $(s), 7)
	$(elif:type=double)
	    $fcall $(var)=f_string_append_float($(string), $(s), 15)
	$(elif:type=char *)
	    $get_var_attr $(s), strlen
	    $(if:!strlen)
		$(set:strlen=strlen($(s)))
	    $fcall $(var)=f_string_append($(string), $(s), $(strlen))
	$(else)
	    $warn string format $(s):$(type) not recognized
	    $fcall $(var)=f_string_append($(string), $(s), strlen($(s)))

subcode: string_add(var, @plist)
    $(foreach:p)
	$call string_append, $(var), $(p)

subcode: string_set(var, @plist)
    $call string_clear, $(var)
    $(foreach:p)
	$call string_append, $(var), $(p)

subcode: string_addchar(var, c)
    $(set:string=$(var), &$(var)_len, &$(var)_size)
    $fcall $(var)=f_string_append_char($(string), $(c))

subcode: string_addhex(var, c)
    $(set:string=$(var), &$(var)_len, &$(var)_size)
    $fcall $(var)=f_string_append_hex($(string), $(c))

subcode: string_fmt(var, @param)
    $fmt $(param)
    $call string_resize, $(var), 100
    $(if:fmt_n>0)
	tn_ret=snprintf($(var)+$(var)_len, $(var)_size-$(var)_len-1, $(fmt))
	$(var)_len+=tn_ret
    $(else)
	$call string_add, $(var), $(fmt)

#---------------------------------------- 
subcode: string_replace(var, i0, i1, @replace)
    $local string temp_string
    $call string_resize, temp_string, $(var)_len-$(i1)
    temp_string_len=$(var)_len-$(i1)
    strncpy(temp_string, $(var)+$(i1), temp_string_len)
    $call string_resize, $(var), $(i0)
    $call string_fmt, $(var), $(replace)
    $call string_append, temp_string
    
#---------------------------------------- 
#-- all f_string function use this pattern
subcode: f_string(l, @p)
    $parameter s, pn_len, pn_size
    $parameter $(p)
    $call string_expand, s, *pn_len, *pn_size, $(l)
    s2=s+(*pn_len)

#---------------------------------------- 
fncode: f_string_append
    $call f_string, n_len, s_src, n_len
    memcpy(s2, s_src, n_len)
    *pn_len+=n_len
    return s

fncode: f_string_append_char
    $call f_string, 1, c
    *s2=c
    *pn_len+=1
    return s

fncode: f_string_append_hex
    $call f_string, 2, c
    t_c=c>>4
    $if t_c<10
	*s2=t_c+'0'
    $else
	*s2=t_c-10+'a'
    t_c=c&0xf
    s2++
    $if t_c<10
	*s2=t_c+'0'
    $else
	*s2=t_c-10+'a'
    *pn_len+=2
    return s

fncode: f_string_append_int
    #-- maximum uint_64 is 18446744073709551615 (20 digits)
    $call f_string, 30, n
    $if n==0
	*s2++='0'
    $else
        $call get_sign, n
	$call itoa, n, 10
        $call itoa_copy
    *pn_len=s2-s
    return s

fncode: f_string_append_float
    $call f_string, 40, d, n_digits
    $call get_sign, d

    n=(int)d
    d-=n

    $if 1.0-d<5e-7
	n++
	d=0.0

    $call itoa, n, 10
    $call ftoa_get_precision
    $call ftoa_carryover_int
    $call itoa_copy
    $if d>f_eps && n_digits>0
	*s2++='.'
	$for i=0:n_digits
	    d *= 10
	    n=(int)d
	    d-=n
	    s2[i]=n+'0'
	    # $print "s2 $i ($d): %c", s2[i]
	$if d>0.5
	    $call ftoa_carryover_float
	$else
	    $call ftoa_remove_zeros
	s2+=i
    $else
	#- omit decimals
    *pn_len=s2-s
    return s

#---------------------------------------- 
subcode: get_sign(n)
    $if $(n)<0
        *s2++='-'
        $(n)=(-$(n))

subcode: itoa(n, base)
    $local tpn_digits[40]
    $if $(n)==0
	tpn_digits[0]=0
	i=1
    $else
	i=0
	$while $(n)>0
	    tpn_digits[i++]=$(n) % $(base)
	    $(n)/=$(base)

subcode: itoa_copy
    $while i>0
        i--
        *s2++=tpn_digits[i] + '0'

#-------
subcode: ftoa_get_precision
    n_digits-=i
    $local double f_eps=0.5
    $for j=0:n_digits
	f_eps/=10.0

subcode: ftoa_carryover_int
    $if 1.0-d<f_eps
	$for j=0:i
	    $if tpn_digits[j]<9
		tpn_digits[j]++
		break
	    $else
		tpn_digits[j]=0
	$if j==i
	    tpn_digits[j]=1
	    i++

subcode: ftoa_carryover_float
    $while i>0
	i--
	$if s2[i]<'9'
	    s2[i]+=1
	    break
	$else
	    s2[i]='0'

subcode: ftoa_remove_zeros
    $while i>0 && s2[i-1]=='0'
	i--
	s2[i]='\0'

#---------------------------------------- 
subcode: string_expand(var, len, size, inc)
    $if $(len)+$(inc)>$(size)
	$temp n
	$if $(size)==0
	    $(n)=100
	$else
	    $(n)=$(size)
	$while $(len)+$(inc)>$(n)
	    $(n)=$(n)*5/3
	$(var)=(char *)realloc($(var), $(n)+1)
	# $call @assert, $(var)
	memset($(var)+$(size), 0, $(n)-$(size)+1)
	$(size)=$(n)

