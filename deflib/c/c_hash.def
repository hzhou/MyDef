subcode:: _autoload
    $include stdlib
    $include string
    $call hash_functions

# HASH ----------------------------------------------
subcode: hash_functions
    $struct(hash_entry) s_key, s_val, next
    $struct(hash) struct hash_entry * p_table, n_size, n_prime, n_top
    $list hash_new, 
    $list hash_expand, hash_free
    $list hash_getstr, hash_lookup

subcode: hash_free_val(p)
    $if $(p)->s_val && $(p)->s_val >(char *)100
	free($(p)->s_val)

subcode: hash_free_key(p)
    $if $(p)->s_key
	free($(p)->s_key)

subcode: hash_set_val(p, val)
    $call hash_free_val, $(p)
    $(p)->s_val=strdup($(val))

# -------------------------------------
# p_hash=hash_new(1000)
# -------------------------------------
subcode: hash_set(p_hash, key, val)
    $local struct hash_entry * p
    p=hash_lookup($(p_hash), $(key))
    $call hash_set_val, p, $(val)

# ---- macros ---------------------------------
subcode: local_hash(var)
    $local struct hash * $(var)
    $(var)=hash_new(100)

subcode: global_hash(var)
    $global struct hash * $(var)
    $(var)=hash_new(1000)

# -------------------------------------
fncode: hash_new(tn_initial_size)
    $local struct hash * p_hash
    $allocate p_hash
    $call hash_initialize, tn_initial_size
    return p_hash

subcode: hash_initialize(size)
    $call get_prime, $(size)
    p_hash->n_size=$(size)
    p_hash->n_prime=tn_prime
    p_hash->n_top=$(size)-1
    $allocate($(size)) p_hash->p_table
    memset(p_hash->p_table, 0, $(size)*sizeof(struct hash_entry *))

subcode: get_prime(size)
    tn_prime=$(size)*85/100
    $(set:comp=tn_prime % $1 == 0)
    $if $(comp:2)
	tn_prime++
    $while $(comp:3) || $(comp:5) || $(comp:7)
	tn_prime+=2

# ----
fncode: hash_expand(struct hash * p_hash)
    $local struct hash_entry * p_temp
    $local struct hash_entry * p
    p_temp=p_hash->p_table
    tn_old_size=p_hash->n_size
    tn_size=p_hash->n_size*2
    $call hash_initialize, tn_size
    $for i=0:tn_old_size
	p=p_temp+i
	$if p->s_key
	    $fcall hash_set_direct(p_hash, p->s_key, p->s_val)
    free(p_temp)

fncode: hash_free(struct hash * p_hash)
    tn_size=p_hash->n_size
    $for i=0:tn_size
	$local struct hash_entry * p
	p=p_hash->p_table+i
	$call hash_free_key, p
	$call hash_free_val, p
    free(p_hash->p_table)
    free(p_hash)


# -------------------------------------
fncode: hash_getstr(struct hash * p_hash, ts_key)
    $return_type char *
    $call hash_sub, getstr

fncode: hash_lookup(struct hash * p_hash, ts_key)
    $return_type struct hash_entry *
    $if p_hash->n_top==0
	hash_expand(p_hash)
    $call hash_sub, lookup

fncode: hash_set_direct(struct hash * p_hash, ts_key, ts_val)
    $call hash_sub, setdirect
# --
subcode: hash_sub(type)
    $local struct hash_entry * p
    $call hash_get_code, ts_key
    p=p_hash->p_table+tn_h

    $if ! p->s_key
	$(if:type=getstr)
	    return NULL
	$(elif:type=lookup)
	    p->s_key=strdup(ts_key)
	    return p
	$(elif:type=setdirect)
	    p->s_key=ts_key
	    p->s_val=ts_val
	    return p
    $else
	$while 1
	    $if strcmp(ts_key, p->s_key)==0
		$(if:type=getstr)
		    return p->s_val
		$(elif:type=lookup)
		    return p
		$(else)
		    return p
	    $elif p->next
		p=p->next
	    $else
		$(if:type=getstr)
		    return NULL
		$(elif:type=lookup)
		    $call hash_find_next
		    p->s_key=strdup(ts_key)
		    return p
		$(elif:type=setdirect)
		    p->s_key=ts_key
		    p->s_val=ts_val
		    return p

# --
subcode: hash_find_next
    $while p_hash->p_table[p_hash->n_top].s_key
	p_hash->n_top--
    p->next=p_hash->p_table+p_hash->n_top
    p=p->next

subcode: hash_get_code(key)
    $local unsigned char * s=(unsigned char *)$(key)
    tn_h=*s++
    tn_prime=p_hash->n_prime
    $while *s
	tn_h+=*s
	$if tn_h>tn_prime
	    tn_h-=tn_prime
	s++
