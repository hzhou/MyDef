# dynamic array ----------------------------------------------------
#     function does  not work because we want flexible element types

#    LESSON: 
# 	do not over worry about global name collision
#       rather, work on how to get program detect name collisions

subcode: local_darray(type, var)
    $local $(type) * $(var)=NULL
    $local int $(var)_len=0
    $local int $(var)_size=0

subcode: global_darray(type, var)
    $global $(type) * $(var)=NULL
    $global int $(var)_len=0
    $global int $(var)_size=0

subcode: use_darray(var)
    $(export:len=$(var)_len)
    $(export:size=$(var)_size)

# ----------------------------------------------------
subcode: darray_init(var)
    $(var)=NULL
    $(var)_len=0
    $(var)_size=0

subcode: darray_clear(var)
    free($(var))
    $call darray_init, $(var)

# ----------------------------------------------------
subcode: darray_check(var)
    $(export:len=$(var)_len)
    $(export:size=$(var)_size)

    $if $(len)+1>$(size)
	$my tn_temp
	tn_temp=(int)($(size)*2/3)
	$if tn_temp<64
	    tn_temp=64
	$call darray_expand_n, $(var), tn_temp

subcode: darray_check_n(var, n)
    $if $(var)_len+$(n)>$(var)_size
	$call darray_expand_n, $(var), $(var)_len+$(n)-$(var)_size
    
subcode: darray_expand_n(var, n)
    $get_pointer_type(type) $(var)
    $(var)_size+=$(n)
    $(var)=($(type) *)realloc($(var), $(var)_size*sizeof($(type)))
    $call @assert, $(var)

# ----------------------------------------------------
subcode: da_push(var, @val)
    $call darray_check, $(var)
    $get_pointer_type(type) $(var)
    $(var)[$(var)_len]=($(type))$(val) ;
    $(var)_len++
    # $(export:item=$(var)[$(var)_len-1])

subcode: da_pop(var)
    $(var)_len--
    $(export:item=$(var)[$(var)_len])
