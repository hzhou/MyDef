subcode:: _autoload
    $class matrix

subcode: set_vector(v, m)
    $set_var_attr $(v), dimension=$(m)

subcode: set_matrix(v, m, n)
    $set_var_attr $(v), dim1=$(m), dim2=$(n)
    $set_var_attr $(v), class=matrix

#---------------------------------------- 
subcode: matrix_print(v)
    $get_var_attr $(v), dim1, dim2
    $print \nMatrix $(v): $(dim1) x $(dim2)
    
    $fcall f_matrix_print($(v), $(dim1), $(dim2))

fncode: f_matrix_print(pf_A, m, n)
    $(set:M=pf_A[$1*n+$2])
    $(mset:limit=8, skip=3, skip2=5)
    $for i=0:m
	$if m>$(limit) && i==$(skip)
	    $print "      ... ..."
	    i+=m-$(skip2)
	$else
	    $for j=0:n
		$if n>$(limit) && j==$(skip)
		    printf "  ...  "
		    j+=n-$(skip2)
		$else
		    printf " %6g ", $(M:i,j)
	    $print

#---------------------------------------- 
subcode: vector_print(v)
    $print "\nVector $(v): -"
    $get_var_attr $(v), dimension
    $fcall f_vector_print($(v), $(dimension))

fncode: f_vector_print(pf_V, m)
    $(set:V=pf_V[$1])
    $print "%g-", $(V:0)
    $for i=1:m
	$if i>20
	    $print " ... -"
	    i=m-2
	$else
	    $print ", %g-", $(V:i)
    $print

#---------------------------------------- 
subcode: matrix_init(var, scope, @init)
    $call parse_matrix_init, $(init)
    $(if:use_double)
	$$(scope) double $(var)[$(dimension)]={$(init_str)}
    $(else)
	$$(scope) float $(var)[$(dimension)]={$(init_str)}
    $call set_matrix, $(var), $(dim1), $(dim2)

perlcode: parse_matrix_init
    my @rows=split /;/, $param
    my $n_rows=@rows

    my @t
    my $n_cols
    $foreach $r in @rows
	my @cols=split /\s*,\s*/, $r
	$if !$n_cols
	    $n_cols=@cols
	$else
	    $if $n_cols != @cols
		$print "parse_matrix_init: uneven rows [$param]\n"
	push @t, @cols
    my $init_str=join(",", @t)
    my $dimension=$n_rows*$n_cols
    MyDef::compileutil::set_current_macro("dim1", $n_rows)
    MyDef::compileutil::set_current_macro("dim2", $n_cols)
    MyDef::compileutil::set_current_macro("dimension", $dimension)
    MyDef::compileutil::set_current_macro("init_str", $init_str)


#---------------------------------------- 
subcode: matrix_LU(var)
    $get_var_attr $(var), dim1, dim2
    $(if:!P)
	$(export:P=$(var)_P)
	$local int * $(P)
	$allocate($(dim1)) $(P)
	$set_var_attr $(P), exit=free

	$(export:work=$(var)_work)
	$get_pointer_type(type) $(var)
	$local $(type) * $(work)
	$allocate($(dim1)) $(work)
	$set_var_attr $(work), exit=free

	$fcall f_matrix_LU($(var), $(P), $(work), $(dim1), $(dim2))

fncode: f_matrix_LU(pf_A, int * P, pf_work, m, n)
    $for i=0:m
	P[i]=i

    #$(set:M=pf_A[P[$1]*n+$2])
    $(set:M=pf_A[$1*n+$2])
    tn_row_size=n*sizeof(pf_A[0])

    $for i=0:m
	$my tf_max
	$(if:!skip_pivot)
	    $call matrix_LU_find_pivot
	    $if tn_pivot>i
		$call swap, P[i], P[tn_pivot]
	    $call matrix_row_swap, i, tn_pivot
	    # $dump tn_pivot, tf_max
	$(else)
	    tf_max=$(M:i,i)
	$for j=i+1:m
	    $my tf_l=$(M:j,i)/tf_max
	    $(M:j,i) = tf_l
	    $for k=i+1:n
		$(M:j,k)-=tf_l*$(M:i,k)

subcode: matrix_row_swap(i,j)
    $include string
    memcpy(pf_work, pf_A+$(i)*n, tn_row_size)
    memcpy(pf_A+$(i)*n, pf_A+$(j)*n, tn_row_size)
    memcpy(pf_A+$(j)*n, pf_work, tn_row_size)

subcode: matrix_LU_find_pivot
    $my tn_pivot=i
    tf_max=$(M:i,i)
    $for j=i+1:m
	$if tf_max<fabs($(M:j,i))
	    tn_pivot=j
	    tf_max=fabs($(M:j,i))

subcode: clear_pivots(var)
    $(if:P)
	free($(P))
	$set_var_attr $(P), exit=--
	$(unset:P)
	
	free($(work))
	$set_var_attr $(work), exit=--

fncode: f_pivot_vector(pf_V, int * P, pf_work, m)
    $include string
    memcpy(pf_work, pf_V, m*sizeof(pf_V[0]))
    $for i=0:m
	pf_V[i]=pf_work[P[i]]

#---------------------------------------- 
subcode: matrix_det(var)
    $call matrix_LU, $(var)

    $get_var_attr $(var), dim1, dim2

    $my tf_det
    tf_det=1.0
    $for i=0:$(dim1)
	tf_det *= $(var)[i*$(dim1)+i]

    $list f_permutation_parity
    $if f_permutation_parity($(P), $(dim1))
	tf_det=-tf_det

    $yield tf_det

fncode: f_permutation_parity(int * P, m)
    $local_allocate(m, 0) pn_check
    tn_count=0
    $while 1
	tn_start=-1
	$for i=0:m
	    $if pn_check[i]==0
		tn_start=i
		break
	$if tn_start<0
	    break

	i=tn_start
	pn_check[i]=1
	$while P[i]!=tn_start
	    i=P[i]
	    pn_check[i]=1
	    tn_count++
    return tn_count%2
#---------------------------------------- 
subcode: matrix_solve(var, b)
    $get_var_attr $(var), dim1, dim2

    $call matrix_LU, $(var)
    $fcall f_pivot_vector(b, $(P), $(work), $(dim1))

    $(set:M=$(var)[$1*$(dim2)+$2])
    $(set:V=$(b)[$1])

    #--- forward elimination ----
    $for i=0:$(dim1)-1
	$for j=i+1:$(dim1)
	    $(V:j)-=$(V:i)*$(M:j,i)
    # $call vector_print, $(b)
    #--- backward substitution ----
    $for i=$(dim1):0
	$(V:i) /= $(M:i,i)
	$for j=i:0
	    $(V:j) -= $(V:i)*$(M:j,i)

#---------------------------------------- 
subcode: matrix_inv(var)
    $call matrix_LU, $(var)

    $get_var_attr $(var), dim1, dim2
    $fcall f_matrix_LU_invert($(var), $(dim1))
    $for i=0:$(dim1)
	$fcall f_pivot_vector($(var)+i*$(dim1), $(P), $(work), $(dim1))


fncode: f_matrix_LU_invert(pf_A, n)
    $(set:M=pf_A[($1)*n+$2])

    #--- forward elimination ----
    $for i=1:n
	k=i-1
	$(M:i,k)=-$(M:i,k)
	$for j=k:0
	    $(M:i,j)=-$(M:i,j)+$(M:i,j+1)*$(M:i-1,j)
    #--- backward substitution ----
    $for i=0:n
	$(M:i,i)=1.0/$(M:i,i)
	$for j=0:i
	    $(M:i,j) *= $(M:i,i)
	$for j=i+1:n
	    $(M:i,j) *= $(M:i,i)

	$for k=0:i
	    $for j=0:i
		$(M:k,j) -= $(M:k,i)*$(M:i,j)
	    $for j=i+1:n
		$(M:k,j) -= $(M:k,i)*$(M:i,j)
	    $(M:k,i) = -$(M:k,i)*$(M:i,i)

#---------------------------------------- 
#- Normalized symmetric matrix A=LDL'
#- A = LDL'
fncode: f_matrix_cholesky(pf_A, n)
    $(set:M=pf_A[$1*n+$2])
    # $call set_matrix, A, n, n
    #---- LDL' ----
    $for i=0:n
	tf_pivot=$(M:i,i)
	$for j=i+1:n
	    $my tf_l=$(M:j,i)/tf_pivot
	    $(M:j,i) = tf_l
	    $for k=i+1:n
		$(M:j,k)-=tf_l*$(M:i,k)
    #---- split D ----
    $for i=0:n
	$(M:i,i)=sqrt($(M:i,i))
	$for j=i+1:n
	    $(M:i,j)=$(M:j,i)

#- inv(A) = inv(L)' inv(D) inv(L)
fncode: f_matrix_cholesky_inverse(pf_A, n)
    $(set:M=pf_A[$1*n+$2])
    $for i=1:n
	k=i-1
	$(M:i,k)=-$(M:i,k)
	$for j=k:0
	    $(M:i,j)=-$(M:i,j)+$(M:i,j+1)*$(M:i-1,j)
    $for i=0:n
	$(M:i,i)=1.0/$(M:i,i)
	$for j=i+1:n
	    $(M:i,j)=$(M:j,i)

#- V = inv(sqrt(D)) inv(L)' V
fncode: f_matrix_cholesky_inverse_transform(pf_A, n, pf_V)
    $(set:M=pf_A[$1*n+$2])
    $for i=0:n
	tf_sum=pf_V[i]
	$for j=i+1:n
	    tf_sum+=$(M:j,i)*pf_V[j]
	pf_V[i]=tf_sum*$(M:i,i)

#---------------------------------------- 
#- Lapack routines
#---------------------------------------- 

subcode: m_get_inverse(M, n)
    tn_work=4*$(n)
    $local int * pn_ipiv
    $local_allocate(tn_work) pn_ipiv
    $local double * pf_work
    $local_allocate(tn_work) pf_work

    tn_M=$(n)
    tn_info=0
    dgetrf_(&tn_M, &tn_M, $(M), &tn_M, pn_ipiv, &tn_info)
    dgetri_(&tn_M, $(M), &tn_M, pn_ipiv, pf_work, &tn_work, &tn_info)
    $(if:PRINT_INFO=1)
        $dump(inverse) tn_info

