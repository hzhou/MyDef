page: cfunctions
    type: pm
    output_dir: lib/MyDef
    subcode: main
	$call c_main

subcode: c_main
    use MyDef::dumpout;
    use MyDef::regex;
    package MyDef::cfunctions;

    my $debug;
    ##########################################
    our $define_id_base=1000;
    our %defines;
    our %includes;
    our %functions;
    our %stock_functions=("printf"=>1);
    our @function_declare_list;
    our %enums;
    our @enum_list;
    our %structs;
    our @struct_list;

    our %var_type_cast;

    # -- global variables
    our $global_type={};
    our $global_flag={};
    our @global_list;

    our @initcodes;

    my $cur_indent;
    our $cur_function;

    sub get_var_type {
	my $name=shift;
	if($cur_function and $cur_function->{var_type}->{$name}){
	    return $cur_function->{var_type}->{$name};
	}
	else{
	    return $global_type->{$name};
	}
    }
    sub get_var_flag {
	my $name=shift;
	if($cur_function->{var_flag}->{$name}){
	    return $cur_function->{var_flag}->{$name};
	}
	else{
	    return $global_flag->{$name};
	}
    }

    # ----
    my %function_flags;
    sub set_function_flag {
	my ($k, $v)=@_;
	$function_flags{$k}=$v;
    }
    #----
    our @func_var_hooks;
    our @func_extra_init;
    our @func_extra_release;
    our @func_pre_assign;
    our @func_post_assign;
    #----
    our %misc_vars;
    #----
    our $except;
    ############################################
    our %type_name=(
	c=>"char",
	i=>"int",
	j=>"int",
	k=>"int",
	m=>"int",
	n=>"int",
	f=>"float",
	d=>"double",
	count=>"int",
    );
    our %type_prefix=(
	n=>"int",
	ui=>"unsigned int",
	c=>"char",
	"uc"=>"unsigned char",
	b=>"int",
	s=>"char *",
	v=>"unsigned char *",
	f=>"float",
	d=>"double",
	"time"=>"time_t",
	"file"=>"FILE *",
	"strlen"=>"STRLEN",
	"has"=>"int",
	"is"=>"int",
    );

    our %fntype;

    my %lib_include=(
	glib=>"glib.h",
    );

    my %type_include=(
	time_t=>"time.h",
    );

    # --
    my %text_include=(
	"printf"=>"stdio.h",
	"sin|cos|sqrt"=>"math.h",
	"malloc"=>"stdlib.h",
	"strlen"=>"string.h",
	"strdup"=>"string.h",
	"fstat"=>"sys/stat.h",
    );
    sub check_text_includes {
	my $l=shift;
	while(my ($k, $v)=each %text_include){
	    if($l=~/$k/){
		if($v=~/(\S+)/){
		    $includes{"<$1>"}=1;
		}
	    }
	}
    }

    sub register_type_prefix {
	my ($k, $v)=@_;
	$type_prefix{$k}=$v;
    }
    ############################################
    # A registry to hold any parsing variables, such as regex_var, regex_pos, regex_end
    my %registry;

    ############################################
    sub init {
	%includes=();
	$if $MyDef::def->{"macros"}->{"use_double"}
	    $MyDef::cfunctions::type_name{f}="double";
	    $MyDef::cfunctions::type_prefix{f}="double";
	MyDef::dumpout::init_funclist();
    }

    sub modeswitch {
	my ($pmode, $mode, $out)=@_;
	if($mode=~/(\w+)-(.*)/){
	    my $fname=$1;
	    my $t=$2;
	    if($fname eq "n_main"){
		$fname="main";
	    }
	    my $fidx=open_function($fname, $t);
	    push @$out, "OPEN_FUNC_$fidx";
	    $cur_indent=0;
	    return 1;
	}
    }

    sub open_function {
	my ($fname, $t)=@_;
	my @plist=split /,/, $t;
	# -- var_list: list of local variables
	# -- var_type: types of local variables
	# -- var_flag: flags
	my $func= {param_list=>[], var_list=>[], var_type=>{}, var_flag=>{}, var_init=>{}, init=>[], finish=>[]};

	while(my ($k, $v)=each %function_flags){
	    $func->{$k}=$v;
	}
	$func->{name}=$fname;
	my $pbuf=$func->{param_list};
	my $var_type=$func->{var_type};
	foreach my $p(@plist){
	    if($p=~/(\S.*)\s+(\S+)\s*$/){
		push @$pbuf, "$1 $2";
		$var_type->{$2}=$1;
	    }
	    else{
		if($fntype{$p}){
		    push @$pbuf, $fntype{$p};
		    $var_type->{$p}="function";
		}
		else{
		    my $t= get_c_type($p);
		    push @$pbuf, "$t $p";
		    $var_type->{$p}=$t;
		}
	    }
	}
	# --
	if($func->{name}){
	    my $name=$func->{name};
	    push @function_declare_list, $name;
	    $functions{$name}=$func;
	}
	# --
	$cur_function=$func;
	#print "Set Curfunction $func->{name} = $func\n";
	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;
    }

    sub open_closure {
	my ($open, $close)=@_;
	my $func= {"var_list"=>[], var_type=>{}};
	$func->{openblock}=[$open];
	$func->{closeblock}=[$close];
	# --
	$cur_function=$func;
	#print "Set Curfunction Anonymous = $func\n";
	my $fidx=MyDef::dumpout::add_function($func);
	return $fidx;
    }

    sub declare_var {
	my ($var, $type)=@_;
	$cur_function->{var_type}->{$var}=$type;
    }


    # ---------------------------
    sub parsecode {
	my ($l, $custom, $out)=@_;
	if($l=~/^\s*PRINT\s+(.*)$/){
	    fmt_print($1, $out);
	}
	# $function(param1) param2 --------------------------------
	elsif($l=~/^\s*\$(\w+)\((.*)\)\s+(.*)$/){
	    return parsecode_func_param($out, $1, $2, $3);
	}
	# $function param  --------------------------------------------
	elsif($l=~/^\s*\$(\w+)\s*(.*)$/){
	    return parsecode_func($out, $1, $2);
	}
	elsif($custom and $custom->($l, $out)){
	}
	else{
	    #print "parsecode residue: [$l]\n";
	    if($l=~/^return\b/){
		func_return($l, $out);
	    }
	    elsif($l=~/^SOURCE_INDENT/){
		$cur_indent++;
	    }
	    elsif($l=~/^SOURCE_DEDENT/){
		$cur_indent--;
	    }

	    # More difficult parsing, consider moving to a C parser
	    check_expotential(\$l);
	    if($l=~/^(push|unshift|pop|shift)\s+(\w+),\s*(.*)/){
		if($1 eq "push"){
		    $l=array_push($out, $2, $3);
		}
		elsif($1 eq "unshift"){
		    $l=array_unshift($out, $2, $3);
		}
		elsif($1 eq "pop"){
		    $l=array_pop($out, $2);
		}
		elsif($1 eq "shift"){
		    $l=array_shift($out, $2);
		}
	    }
	    check_functioncall(\$l);
	    check_termination(\$l);
	    if($l=~/^[^'"]*=/){
		if($l=~/^(\w+)->\{(.*)\}\s*=\s*(.+)/){
		    $l=hash_assign($out, $1, $2, $3);
		}
		elsif($l=~/^(\w+)\s*=\s*(\w+)->\{(.*)\}/){
		    $l=hash_fetch($out, $2, $3, $1);
		}
		elsif($l=~/^(\w+)\s*=\s*(shift|pop)\s+(\w+)/){
		    if($2 eq "shift"){
			$l=array_shift($out, $3, $1);
		    }
		    elsif($2 eq "pop"){
			$l=array_pop($out, $3, $1);
		    }
		}
		check_assignment(\$l, $out);
	    }
	    if($l){
		push @$out, $l;
	    }
	}
	return 0;
    }

    sub single_block {
	my ($t, $out)=@_;
	push @$out, "$t\{";
	push @$out, "INDENT";
	push @$out, "BLOCK";
	push @$out, "DEDENT";
	push @$out, "}";
	return "NEWBLOCK";
    }

    sub parsecode_func_param {
	my ($out, $func, $param1, $param2)=@_;
	if($func eq "allocate"){
	    allocate($out, $param1, $param2);
	}
	elsif($func eq "dump"){
	    debug_dump($param2, $param1, $out);
	}
	elsif($func eq "register_prefix"){
	    $param2=~s/^\s+//;
	    $param2=~s/\s+$//;
	    $type_prefix{$param1}=$param2;
	}
	elsif($func eq "register_name"){
	    $param2=~s/^\s+//;
	    $param2=~s/\s+$//;
	    $type_name{$param1}=$param2;
	}
	elsif($func eq "register_include"){
	    $param2=~s/^\s+//;
	    $param2=~s/\s+$//;
	    $type_include{$param1}.=",$param2";
	}
	elsif($func eq "struct"){
	    if(!$structs{$param1}){
		push @struct_list, $param1;
		$structs{$param1}=make_struct($param1, $param2);
		$type_prefix{"st$param1"}="struct $param1";
	    }
	}
	elsif($func eq "get_type"){
	    my $type=get_var_type($param2);
	    return "SET:$param1=$type";
	}
	elsif($func eq "get_pointer_type"){
	    my $type=pointer_type(get_var_type($param2));
	    return "SET:$param1=$type";
	}
	elsif($func eq "enum"){
	    if(!$enums{$param1}){
		push @enum_list, $param1;
		$enums{$param1}=$param2;
	    }
	}
	elsif($func eq "enumbit"){
	    my $base=0;
	    my @plist=split /,\s+/, $param2;
	    foreach my $t(@plist){
		$defines{"$param1\_$t"}=0x1<<$base;
		$base++;
	    }
	}
	return 0;
    }

    sub parsecode_func {
	my ($out, $func, $param)=@_;
	## Pre-Process condition clause
	while($param =~ /(\S+)\s+eq\s+"(.*?)"/){
	    my ($var, $key)=($1, $2);
	    my $keylen=length($key);
	    $param=$`."strncmp($var, \"$key\", $keylen)==0".$';
	}
	## All the functions
	if($func eq "block"){
	    return single_block($param, $out);
	}
	elsif($func eq "allocate"){
	    allocate($out, 1, $param);
	}
	elsif($func =~/^except/){
	    return single_block($except, $out);
	}
	elsif($func =~ /^(if|while|switch|(el|els|else)if)$/){
	    my $name=$1;
	    if($2){
		$name="else if";
	    }
	    my $p=parse_condition($param, $out);
	    return single_block("$name($p)", $out);
	}
	elsif($func eq "else"){
	    return single_block("else", $out);
	}
	elsif($func eq "for"){
	    if($param=~/(\w+)=(.*?):(.*?)(:.*)?$/){
		my ($var, $i0, $i1, $step)=($1, $2, $3, $4);
		func_add_var($var, undef, $i0);
		my $stepclause;
		if($step){
		    my $t=substr($step, 1);
		    if($t eq "-1"){
			$stepclause="$var=$i0;$var>$i1;$var--";
		    }
		    elsif($t=~/^-/){
			$stepclause="$var=$i0;$var>$i1;$var=$var$t";
		    }
		    elsif($t eq "1"){
			$stepclause="$var=$i0;$var<$i1;$var++";
		    }
		    else{
			$stepclause="$var=$i0;$var<$i1;$var+=$t";
		    }
		}
		else{
		    $stepclause="$var=$i0;$var<$i1;$var++";
		}
		return single_block("for($stepclause)", $out);
	    }
	    else{
		print "\$for mismatch [$param]\n";
	    }
	}
	elsif($func eq "return_type"){
	    $cur_function->{ret_type}=$param;
	}
	elsif($func eq "parameter"){
	    my @plist=split /,\s*/, $param;
	    my $fplist=$cur_function->{param_list};
	    foreach my $p(@plist){
		push @$fplist, $p;
		if($p=~/(.*)\s+(\w+)\s*$/){
		    $cur_function->{var_type}->{$2}=$1;
		}
	    }
	}
	elsif($func eq "mu_skip"){
	    my @plist=split /,\s*/, $param;
	    foreach my $p(@plist){
		$cur_function->{mu_skip}->{$p}=1;
	    }
	}
	elsif($func eq "mu_enable"){
	    mu_enable();
	}
	elsif($func eq "include"){
	    my @flist=split /,\s+/, $param;
	    foreach my $f(@flist){
		if($f=~/\.h$/){
		    $includes{"\"$f\""}=1;
		}
		else{
		    $includes{"<$f.h>"}=1;
		}
	    }
	}
	elsif($func eq "define") {
	    push @$out, "#define $param";
	}
	elsif($func eq "define_id_base") {
	    $define_id_base=$param;
	}
	elsif($func eq "define_id") {
	    $define_id_base++;
	    $defines{$param}=$define_id_base;
	}
	elsif($func eq "uselib"){
	    my @flist=split /,\s+/, $param;
	    foreach my $f(@flist){
		$includes{"lib$f"}=1;
		if($lib_include{$f}){
		    add_include($lib_include{$f});
		}
	    }
	}
	elsif($func eq "fntype"){
	    # Similar to type_name, but for funtion pointer types
	    if($param=~/^.*?\(\s*\*\s*(\w+)\s*\)/){
		$fntype{$1}=$param;
	    }
	}
	elsif($func eq "debug_mem"){
	    push @$out, "debug_mem=1;";
	    $misc_vars{"debug_mem"}=1;
	}
	elsif($func eq "namespace"){
	    my @vlist=split /,\s+/, $param;
	    foreach my $v(@vlist){
		global_namespace($v);
	    }
	}
	elsif($func eq "global"){
	    my @vlist=split /,\s+/, $param;
	    foreach my $v(@vlist){
		if($v=~/^(\S.*)\s+(\S+)$/){
		    global_add_var($2, $1);
		}
		else{
		    global_add_var($v);
		}
	    }
	}
	elsif($func eq "globalinit"){
	    global_add_var($param);
	}
	elsif($func eq "local"){
	    my @vlist=split /,\s+/, $param;
	    foreach my $v(@vlist){
		if($v=~/^(\S.*)\s+(\S+)$/){
		    func_add_var($2, $1);
		}
		else{
		    func_add_var($v);
		}
	    }
	}
	elsif($func eq "localinit"){
	    func_add_var($param);
	}
	elsif($func eq "new"){
	    my @plist=split /,\s+/, $param;
	    foreach my $p(@plist){
		if($p){
		    func_add_var($p);
		    my $type=pointer_type(get_var_type($p));
		    $includes{"<stdlib.h>"}=1;
		    push @$out, "$p=($type*) malloc(sizeof($type));";
		}
	    }
	}
	elsif($func eq "free"){
	    my @plist=split /,\s+/, $param;
	    foreach my $p(@plist){
		my $ptype=get_var_type($p);
		struct_free($out, $ptype, $p);
	    }
	}
	elsif($func eq "regex_setup"){
	    my @plist=split /,\s+/, $param;
	    $registry{regex_var}=$plist[0];
	    $registry{regex_pos}=$plist[1];
	    $registry{regex_end}=$plist[2];
	}
	elsif($func eq "dump"){
	    debug_dump($param, undef, $out);
	}
	elsif($func eq "getopt"){
	    $includes{"<stdlib.h>"}=1;
	    $includes{"<unistd.h>"}=1;
	    my @vlist=split /,\s+/, $param;
	    my $cstr='';
	    foreach my $v(@vlist){
		if($v=~/(\w+):(\w+)(=.*)?/){
		    func_add_var($1);
		    if(substr($1, 0, 2) eq "b_"){
			$cstr.=$2;
			push @$out, "$1=0;";
		    }
		    elsif($3){
			push @$out, "$1$3;";
			$cstr.="$2::";
		    }
		    else{
			$cstr.="$2:";
		    }
		}
	    }
	    push @$out, "opterr = 1;";
	    func_add_var("c", "char");
	    push @$out, "while ((c=getopt(argc, argv, \"$cstr\"))!=-1){";
	    push @$out, "    switch(c){";
	    foreach my $v(@vlist){
		if($v=~/(\w+):(\w+)/){
		    push @$out, "        case '$2':";
		    my $type=get_var_type($1);
		    if(substr($1, 0, 2) eq "b_"){
			push @$out, "            $1=1;";
		    }
		    elsif($type eq "char *"){
			push @$out, "            $1=optarg;";
		    }
		    elsif($type eq "int" or $type eq "long"){
			push @$out, "            $1=atoi(optarg);";
		    }
		    elsif($type eq "float" or $type eq "double"){
			push @$out, "            $1=atof(optarg);";
		    }
		}
		push @$out, "            break;";
	    }
	    push @$out, "    }";
	    push @$out, "}";
	}
	return 0;
    }


    sub regex_init_code {
	print "regex_init_code\n";
	$includes{"<stdlib.h>"}=1;
	if(!$structs{"VMInst"}){
	    push @struct_list, "VMInst";
	    $structs{"VMInst"}=make_struct("VMInst", "int opcode, int c, int x, int y");
	    MyDef::regex::add_regex_vm_code(\@initcodes);
	}
	if(!$enums{"RegexOp"}){
	    push @enum_list, "RegexOp";
	    $enums{"RegexOp"}="Char, Match, Jmp, Split, AnyChar";
	}
    }
    sub parse_condition {
	my ($param, $out)=@_;
	if($param=~/^\s*(!)?\/(.*)\//){
	    my $var=$registry{regex_var};
	    my $pos=$registry{regex_pos};
	    my $end=$registry{regex_end};
	    my $t= MyDef::regex::parse_regex_match($2, $out, \&regex_init_code, $var, $pos, $end);
	    if($1){
		return "!($t)"
	    }
	    else{
		return $t;
	    }
	}
	elsif($param=~/(\w+)->\{(.*)\}/){
	    return hash_check($out, $1, $2);
	}
	else{
	    return $param;
	}
    }

    # ---------------------------
    sub allocate {
	my ($out, $param1, $param2)=@_;
	$includes{"<stdlib.h>"}=1;
	my $init;
	if($param1=~/(.*),\s*(.*)/){
	    $param1=$1;
	    $init=$2;
	}
	if($param1=~/[+-]/){
	    $param1="($param1)";
	}
	my @plist=split /,\s+/, $param2;
	foreach my $p(@plist){
	    if($p){
		func_add_var($p);
		$cur_function->{var_flag}->{$p}="retained";
		my $type=pointer_type(get_var_type($p));
		if($param1 == 1){
		    push @$out, "$p=($type*)malloc(sizeof($type));";
		    if($t->{constructor}){
			push @$out, "$1_constructor($p);";
		    }
		}
		else{
		    push @$out, "$p=($type*)malloc($param1*sizeof($type));";
		    if($t->{constructor}){
			func_add_var("i", "int");
			push @$out, "for(i=0;i<$param1;i++)$1_constructor($p\[i]);";
		    }
		}
		my $destructor="NULL";
		if($type=~/struct (\w+)/){
		    my $t=$structs{$1}->[0];
		    if($t->{destructor}){
			$destructor="&$1_destructor";
		    }
		}
		if($misc_vars{mu_enable}){
		    push @$out, "mu_add((void*)$p, sizeof($type), $param1, $destructor);";
		}
		if($misc_vars{"debug_mem"}==1){
		    push @$out, "printf(\"Mem \%d - $p \%d $type [%x]\\n\", mu_lastmem, $param1, $p);";
		}
	    }
	}
	if(defined $init and $init ne ""){
	    func_add_var("i", "int");
	    push @$out, "for(i=0;i<$param1;i++){";
	    foreach my $p(@plist){
		if($p){
		    push @$out, "    $p\[i]=$init;";
		}
	    }
	    push @$out, "}";
	}
    }

    # ------------------------------------------------------------- 
    # Supporting Struct
    # ------------------------------------------------------------- 
    sub make_struct {
	my ($name, $param)=@_;
	my @struct;
	my (@init, @exit);
	push @struct, {constructor=>undef, destructor=>undef};
	my @plist=split /,\s+/, $param;
	foreach my $p(@plist){
	    my $needfree;
	    my $init;
	    if($p=~/^@/){
		$needfree=1;
		$p=$';
	    }
	    if($p=~/(.*)(\S+)\s*=\s*(.*)/){
		$p="$1$2";
		$init=1;
		push @init, "p->$2=$3;";
	    }
	    if($p=~/(.*\S)\s+(\S+)\s*$/){
		push @struct, {type=>$1, name=>$2};
	    }
	    elsif($p eq "next" or $p eq "prev"){
		push @struct, {type=>"struct $name *", name=>$p};
		if(!$init){
		    push @init, "p->$p=NULL;";
		}
	    }
	    elsif($p eq "list"){
		push @struct, {type=>"struct $name\_node", name=>$p};
	    }
	    elsif($p eq "tail"){
		push @struct, {type=>"struct $name\_node *", name=>$p};
		if(!$init){
		    push @init, "p->$p=&p->list;";
		}
	    }
	    elsif($fntype{$p}){
		push @struct, {type=>"function", name=>$p};
	    }
	    elsif($p){
		my $type=get_c_type($p);
		push @struct, {type=>$type, name=>$p};
		if($type=~/\*/){
		    if(!$init){
			push @init, "p->$p=NULL;";
		    }
		    push @exit, "release(p->$p);";
		}
	    }
	    if($needfree){
		$struct[-1]->{needfree}=1;
	    }
	}
	if(@init){
	    $struct[0]->{constructor}=\@init;
	}
	if(@exit){
	    $struct[0]->{destructor}=\@init;
	}
	return \@struct;
    }

    sub dump_structs {
	my ($f)=@_;
	foreach my $name (@struct_list){
	    push @$f, "struct $name {\n";
	    my @plist=@{$structs{$name}};
	    my $info=$plist[0];
	    my $i=0;
	    foreach my $p(@plist){
		$i++;
		if($i==1){
		    next;
		}
		if($p->{type} eq "function"){
		    push @$f, "\t".$fntype{$p->{name}}.";\n";
		}
		else{
		    push @$f, "\t$p->{type} $p->{name};\n";
		}
	    }
	    push @$f, "};\n\n";
	    if($info->{"constructor"}){
		push @$f, "void $name\_constructor(struct $name* p){\n";
		foreach my $l(@{$info->{constructor}}){
		    push @$f, "    $l\n";
		}
		push @$f, "}\n";
	    }
	    if($info->{"destructor"}){
		push @$f, "void $name\_destructor(struct $name* p){\n";
		foreach my $l(@{$info->{destructor}}){
		    push @$f, "    $l\n";
		}
		push @$f, "}\n";
	    }
	    push @$f, "\n";
	}
    }

    sub add_struct {
	my ($stname, $pname)=@_;
	my $struct=$structs{$stname};
	#print "Struct $stname: $struct\n";
	if($struct){
	    foreach my $p(@$struct){
		if($p->{name} eq $pname){
		    return;
		}
	    }
	    if($fntype{$pname}){
		push @$struct, {type=>"function", name=>$pname};
	    }
	    else{
		my $type=get_c_type($pname);
		push @$struct, {type=>$type, name=>$pname};
	    }
	}
    }
    sub get_struct_element_type {
	my ($svar, $evar)=@_;
	my $stype=get_var_type($svar);
	if($stype=~/struct\s+(\w+)/){
	    my $struc=$structs{$1};
	    foreach my $p(@$struc){
		if($p->{name} eq $evar){
		    return $p->{type};
		}
	    }
	}
	#print STDERR "failed get_struct_element_type($svar, $evar)\n";
	return "void";
    }

    sub struct_free {
	my ($out, $ptype, $name)=@_;
	my $type=pointer_type($ptype);
	if($type=~/struct\s+(\w+)/ and $structs{$1}){
	    foreach my $p (@{$structs{$1}}){
		if($p->{needfree}){
		    struct_free($out, $p->{type}, "$name"."->".$p->{name});
		}
	    }
	}
	push @$out, "free($name);";
    }

    # ------------------------------------------------------------- 
    sub debug_dump {
	my ($param, $prefix, $out)=@_;
	my @vlist=split /,\s+/, $param;
	my @a1;
	my @a2;
	foreach my $v(@vlist){
	    push @a2, $v;
	    my $type=get_c_type($v);
	    if($type=~/^(float|double)/){
		push @a1,"$v=\%g";
	    }
	    elsif($type=~/^int/){
		push @a1,"$v=\%d";
	    }
	    elsif($type=~/^char \*/){
		push @a1, "$v=\%s";
	    }
	    elsif($type=~/^char/){
		push @a1,"$v=\%d";
	    }
	    else{
		print "debug_dump: unhandled $v - $type\n";
	    }
	}
	if($prefix){
	    push @$out, "fprintf(stderr, \"    :[$prefix] ".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	}
	else{
	    push @$out, "fprintf(stderr, \"    :".join(", ", @a1)."\\n\", ".join(", ", @a2).");";
	}
	$includes{"<stdio.h>"}=1;
    }
    # ---------------------------
    sub check_termination {
	my $l=shift;
	#$$l=~s/^\|//;
	if($$l=~/^\s*$/){
	}
	elsif($$l=~/(for|while|if|else if)\s*\(.*\)\s*$/){
	}
	elsif($$l!~/[:\{\};]\s*$/){
	    $$l.=";";
	}
    }
    sub check_expotential {
	my $l=shift;
	# x^4
	while($$l=~/\^([234])/){
	    my $t_p=$1;
	    my $t_tail=$';
	    my ($t_head, $t_exp)=last_exp($`);
	    my $t_trunk="$t_exp*" x ($t_p-1);
	    $t_trunk.=$t_exp;
	    $$l="$t_head($t_trunk)$t_tail";
	}
    }
    sub check_functioncall {
	my $l=shift;
	# func param1, param2
	if($$l=~/^(\w+)\s+(.*)$/ and ($functions{$1} or $stock_functions{$1})){
	    my $fn=$1;
	    my $t=$2;
	    $t=~s/;\s*$//;
	    $t=~s/\s+$//;
	    $$l="$fn($t);";
	}
    }
    sub check_assignment {
	my ($l, $out)=@_;
	if($cur_function and $$l=~/^[^'"]*=/){
	    my $tl=$$l;
	    $tl=~s/;+\s*$//;
	    if($tl=~/^\s*(.*?\w)\s*=\s*([^=].*)/){
		undef $$l;
		my ($left, $right)=($1, $2);
		# multi-assignment
		my @left=split /,\s*/, $left;
		my @right=split /,\s*/, $right;
		for(my $i=0; $i<=$#left; $i++){
		    do_assignment($left[$i], $right[$i], $out);
		}
	    }
	}
    }
    sub do_assignment {
	my ($left, $right, $out)=@_;
	if($debug){ print "do_assignment: $left = $right\n"; }
	my $type;
	if($left=~/^(.*?)\s+(\S+)$/){
	    $type=$1;
	    $left=$2;
	}
	if($left=~/^\w+$/){
	    func_add_var($left, $type, $right);
	    $type=get_var_type($left);
	    func_var_assign($type, $left, $right, $out);
	}
	elsif($left=~/(\w+)(\.|->)(\w+)/){
	    my $v1=$1;
	    my $v2=$3;
	    if($v1=~/^gns_(\w+)/){
		global_namespace($v1);
		add_struct($v1, $v2, $right);
	    }
	    my $stype=get_struct_element_type($v1, $v2);
	    func_var_assign($stype, $left, $right, $out);
	}
	else{
	    push @$out, "$left = $right;";
	}
    }
    sub last_exp {
	my $l=shift;
	my $tlen=length($l);
	my $i=$tlen-1;
	if(substr($l, $i, 1) eq ')'){
	    my $level=1;
	    while($i>1){
		$i--;
		if(substr($l, $i, 1) eq ')'){$level++;}
		if(substr($l, $i, 1) eq '('){$level--;}
		if($level==0){last;}
	    }
	}
	else{
	    while($i>0){
		if(substr($l, $i, 1) eq ']'){
		    my $level=1;
		    while($i>1){
			$i--;
			if(substr($l, $i, 1) eq ']'){$level++;}
			if(substr($l, $i, 1) eq '['){$level--;}
			if($level==0){last;}
		    }
		    $i--;
		    next;
		}
		elsif(substr($l, $i-1, 2) eq '->'){
		    $i-=2;
		    next;
		}
		elsif(substr($l, $i, 1)=~/[0-9a-zA-Z_.]/){
		    $i--;
		    next;
		}
		last;
	    }
	    if(substr($l, $i, 1)!~/[a-zA-Z_.]/){
		$i++;
	    }
	}
	my $t0=substr($l, 0, $i);
	my $t3=substr($l, $i, $tlen-$i);
	return ($t0, $t3);
    }

    # ---------------------------
    sub struct_set {
	my ($struct_type, $struct_var, $val, $out)=@_;
	my $struct=$structs{$struct_type};
	my @vals=split /,\s*/, $val;
	for(my $i=0; $i<=$#vals; $i++){
	    my $sname=$struct->[$i]->{name};
	    do_assignment("$struct_var\->$sname", $vals[$i], $out);
	}
    }
    sub struct_get {
	my ($struct_type, $struct_var, $var, $out)=@_;
	my $struct=$structs{$struct_type};
	my @vars=split /,\s*/, $var;
	for(my $i=0; $i<=$#vars; $i++){
	    my $sname=$struct->[$i]->{name};
	    do_assignment( $vars[$i],"$struct_var\->$sname", $out);
	}
    }
    # --
    sub hash_check {
	my ($out, $h, $name)=@_;
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	return "p_$h\->s_text";
    }
    sub hash_assign {
	my ($out, $h, $name, $val)=@_;
	my $p="p_$h";
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	push @$out, "if(p_$h\->s_text==NULL){p_$h->s_text=strdup($name);}";
	struct_set("$h\_node", "p_$h", $val, $out);
    }
    sub hash_fetch {
	my ($out, $h, $name, $var)=@_;
	func_add_var("p_$h", "struct $h\_node *");
	push @$out, "p_$h=hash_lookup_$h($name);";
	push @$out, "if(p_$h\->s_text){";
	struct_get("$h\_node", "p_$h", $var, $out);
	push @$out, "}";
	# use $except for the case where key does not exist.
	$except="else";
    }
    # --
    sub get_array_type {
	my ($var)=@_;
	if(my $type = get_var_type($var)){
	    return $type;
	}
	elsif($var_type_cast/{$var}){
	    return $var_type_cast{$var};
	}
	else{
	    return $var;
	}
    }
    sub array_push {
	my ($out, $v, $val)=@_;
	my $a=get_array_type($v);
	func_add_var("p_$a", "struct $a\_node *");
	push @$out, "p_$a=list_push_$a();";
	struct_set("$a\_node", "p_$a", $val, $out);
    }
    sub array_unshift {
	my ($out, $v, $val)=@_;
	my $a=get_array_type($v);
	func_add_var("p_$a", "struct $a\_node *");
	push @$out, "p_$a=list_unshift_$a();";
	struct_set("$a\_node", "p_$a", $val, $out);
    }
    sub array_pop {
	my ($out, $v, $var)=@_;
	my $a=get_array_type($v);
	if($var){
	    func_add_var("p_$a", "struct $a\_node *");
	    push @$out, "p_$a=list_pop_$a();";
	    struct_get("$a\_node", "p_$a", $var, $out);
	}
	else{
	    push @$out, "list_pop_$a();";
	}
    }
    sub array_shift {
	my ($out, $v, $var)=@_;
	my $a=get_array_type($v);
	if($var){
	    func_add_var("p_$a", "struct $a\_node *");
	    push @$out, "p_$a=list_shift_$a();";
	    struct_get("$a\_node", "p_$a", $var, $out);
	}
	else{
	    push @$out, "list_shift_$a();";
	}
    }

    # ---------------------------
    sub get_c_fmt {
	my $name=shift;
	my $type=get_var_type($name);
	if($type eq "int"){
	    return "%d";
	}
	elsif($type eq "char"){
	    return "%c";
	}
	elsif($type eq "char *"){
	    return "%s";
	}
    }

    sub fmt_print {
	my ($t, $out)=@_;
	my @fmt=split /(\$[0-9a-zA-Z_\[\]]+)/, $t;
	my @var;
	for (my $j=0; $j<@fmt; $j++){
	    if($fmt[$j]=~/^\$(\w+)(.*)/){
		push @var, "$1$2";
		$fmt[$j]=get_c_fmt($1);
	    }
	}
	if(@var){
	    push @$out, "printf(\"".join('', @fmt)."\", ".join(', ', @var).");";
	}
	else{
	    push @$out, "printf(\"$t\");";
	}
	$includes{"<stdio.h>"}=1;
    }

    # ---------------------------
    sub dump_init {
	my ($f, $custom_global)=@_;
	dump_includes($f);
	dump_defines($f);
	dump_enums($f);
	dump_structs($f);
	dump_globals($f, $custom_global);
	dump_function_declares($f);
	dump_code_list(\@initcodes, $f);
    }

    sub process_function_std {
	$cur_function=shift;
	my (@t0, @t1, @pre, @post);
	my $name=$cur_function->{name};
	# -- 
	if(!$cur_function->{openblock}){
	    if($name){
		my $ret_type=$cur_function->{ret_type};
		if(!$ret_type){$ret_type="void";}
		my $paramlist=$cur_function->{'param_list'};
		my @param_name_list;
		foreach my $p(@$paramlist){
		    if($p=~/(\w+)\s*$/){
			push @param_name_list, $1;
		    }
		}
		my $param_name_list_str=join(",", @param_name_list);

		my $param=join(', ', @$paramlist);
		push @t0, "$ret_type $name($param){";
	    }
	    $cur_function->{openblock}=\@t0;
	}
	# -- 
	if(!$cur_function->{closeblock}){
	    if($name){
		push @t1, "}";
		push @t1, "NEWLINE";
	    }
	    $cur_function->{closeblock}=\@t1;
	}

	# -- 
	if(!$cur_function->{has_return}){
	    #print "final var_release: $cur_function->{name}\n";
	    func_var_release(\@post);
	}
	my $var_init=$cur_function->{var_init};
	my $var_list=$cur_function->{var_list};
	if(@$var_list){
	    foreach my $v (@$var_list){
		push @pre, "$var_init->{$v};";
	    }
	    push @pre, "NEWLINE";
	}
	foreach my $tl(@{$cur_function->{init}}){
	    push @pre, $tl;
	}
	$cur_function->{preblock}=\@pre;

	# -- 
	foreach my $tl(@{$cur_function->{finish}}){
	    push @post, $tl;
	}
	$cur_function->{postblock}=\@post;
    }

    sub process_function {
	my ($funclist, $custom)=@_;
	foreach my $func(@$funclist){
	    if(!$custom or !$custom->($func)){
		process_function_std($func);
	    }
	}
    }

    sub dump_includes {
	my ($f)=@_;
	my @includes=keys %includes;
	foreach my $i (@includes){
	    if($i!~/^lib/){
		push @$f, "#include $i\n";
	    }
	}
	push @$f, "\n";
    }

    sub dump_defines {
	my ($f)=@_;
	while(my ($k, $t)=each %defines){
	    push @$f, "#define $k $t\n";
	}
    }

    sub dump_function_declares {
	my ($f)=@_;
	foreach my $t (@function_declare_list){
	    #print "function_declare: $t\n";
	    my $func=$functions{$t};
	    if(!$func->{skip_declare}){
		my $name=$func->{name};
		my $ret_type=$func->{'ret_type'};
		if(!$ret_type){$ret_type="void";}
		my $paramlist=$func->{'param_list'};
		my $param=join(', ', @$paramlist);
		push @$f, "$ret_type $name($param);\n";
	    }
	}
	push @$f, "\n";
    }

    sub dump_enums {
	my ($f)=@_;
	foreach my $name (@enum_list){
	    my $t=$enums{$name};
	    push @$f, "enum $name {$t};\n";
	}
    }

    sub dump_globals {
	my ($f, $custom)=@_;
	foreach my $v(@global_list){
	    if($custom and $custom->($v)){
	    }
	    else{
		push @$f, "$v;\n";
	    }
	}
	push @$f, "\n";
    }

    sub dump_code_list {
	my ($codelist, $f)=@_;
	foreach my $l(@$codelist){
	    push @$f, "$l\n";
	}
    }

    # ---------------------------
    sub func_add_var {
	my ($name, $type, $value)=@_;
	my $tail;

	if(!$cur_function){
	    return;
	}
	if(get_var_type($name)){
	    return;
	}
	if($name=~/(\S+)(=.*)/){
	    $name=$1;
	    $tail=$2;
	}
	my $var_list=$cur_function->{var_list};
	my $var_init=$cur_function->{var_init};
	my $var_type=$cur_function->{var_type};
	if($fntype{$name} and !$type){
	    $var_init->{$name}=$fntype{$name};
	    $var_type->{$name}="function";
	}
	else{
	    my ($array, $ptype);
	    if(!$type){
		if($value){
		    $type=infer_c_type($val);
		}
		if(!$type){
		    $type=get_c_type($name);
		}
	    }
	    if($name=~/(\w+)\[(.*)\]/){
		$name=$1;
		$array=$2;
		$ptype="$type *";
	    }
	    else{
		$ptype=$type;
	    }
	    $var_type->{$name}=$ptype;
	    if(!$tail){
		my $init_value=func_var_init($name, $type);
		if($init_value){
		    if($array){
			my $init=$cur_function->{init};
			func_add_var("i", "int");
			push @$init, "for(i=0;i<$array;i++){$name\[i] = $init_value;}";
		    }
		    else{
			$tail=" = $init_value";
		    }
		}
	    }
	    if($array){
		$var_init->{$name}="$type $name\[$array]$tail";
	    }
	    else{
		$var_init->{$name}="$type $name$tail";
	    }
	}
	push @$var_list, $name;
	#print "Add var $name, type: $var_type->{$name}, init: $var_init->{$name}\n";
    }

    sub func_return {
	my ($l, $out)=@_;
	if(!$cur_function->{ret_type}){
	    if($l=~/return\s+(.*)/){
		my $t=$1;
		if($t=~/(\w+)/){
		    my $type=get_var_type($1);
		    $cur_function->{ret_type}=$type;
		    $cur_function->{ret_var}=$1;
		}
		elsif($t=~/^"/){
		    $cur_function->{ret_type}="char *";
		}
		elsif($t=~/^'/){
		    $cur_function->{ret_type}="char";
		}
		elsif($t=~/^\d+\./){
		    $cur_function->{ret_type}="float";
		}
		elsif($t=~/^\d+/){
		    $cur_function->{ret_type}="int";
		}
	    }
	    else{
		$cur_function->{ret_type}="void";
	    }
	}
	if($cur_indent<=1){
	    $cur_function->{has_return}=1;
	}
	func_var_release($out);
    }

    sub func_var_init {
	my ($v, $type)=@_;
	my $init;
	foreach my $fh(@func_var_hooks){
	    if($fh->{var_check}->($type)){
		$init=$fh->{var_init}->($v, $type);
	    }
	}
	if($init){
	    return $init;
	}
    }

    sub func_var_release {
	my ($out)=@_;
	my $ret_type=$cur_function->{ret_type};
	my $ret_var=$cur_function->{ret_var};
	my $var_list=$cur_function->{var_list};
	my $var_type=$cur_function->{var_type};
	if(@$var_list and @func_var_hooks){
	    foreach my $name (@$var_list){
		my $type=$var_type->{$name};
		if($name ne $ret_var){
		    foreach my $fh(@func_var_hooks){
			if($fh->{var_check}->($type)){
			    $fh->{var_release}->($type, $name, $out);
			}
		    }
		}
	    }
	}
    }

    sub func_var_assign {
	my ($type, $name, $val, $out)=@_;
	if($debug){print "func_var_assign: $type $name = $val\n"}
	my $done_out;
	if(@func_var_hooks){
	    foreach my $fh(@func_var_hooks){
		if($fh->{var_check}->($type)){
		    $fh->{var_pre_assign}->($type, $name, $val, $out);
		    push @$out, "$name = $val;";
		    $fh->{var_post_assign}->($type, $name, $val, $out);
		    $done_out=1;
		    last;
		}
	    }
	}
	if(!$done_out){
	    push @$out, "$name = $val;";
	}
    }

    sub global_add_var {
	my $name=shift;
	my $type=shift;
	my $tail;

	if($global_type->{$name}){
	    return;
	}

	if($name=~/(\S+)(=.*)/){
	    $name=$1;
	    $tail=$2;
	}
	if($fntype{$name} and !$type){
	    $global_type->{$name}="function";
	    push @global_list, $fntype{$name};
	}
	else{
	    if(!$type){
		$type=get_c_type($name);
	    }
	    $global_type->{$name}=$type;
	    push @global_list, "$type $name$tail";
	}
    }

    sub global_namespace{
	my $v=shift;
	my $stname="ns$v";
	if(!$structs{$stname}){
	    push @struct_list, $stname;
	    $structs{$stname}=make_struct($stname, "");
	    $type_name{$v}="struct $stname";
	    global_add_var($v);
	}
    }
    ############################################
    sub mu_enable {
	$misc_vars{mu_enable}=1;
	push @func_var_hooks, {var_check=>\&mu_var_check, var_init=>\&mu_var_init, var_pre_assign=>\&mu_pre_assign, var_post_assign=>\&mu_post_assign, var_release=>\&mu_release};
    }

    sub mu_var_check {
	my ($type)=@_;
	if($type=~/\*$/){
	    return 1;
	}
	else{
	    return 0;
	}
    }

    sub mu_var_init {
	return "NULL";
    }
    sub mu_pre_assign {
	my ($type, $name, $val, $out)=@_;
	if($var_flag->{$name} eq "retained"){
	    my $var_flag=$cur_function->{var_flag};
	    push @$out, "if($name){mu_release($name);}";
	    $var_flag->{$name}=0;
	}
    }
    sub mu_post_assign {
	my ($type, $name, $val, $out)=@_;
	print "mu_post_assign: $type $name = $val\n";
	my $var_flag=$cur_function->{var_flag};
	print "mu_post_assign: $name = $val\n";
	if($val=~/^\s*(NULL|0)\s*$/i){
	}
	elsif($val=~/^\s*(\w+)(.*)/){
	    $var_flag->{$name}="retained";
	    print "retain $name\n";
	    my $name=$1;
	    my $tail=$2;
	    if($tail=~/^\s*\(/ and MyDef::is_sub($name)){
	    }
	    else{
		push @$out, "mu_retain($name);";
	    }
	}
    }
    sub mu_release {
	my ($type, $name, $out)=@_;
	my $var_flag=$cur_function->{var_flag};
	print "$cur_function->{name} mu_release($name): flag: $var_flag->{$name}\n";
	if($func->{mu_skip}->{$name}){
	}
	elsif($var_flag->{$name} eq "retained"){
	    push @$out, "if($name){";
	    push @$out, "INDENT";
	    if($type=~/^struct\s+(\w+)\s*$/){
		my $t=$structs{$1}->[0];
		if($t->{destructor}){
		    push @$out, "$1_destructor($name);";
		}
	    }
	    push @$out, "mu_release($name);";
	    push @$out, "DEDENT";
	    push @$out, "}";
	}
    }
    ############################################
    sub infer_c_type {
	my $val=shift;
	if($val=~/^[+-]?\d+\s*$/){
	    return "int";
	}
    }
    sub get_c_type_word {
	my $name=shift;
	if($debug){
	    print "get_c_type_word: [$name]\n";
	    foreach my $prefix(keys %type_prefix){
		print "   -- prefix: $prefix -> $type_prefix{$prefix}\n";
	    }
	}
	if($name=~/^([a-z]+)/){
	    $prefix=$1;
	    if($type_prefix{$prefix}){
		return $type_prefix{$prefix};
	    }
	    elsif(substr($prefix, 0, 1) eq "t"){
		return get_c_type_word(substr($prefix,1));
	    }
	    elsif(substr($prefix, 0, 1) eq "p"){
		return get_c_type_word(substr($prefix,1)).'*';
	    }
	    elsif($name=~/^st(\w+)/){
		return "struct $1";
	    }
	    else{
		#print "Failed to get_c_type_word $name";
	    }
	}
    }

    sub get_c_type {
	my $name=shift;
	#if($name=~/ntop/){ $debug=1; } else{ $debug=0; }
	my $check;
	my $type="void";
	if($name=~/.*\.([a-zA-Z].+)/){
	    #print "ctype: $name->$1\n";
	    $name=$1;
	}
	if($type_name{$name}){
	    $type= $type_name{$name};
	}
	elsif($name=~/([a-zA-Z]+)_(.*)/){
	    my $t1=$1;
	    my $t2=$2;
	    my $t=get_c_type_word($t1);
	    if(!$t){
		if($t1=~/^\w+$/){
		    $type=get_c_type_word($t2);
		}
	    }
	    elsif($t=~/^\*/){
		$type=get_c_type_word($t2).$t;
	    }
	    else{
		$type=$t;
	    }
	}
	else{
	    $type=get_c_type_word($name);
	}

	if(!$type){
	    $type="void";
	}
	elsif($type =~/^\*/){
	    $type="void";
	}
	# --
	while($name=~/\[.*?\]/g){
	    $type=pointer_type($type);
	}
	# --
	if($type_include{$type}){
	    add_include($type_include{$type});
	}
	#if($type eq "void"){warn "get_c_type $name failed\n";}
	return $type;
    }

    sub add_include {
	my $l=shift;
	my @tlist=split /,/, $l;
	foreach my $t(@tlist){
	    if($t=~/(\S+)/){
		$includes{"<$1>"}=1;
	    }
	}
    }
    sub pointer_type {
	my ($t)=@_;
	$t=~s/\s*\*\s*$//;
	return $t;
    }

    1;
