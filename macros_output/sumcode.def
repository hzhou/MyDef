# $sumcode sum = A[i]
subcode: parsecode_sum_support(style)
    &call parsecode_sum_frame
        $call sumcode_parse

# $sumcode(100) sum = A[i]
subcode: parsecode_sum_simple(style)
    &call parsecode_sum_frame
        $call sumcode_simple_parse

#----------------------------------------------- 
subcode: parsecode_sum_frame
    $if $debug
        $print parsecode_sum: [$param]
    my $h={}
    $call sumcode_init_style, $(style)
    BLOCK
    $call parsecode_sum_common
    my $codelist=sumcode_generate($h)
    MyDef::compileutil::parseblock({source=>$codelist, name=>"sumcode"})
    return

    subcode: parsecode_sum_common
        $(for:left in left, right)
            $h->{$(left)}=$$(left)
            $h->{$(left)_idx}=\@$(left)_idx
        $h->{klist} = \@k_list
        $foreach $k in @k_list
            $h->{"$k-init"}="$(my) $(k)_$k"
            $h->{"$k-var"}="$(k)_$k"
        $if @right_idx
            $if $left=~/^(\$?\w+)$/
                $h->{sum}=$1
            $else
                $h->{sum}="$(sum)"
            $h->{"sum-init"}="$(mytype) $h->{sum}"

#---------------------------------------- 
#- '$' is not an operator, so if it appears, let's assume it is 
#-     part of variable name
#---------------------------------------- 
subcode: sumcode_init_style(style)
    $(if:style=c)
        # my $type="double"
        my $type
        $(export:mytype=\$my $type)
        $(export:my=\$my int)
        $(mexport:sum=sum,i=_,k=k)
    $(elif:style=perl)
        $(export:mytype=my)
        $(export:my=my)
        $(mexport:sum=\$sum,i=\$i,k=\$k)

subcode: sumcode_gen_sumvar_c
    $sum="sum"
    push @code, "\$my $type $sum"
    push @code, "$sum = 0"

subcode: sumcode_gen_sumvar_perl
    $sum="\$sum"
    push @code, "my $sum = 0"

#---------------------------------------- 
#########################################
subcode: sumcode_parse
    my ($left, $right)
    $if $param=~/(.*?)\s*(?<![\+\-\*\/%&\|><=])=(?!=)\s*(.*)/
        ($left, $right)=($1, $2)
    $else
        $left=$param

    my (%k_hash, @k_list)

    my %var_hash
    my (@left_idx, @right_idx)
    $call sumcode_get_idx, left
    $if $right
        $call sumcode_get_idx, right

subcode: sumcode_get_idx(left)
    my @segs=split /(\w+\[[ijkl,]*?\])/, $$(left)
    $foreach $s in @segs
        $if $s=~/^(\w+)\[([ijkl,]*?)\]$/
            $if $var_hash{$s}
                $s=$var_hash{$s}
            $else
                #---- translate var, populate $type, %k_hash, dim_hash ----
                $call sumcode_var
                $var_hash{$s}=$t
                $s=$t
    $$(left)=join '', @segs
    $$(left)=~s/\b([ijkl])\b/$(i)$1/g

subcode: sumcode_var
    my $t
    my ($v, $idx_str)=($1, $2)
    my $var=find_var($v)
    $(if:style=c)
        $if !$type
            $type=pointer_type($var->{type})

    my @idxlist=split /,/, $idx_str
    $if @idxlist==1
        my $idx=$idx_str
        $t="$v\[$(i)$idx\]"
    $else
        my $k=join('', @idxlist)
        $if !$k_hash{$k}
            $k_hash{$k}=1
            push @k_list, $k
        $t="$v\[$(k)_$k\]"
    my $i=0
    $foreach $idx in @idxlist
        $i++
        $call sumcode_idx

subcode: sumcode_idx
    #-- get idx dimension based on var ----
    my ($dim, $inc)
    $if $var->{"dim$i"}
        $dim=$var->{"dim$i"}
    $elif $var->{"dimension"} and $i==1
        $dim=$var->{"dimension"}
    $else
        $call warn, sumcode: var $v missing dimension $i

    #-- set dim_hash ----
    $if !$h->{"$idx-dim"}
        push @$(left)_idx, $idx
        $h->{"$idx-dim"}=$dim
        $h->{"$idx-var"}="$(i)$idx"
    $else
        $if $h->{"$idx-dim"} ne $dim
            my $old_dim=$h->{"$idx-dim"}
            $print "sumcode dimesnion mismatch: $old_dim != $dim"

#---------------------------------------- 
#- sumcode simple
#---------------------------------------- 
subcode: sumcode_simple_parse
    # $print sumcode_simple_parse: $param
    my ($left, $right)
    $if $param=~/(.*?)\s*(?<![\+\-\*\/%&\|><=])=(?!=)\s*(.*)/
        ($left, $right)=($1, $2)
    $else
        $left=$param

    my @idxlist=('i','j','k','l')
    my @dimlist=MyDef::utils::proper_split($dimstr)
    my (@left_idx, @right_idx)
    $foreach $dim in @dimlist
        my $idx=shift @idxlist
        $h->{"$idx-dim"}=$dim
        $h->{"$idx-var"}="$(i)$idx"

        $if $left=~/\b$idx\b/
            push @left_idx, $idx
        $else
            push @right_idx, $idx

    my (%k_hash, @k_list)
    $call sumcode_simple_get_idx, left
    $if $right
        $call sumcode_simple_get_idx, right
    $(if:style=c)
        $if @right_idx and !$type
            $if $right=~/^(\w+)/
                my $var=find_var($1)
                $if $right=~/^\w+\[/
                    $type=pointer_type($var->{type})
                $else
                    $type=$var->{type}


subcode: sumcode_simple_get_idx(left)
    my @segs=split /(\[[ijkl,]*?\])/, $$(left)
    $foreach $s in @segs
        $if $s=~/^\[([ijkl,]*?)\]$/
            #---- %k_hash ----
            my @idxlist=split /,/, $1
            $if @idxlist > 1
                my $k=join('', @idxlist)
                $if !$k_hash{$k}
                    $k_hash{$k}=1
                    push @k_list, $k
                $s="[$(k)_$k\]"
    $$(left)=join '', @segs
    $$(left)=~s/\b([ijkl])\b/$(i)$1/g

subcode: sumcode_simple_generate
    my @code
    &call sumcode_simple_loop, left
        $if @right_idx
            my $sum=$left
            push @code, "$sum = 0"
            &call sumcode_simple_loop, right
                push @code, "$sum += $right"
        $elif $right
            push @code, "$left = $right"
        $else
            push @code, $left

subcode: sumcode_simple_loop(left)
    $(allow_recurse:2)
    $foreach $i in @$(left)_idx
        my $dim=$h->{"$i-dim"}
        push @code, "\$for $(i)$i=0:$dim"
        push @code, "SOURCE_INDENT"
    BLOCK
    $foreach $i in reverse @$(left)_idx
        push @code, "SOURCE_DEDENT"

#############################################################
#- ToDo: Factor a[i,j]=b[i,k]*c[k,l]*d[l,j]
#-       maybe: a[i,j]=b[i,k]*{c[k,l]*d[l,j]}
fncode: sumcode_generate($h)
    $(for:k in left, right, left_idx, right_idx, klist)
        my $$(k) = $h->{$(k)}
    $call sumcode_process_k

    my @code
    my %loop_i_hash
    my %loop_k_hash
    $call sumcode_init_each_k
    $if $debug
        print "left indexs: ", join(", ", @$left_idx), "\n"
        print "right indexs: ", join(", ", @$right_idx), "\n"
    &call sumcode_loop, left
        $if @$right_idx
            my $sum=$h->{sum}
            push @code, $h->{"sum-init"}
            push @code, "$h->{sum}=0"
            &call sumcode_loop, right
                push @code, "$sum += $right"
            $if $left ne $sum
                push @code, "$left = $sum"
        $elif $right
            push @code, "$left = $right"
        $else
            push @code, $left
    return \@code

subcode: sumcode_loop(left)
    $(allow_recurse:2)
    $foreach $i in @$$(left)_idx
        $loop_i_hash{$i}=1
        my $dim=$h->{"$i-dim"}
        my $var=$h->{"$i-var"}
        push @code, "\$for $var=0:$dim"
        push @code, "SOURCE_INDENT"
        $call sumcode_set_each_k
    BLOCK
    $foreach $i in reverse @$$(left)_idx
        $call sumcode_inc_each_k
        push @code, "SOURCE_DEDENT"

#---------------------------------------- 
subcode: sumcode_process_k
    my %k_calc_hash
    my %k_inc_hash
    my %k_init_hash
    #-- prepare above three hashes ----
    my @allidx=(@$left_idx, @$right_idx)
    # print "left_idx: @$left_idx, right_idx: @$right_idx\n"
    EACH_K:
    $foreach $k in @$klist
        $call find_inner_idx
        $(set:i=$allidx[$i])
        $if index(substr($k, $pos+1), $(i))>=0
            #--- repeated index such as k_ii
            # $print k_calc_hash $k - $(i): repeated index
            $k_calc_hash{"$k-$(i)"}=1
            next EACH_K
        $else
            $k_inc_hash{"$k-$(i)"}=1

            $pos--
            $i--
            $while $pos>=0 and $i>=0 and substr($k, $pos, 1) eq $(i)
                $if index(substr($k, $pos+1), $(i))>=0 or ($pos>0 && index(substr($k, 0, $pos), $(i))>=0)
                    # $print k_calc_hash $k - $pos - $(i): repeated index
                    $k_calc_hash{"$k-$(i)"}=1
                    next EACH_K
                $pos--
                $i--

            $if $i>=0
                # $print k_calc_hash $k - $i - $(i)
                $k_calc_hash{"$k-$(i)"}=1
            $else
                $k_init_hash{$k}=1

subcode: find_inner_idx
    my $pos
    my $i=$#allidx
    $while $i>=0
        $pos=index($k, $allidx[$i])
        $if $pos>=0
            break
        $i--
#---------------------------------------- 
subcode: sumcode_init_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
        $if $k_init_hash{$k}
            push @code, $h->{"$k-init"}
            push @code, "$kvar = 0"
            $loop_k_hash{$k}=1

subcode: sumcode_set_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
        $if $k_calc_hash{"$k-$i"}
            # $print "    k_calc_hash: $k - $i"
            $call sumcode_calc_k

subcode: sumcode_inc_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
        $if $k_inc_hash{"$k-$i"}
            $call sumcode_inc_k

#---------------------------------------- 
subcode: sumcode_inc_k
    $if substr($k, -1, 1) eq $i
        push @code, "$kvar++"
    $else
        my @tlist
        my $pos=index($k, $i)
        $pos++
        $while $pos<length($k); $pos++
            my $j=substr($k, $pos, 1)
            my $dim=$h->{"$j-dim"}
            push @tlist, $dim
        push @code, "$kvar += ".join("*", @tlist)

subcode: sumcode_calc_k
    $if !$loop_k_hash{$k}
        push @code, $h->{"$k-init"}
        $loop_k_hash{$k}=1

    #- k_ij = i*n+j
    my $t
    $for $j=0:length($k)-1
        my $idx=substr($k, $j, 1)
        $if $loop_i_hash{$idx}
            my $dim=$h->{substr($k, $j+1, 1)."-dim"}
            my $var=$h->{"$idx-var"}
            $if !$t
                $t = "$var*$dim"
            $else
                $t = "($t+$var)*$dim"
    my $idx=substr($k, -1, 1)
    $if $loop_i_hash{$idx}
        my $var=$h->{"$idx-var"}
        $t.="+$var"

    $if !$t
        $t = "0"
    push @code, "$kvar = $t"

