# $sumcode sum = A[i]
subcode: parsecode_sum_support(style)
    my $h={}
    $call sumcode_init_style, $(style)
    $call sumcode_parse
    $call parsecode_sum_common

# $sumcode(100) sum = A[i]
subcode: parsecode_sum_simple(style)
    my $h={}
    $call sumcode_init_style, $(style)
    $call sumcode_simple_parse
    $call parsecode_sum_common

subcode: parsecode_sum_common
    $(for:left in left, right)
        $h->{$(left)}=$$(left)
        $h->{$(left)_idx}=\@$(left)_idx
    $h->{klist} = \@k_list
    $foreach $k in @k_list
        $h->{"$k-init"}="$(my) $(k)_$k"
        $h->{"$k-var"}="$(k)_$k"
    $if @right_idx
        $if $left=~/^(\$?\w+)$/
            $h->{sum}=$1
        $else
            $h->{sum}="$(sum)"
        $h->{"sum-init"}="$(mytype) $h->{sum} = 0"

    my $codelist=sumcode_generate($h)
    MyDef::compileutil::parseblock({source=>$codelist, name=>"sumcode"})
    return
#---------------------------------------- 
#- '$' is not an operator, so if it appears, let's assume it is 
#-     part of variable name
#---------------------------------------- 
subcode: sumcode_init_style(style)
    $(if:style=c)
	$(export:mytype=\$my $type)
	$(export:my=\$my int)
	$(mexport:sum=sum,i=i,k=k)
    $(elif:style=perl)
	$(export:mytype=my)
	$(export:my=my)
	$(mexport:sum=\$sum,i=\$i,k=\$k)

subcode: sumcode_gen_sumvar_c
    $sum="sum"
    push @code, "\$my $type $sum=0"

subcode: sumcode_gen_sumvar_perl
    $sum="\$sum"
    push @code, "my $sum = 0"

#---------------------------------------- 
#########################################
subcode: sumcode_parse
    my ($left, $right)
    $if $param=~/(.*?)\s*(?<![\+\-\*\/%&\|><=])=(?!=)\s*(.*)/
	($left, $right)=($1, $2)
    $else
	$left=$param

    my $type
    my (%k_hash, @k_list)

    my %var_hash
    my (@left_idx, @right_idx)
    $call sumcode_get_idx, left
    $if $right
	$call sumcode_get_idx, right

subcode: sumcode_get_idx(left)
    my @segs=split /(\w+\[[ijkl,]*?\])/, $$(left)
    $foreach $s in @segs
	$if $s=~/^(\w+)\[([ijkl,]*?)\]$/
	    $if $var_hash{$s}
		$s=$var_hash{$s}
	    $else
		#---- translate var, populate $type, %k_hash, dim_hash ----
		$call sumcode_var
		$var_hash{$s}=$t
		$s=$t
    $$(left)=join '', @segs
    $$(left)=~s/\b([ijkl])\b/$(i)_\1/g

subcode: sumcode_var
    my $t
    my ($v, $idx_str)=($1, $2)
    my $var=find_var($v)
    $(if:style=c)
	$if !$type
	    $type=pointer_type($var->{type})

    my @idxlist=split /,/, $idx_str
    $if @idxlist==1
        my $idx=$idx_str
	$t="$v\[$(i)_$idx\]"
    $else
	my $k=join('', @idxlist)
        $if !$k_hash{$k}
            $k_hash{$k}=1
            push @k_list, $k
	$t="$v\[$(k)_$k\]"
    my $i=0
    $foreach $idx in @idxlist
        $i++
        $call sumcode_idx

subcode: sumcode_idx
    #-- get idx dimension based on var ----
    my ($dim, $inc)
    $if $var->{"dim$i"}
	$dim=$var->{"dim$i"}
    $(if:i=1)
	$elif $var->{"dimension"}
	    $dim=$var->{"dimension"}
    $else
	$call warn, sumcode: var $v missing dimension $i

    #-- set dim_hash ----
    $if !$h->{"$idx-dim"}
	push @$(left)_idx, $idx
	$h->{"$idx-dim"}=$dim
        $h->{"$idx-var"}="$(i)_$idx"
    $else
	$if $h->{"$idx-dim"} ne $dim
            my $old_dim=$h->{"$idx-dim"}
	    $print "sumcode dimesnion mismatch: $old_dim != $dim"

#---------------------------------------- 
#- sumcode simple
#---------------------------------------- 
subcode: sumcode_simple_parse
    my ($left, $right)
    $if $param=~/(.*?)\s*(?<![\+\-\*\/%&\|><=])=(?!=)\s*(.*)/
	($left, $right)=($1, $2)
    $else
	$left=$param

    my @idxlist=('i','j','k','l')
    my @dimlist=MyDef::utils::proper_split($dimstr)
    my (@left_idx, @right_idx)
    $foreach $dim in @dimlist
        my $idx=shift @idxlist
        $h->{"$idx-dim"}=$dim
        $h->{"$idx-var"}="$(i)_$idx"

	$if $left=~/\b$idx\b/
	    push @left_idx, $idx
	$else
	    push @right_idx, $idx

    my (%k_hash, @k_list)
    $call sumcode_simple_get_idx, left
    $if $right
        $call sumcode_simple_get_idx, right

subcode: sumcode_simple_get_idx(left)
    my @segs=split /(\[[ijkl,]*?\])/, $$(left)
    $foreach $s in @segs
	$if $s=~/^\[([ijkl,]*?)\]$/
            #---- %k_hash ----
            my @idxlist=split /,/, $1
            $if @idxlist > 1
                my $k=join('', @idxlist)
                $if !$k_hash{$k}
                    $k_hash{$k}=1
                    push @k_list, $k
                $s="[$(k)_$k\]"
    $$(left)=join '', @segs
    $$(left)=~s/\b([ijkl])\b/$(i)_\1/g

subcode: sumcode_simple_generate
    my @code
    &call sumcode_simple_loop, left
	$if @right_idx
	    my $sum=$left
	    push @code, "$sum = 0"
	    &call sumcode_simple_loop, right
		push @code, "$sum += $right"
	$elif $right
	    push @code, "$left = $right"
	$else
	    push @code, $left

subcode: sumcode_simple_loop(left)
    $(allow_recurse:2)
    $foreach $i in @$(left)_idx
        my $dim=$h->{"$i-dim"}
	push @code, "\$for $(i)_$i=0:$dim"
	push @code, "SOURCE_INDENT"
    BLOCK
    $foreach $i in reverse @$(left)_idx
	push @code, "SOURCE_DEDENT"

#############################################################
#- ToDo: Factor a[i,j]=b[i,k]*c[k,l]*d[l,j]
#-       maybe: a[i,j]=b[i,k]*{c[k,l]*d[l,j]}
fncode: sumcode_generate($h)
    $(for:k in left, right, left_idx, right_idx, klist)
        my $$(k) = $h->{$(k)}
    $call sumcode_process_k

    my @code
    my %loop_i_hash
    my %loop_k_hash
    $call sumcode_init_each_k
    &call sumcode_loop, left
	$if @$right_idx
	    my $sum=$h->{sum}
            push @code, $h->{"sum-init"}
	    &call sumcode_loop, right
		push @code, "$sum += $right"
	    $if $left ne $sum
		push @code, "$left = $sum"
	$elif $right
	    push @code, "$left = $right"
	$else
	    push @code, $left
    return \@code

subcode: sumcode_loop(left)
    $(allow_recurse:2)
    $foreach $i in @$$(left)_idx
	$loop_i_hash{$i}=1
        my $dim=$h->{"$i-dim"}
        my $var=$h->{"$i-var"}
	push @code, "\$for $var=0:$dim"
	push @code, "SOURCE_INDENT"
	$call sumcode_set_each_k
    BLOCK
    $foreach $i in reverse @$$(left)_idx
	$call sumcode_inc_each_k
	push @code, "SOURCE_DEDENT"

#---------------------------------------- 
subcode: sumcode_process_k
    my %k_calc_hash
    my %k_inc_hash
    my %k_init_hash
    #-- prepare above three hashes ----
    my @allidx=(@$left_idx, @$right_idx)
    EACH_K:
    $foreach $k in @$klist
	my $pos
	my $i=$#allidx
	$while $i>=0
	    $pos=index($k, $allidx[$i])
	    $if $pos>=0
		break
	    $i--
	$if index(substr($k, $pos+1), $allidx[$i])>=0
	    #--- repeated index such as k_ii
	    $k_calc_hash{"$k-$allidx[$i]"}=1
	    next EACH_K
	$else
	    $k_inc_hash{"$k-$allidx[$i]"}=1

	    $pos--
	    $i--
	    $while $pos>=0 and $i>=0 and substr($k, $pos, 1) eq $allidx[$i]
		$if index(substr($k, $pos+1), $allidx[$i])>=0 or index(substr($k, 0, $pos-1), $allidx[$i])>=0
		    $k_calc_hash{"$k-$allidx[$i]"}=1
		    next EACH_K
		$else
		    $pos--
		    $i--

	    $if $i>=0
		$k_calc_hash{"$k-$allidx[$i]"}=1
	    $else
		$k_init_hash{$k}=1

#---------------------------------------- 
subcode: sumcode_init_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
	$if $k_init_hash{$k}
	    push @code, $h->{"$k-init"}
	    push @code, "$kvar = 0"
	    $loop_k_hash{$k}=1

subcode: sumcode_set_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
	$if $k_calc_hash{"$k-$i"}
	    $call sumcode_calc_k

subcode: sumcode_inc_each_k
    $foreach $k in @$klist
        my $kvar=$h->{"$k-var"}
	$if $k_inc_hash{"$k-$i"}
	    $call sumcode_inc_k

#---------------------------------------- 
subcode: sumcode_inc_k
    $if substr($k, -1, 1) eq $i
	push @code, "$kvar++"
    $else
	my $dim=$h->{"$i-dim"}
	push @code, "$kvar += $dim"

subcode: sumcode_calc_k
    $if !$loop_k_hash{$k}
	push @code, $h->{"$k-init"}
	$loop_k_hash{$k}=1

    #- k_ij = i*n+j
    my $t
    $for $j=0:length($k)-1
	my $idx=substr($k, $j, 1)
	$if $loop_i_hash{$idx}
	    my $dim=$h->{substr($k, $j+1, 1)."-dim"}
            my $var=$h->{"$idx-var"}
	    $if !$t
		$t = "$var*$dim"
	    $else
		$t = "($t+$var)*$dim"
    my $idx=substr($k, -1, 1)
    $if $loop_i_hash{$idx}
        my $var=$h->{"$idx-var"}
	$t.="+$var"

    $if !$t
	$t = "0"
    push @code, "$kvar = $t"

