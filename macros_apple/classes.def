includes: macros_util/tool_output.def

subcode:: package_global
    my %classes;
    my $cur_class;
    my %method_hash;
    my $method_idx=1;
    my $class_default

subcode: dump_class_interface(block)
    my $interface=$class->{interface};
    $if @{$class->{protocols}}
	my $plist=$class->{protocols}
	$interface.=" <".join(", ", @$plist).">";
    push @$(block), "\@interface $name : $interface";
    # -- properties --
    $while my ($pname, $ptype)=each %{$class->{properties}}
	push @$(block), "\@property $ptype $pname;";
    $foreach my $declare in @{$class->{declares}}
	push @$(block), "$declare;";
    push @$(block), "\@end";
    push @$(block), "NEWLINE";

subcode: dump_class_implementation(block)
    push @$(block), "\@implementation $name";
    $while my ($pname, $ptype)=each %{$class->{properties}}
	push @$(block), "\@synthesize $pname;";
    $foreach my $method in @{$class->{methods}}
	push @$(block), "NEWLINE";
	$foreach my $t in @$method
	    push @$(block), $t;
	push @$(block), "NEWLINE";
    push @$(block), "\@end";
    push @$(block), "NEWLINE";


subcode:: support_subs
    $sub new_class
	my ($name, $tail)=@_;
	my $newclass;
	$if $tail=~/,\s*(\w+)/
	    $newclass=$1
	$elif $tail=~/,\s*_(\w+)/
	    $newclass="$name\_$1"
	$else
	    $newclass=$name
	# ----
	$cur_class={super=>$name, protocols=>[], name=>$newclass, properties=>{}, declares=>[], methods=>[]};
	my $field=collect_class_field($name)
	$cur_class->{field}=$field
	$classes{$newclass} = $cur_class
	# ----
	my $class=$field->{class};
	$if !$class
	    $class=$name;
	$cur_class->{interface}="$class";
	my $protocol=$field->{protocol};
	$call implement_protocol

subcode: implement_protocol
    $if $protocol
	my $plist=$cur_class->{protocols}
	my $exist=0;
	$foreach my $p in @plist
	    $if $p eq $protocol
		$exist=1;
	$if !$exist
	    push @$plist, $protocol;
	    res_collect($cur_class->{field}, $class_default->{$protocol})

subcode: new_method(name, blockname)
    my $declare
    my $method=$cur_class->{field}->{$(name)}
    $if !ref($method)
	$declare=$method
    $else
	$if $method->{declare}
	    $declare=$method->{declare}
	$else
	    $declare=$method->{_name}
    $if !$declare
	$if $(name)=~/^\w+_/
	    my $ret_type=get_c_type($(name));
	    $declare="- ($ret_type)$(name)";
	$else
	    $declare="- (void)$(name)";
    $if $tail=~/^\((.*)\)/
	my @plist=split /,\s*/, $1;
	for(my $i=0; $i<@plist; $i++){
	    my $type=get_c_type($plist[$i]);
	    $if $i>0
		$declare.=" p$i";
	    $declare.=":($type)$plist[$i]";
	}

    my $fidx=open_closure("$declare {", "}");
    my $prop=$cur_class->{properties};
    foreach my $v (keys %$prop){
	declare_var($v, $prop->{$v});
    }
    # ----
    my @method_block;
    push @method_block, "OPEN_FUNC_$fidx";
    push @method_block, "SOURCE_INDENT";
    # -- pre --
    $call push_method_block, pre
    # ---------- Method Block ------------------
    $(if:blockname=BLOCK)
	push @method_block, "BLOCK";
    $(else)
	push @method_block, "INCLUDE_BLOCK $(blockname)";
    # -- post --
    $call push_method_block, post

    push @method_block, "SOURCE_DEDENT";
    push @{$cur_class->{methods}}, \@method_block;
    push @{$cur_class->{declares}}, $declare;

subcode: push_method_block(name)
    $if $method->{$(name)}
	&call replace_output, \@method_block
	    $if !ref($method->{$(name)})
		MyDef::compileutil::parseblock([$method->{$(name)}])
	    $else
		MyDef::compileutil::parseblock($method->{$(name)}->{_list})

# ----
subcode: add_property(t, attr)
    my @plist=split /,\s*/, $(t);
    $foreach my $p in @plist
	my ($type, $name)=get_name_type($p)
	$if $cur_class
	    $if $(attr)
		$cur_class->{properties}->{$name}="($(attr)) $type"
	    $else
		$cur_class->{properties}->{$name}=$type;
	    declare_var($name, $type);
############################################

subcode: apple_functions
    my $animate_block_depth=0;
    my $animate_need_completion=0;

    my %viewitems;

    $sub res_collect
	my ($field, $from)=@_
	$if $from
	    $while my ($k, $v)=each %$from
		$if !$field->{$k}
		    $field->{$k}=$v

    $sub collect_class_field
	my ($name)=@_;
	my $field=$class_default->{$name}
	$if !$field
	    return $class_default->{Default}
	$else
	    $while $field->{super}
		my $super=$class_default->{$field->{super}}
		$field->{super}=undef
		res_collect($field, $super)
	    res_collect($field, $class_default->{Default})
	    return $field;

    ############################################
    sub parse_animation_param {
	my $param=shift;
	my @plist=split /,\s*/, $param;
	if(@plist>1){
	    $animate_need_completion++;
	    my @options;
	    for(my $i=1; $i<@plist; $i++){
		push @options, "UIViewAnimationOption$plist[$i]";
	    }
	    $param="$plist[0] delay:0 options:".join('|', @options);

	}
	return $param;
    }

    sub newclass_spec {
	my ($init, $spec)=@_;
	if($init=~/\$2/){
	    my @speclist=split /,\s*/, $spec;
	    for(my $i=1; $i-1<@speclist; $i++){
		$init=~s/\$$i/$speclist[$i-1]/;
	    }
	}
	else{
	    $init=~s/\$1/$spec/;
	}
	return $init;
    }

    sub nsstring {
	my $s=shift;
	if($s=~/^"(.*)"/){
	    return "@\"$1\"";
	}
	elsif($s =~/^nss_/){
	    return $s;
	}
	else{
	    return "@\"$s\"";
	}
    }
    sub nsnumber {
	my $s=shift;
	if($s=~/^\d/){
	    if($s=~/\./){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return "[NSNumber numberWithInt:$s]";
	    }
	}
	else{
	    my $type=get_c_type($s);
	    if($type =~/^int$/){
		return "[NSNumber numberWithInt:$s]";
	    }
	    elsif($type =~/^(float|double)$/){
		return "[NSNumber numberWithFloat:$s]";
	    }
	    else{
		return $s;
	    }
	}
    }
    # ---- GUI VIEW STUFF
    # -- loading custom config file. todo: Generilize into configfile.pm.
    sub load_view_config {
	my ($f, $itemhash)=@_;
	my $item;
	open In, $f or return;
	while(<In>){
	    if(/^#/){
	    }
	    elsif(/^(\w+)/){
		$item={};
		$itemhash->{$1}=$item;
	    }
	    elsif(/^\s+(\w+):\s*(.*)/){
		$item->{$1}=$2;
	    }
	}
	close In;
    }

    sub addview {
	my ($out, $name, $parent)=@_;
	if(!$viewitems{$name}){
	    warn "Missing layout item $name\n";
	}
	my $main=$viewitems{"main"};
	my $v=$viewitems{$name};
	my $type=$v->{type}?$v->{type}:"UIView";
	my $x=$v->{x};
	my $y=$v->{y};
	my $w=$v->{width};
	my $h=$v->{height};

	new_object($out, $name, $type, "CGRectMake($x, $y, $w, $h)"); 
	if($v->{background}){
	    if($v->{background}=~/\.png/){
		push @$out, "$name.backgroundColor=[UIColor colorWithPatternImage:[UIImage ImageNamed:@\"$v->{background}\"]]";
	    }
	    elsif($v->{background}=~/#(..)(..)(..)(..)/){
		push @$out, "$name.backgroundColor=[UIColor colorWithRed:$1/255.0 green:$2/255.0 blue:$3/255.0 alpha:$4/255.0]";
	    }
	}
	if(!$parent){
	    push @$out, "self.view = $view";
	}
	else{
	    push @$out, "[$parent addSubview:$name]";
	}
	if($v->{children}){
	    my @tlist=split /,\s*/, $v->{children};
	    foreach my $t (@tlist){
		addview($out, $t, $name);
	    }
	}

    }
    # ----
    $sub new_object
	my ($out, $v, $class, $spec)=@_;
	$spec=~s/^,?\s*//;
	#print "new: v=[$v], class=[$class], spec=[$spec]\n";
	my $init="init";
	my $field;
	$if $classes{$class}
	    $field=$MyDef::def->{fields}->{$classes{$class}->{super}};
	$else
	    $field=$MyDef::def->{fields}->{$class};
	    $if $field->{class}
		$class=$field->{class};
	# ----
	if($v=~/^@(.*)/){
	    $v=$1;
	    $cur_class->{properties}->{$1}="$class *";
	}
	elsif($v!~/[.]/){
	    func_add_var($v, "$class *");
	}
	if($field->{create_spec}){
	    my $create=newclass_spec($field->{create_spec}, $spec);
	    push @$out, "$v = [$class $create];";
	}
	else{
	    if(!$spec){
		while($field){
		    if($field->{init_default}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		if($field){
		    $init=$field->{init_default};
		}
	    }
	    else{
		while($field){
		    if($field->{init_spec}){
			last;
		    }
		    else{
			$field=$MyDef::def->{fields}->{$field->{super}};
		    }
		}
		#print "init_spec: $field->{init_spec}\n";
		if($field){
		    $init=newclass_spec($field->{init_spec}, $spec);
		}
		else{
		    $init=$spec;
		}
	    }
	    push @$out, "$v = [[$class alloc] $init];";
	}
	# -- specific classes --
	$if $class=~/EAGLContext/
	    $imports{"QuartzCore/QuartzCore.h"}=1;
	    $imports{"OpenGLES/EAGL.h"}=1;
	    $if $init=~/OpenGLES1/
		$imports{"OpenGLES/ES1/gl.h"}=1;
		$imports{"OpenGLES/ES1/glext.h"}=1;
	    $if $init=~/OpenGLES2/
		$imports{"OpenGLES/ES2/gl.h"}=1;
		$imports{"OpenGLES/ES2/glext.h"}=1;
