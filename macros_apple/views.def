include: macros_util/resource.def
include: macros_util/tool_output.def

subcode:: package_global
    my %view_hash;
    my %view_id_hash;
    my %controller_hash;
    my @cur_method_stack
    my @cur_class_stack

subcode: add_class
    push @cur_class_stack, $cur_class
    BLOCK
    $cur_class=pop @cur_class_stack

# -----------------------------------------
subcode: process_views
    $foreach $name in @view_list 
	$call fetch_named_resource, view
	$if !$view->{processed}
	    $call collect_view_attr, $view

	$call process_view_class_controller

subcode: class_method(name)
    push @cur_method_stack, $cur_function
    my $block=[];
    my $method_name="$(name)"
    $method_hash{"METHOD$method_idx"}=$block
    $call new_method, $method_name, METHOD$method_idx
    $method_idx++
    &call replace_output, $block
	BLOCK
    $cur_function=pop @cur_method_stack

subcode: process_view_class_view
    &call add_class
	new_class( "UIView", ", view_$name",)
	my $proplist=$view->{proplist}
	$call add_view_properties
	my $actionlist=$view->{actionlist}
	my $initlist=$view->{initlist}
	$call add_view_actions

subcode: process_view_class_controller
    &call add_class
	# to hold target actions etc.
	my $actionlist={"_target"=>"self"}
	my $proplist={}
	my $initlist=[]
	new_class("UIViewController", ", controller_$name")
	$if $view->{protocol}
	    $cur_class->{protocols}=$view->{protocol}
	$if 1
	    &call class_method, loadView
		func_add_var("frame0", "CGRect")
		push @$out, "frame0=[[UIScreen mainScreen] applicationFrame];"
		my $mainview={_name=>$name, _list=>$view->{_list}}
		$mainview->{actionlist}=$actionlist
		$mainview->{proplist}=$proplist
		$mainview->{initlist}=$initlist
		my $view_var=create_view($mainview, 1)
		push @$out, "[self setView:$view_var];";
	$call add_view_properties
	$call add_view_actions

subcode: add_view_actions
    my @alist=keys %$actionlist
    my $need_init
    $if @$initlist
	$need_init=1
    $foreach my $a in @alist
	$if $a !~/^_.*/
	    my $tail
	    $if $actionlist->{$a}=~/event/
		$tail="(obj)"
	    &call class_method, $a
		$if $a eq "on_init" and $need_init
		    MyDef::compileutil::parseblock($initlist)
		    $need_init=0
		MyDef::compileutil::call_sub("$name\_$a")
    $if $need_init
	&call class_method, on_init
	    MyDef::compileutil::parseblock($initlist)

subcode: add_view_properties
    $while my ($name, $type) = each %$proplist
	$cur_class->{properties}->{$name}=$type

# ---------------------------------------------
subcode:: support_subs
    $sub create_controller
	my ($name)=@_
	$call fetch_named_resource, view
	my $controller_name="controller_$name"
	my $var="controller"
	func_add_var($var, "controller_$name *")
	push @$out, "$var = [[controller_$name alloc] init];"
	$if !$controller_hash{$name}
	    $controller_hash{$name}="controller_$name"
	    $call process_view_class_controller

subcode: check_need_viewclass
    my $need_view;
    my $actionlist={}
    $if MyDef::compileutil::get_def_attr("codes", "$name\_on_draw")
	$actionlist->{on_draw}=1
	$need_view=1
    $if $need_view
	$actionlist->{_target}=$cur_view
	$view->{actionlist}=$actionlist
	$view->{proplist}={}
	$view->{initlist}=[]
	$view_type="view_$name"

subcode: run_view_custom
    my @codelist
    my $error
    $if ref($l) eq "HASH"
	$foreach my $tl in @{$l->{_list}}
	    $tl=~s/\$view/$cur_view/g
	    $tl=res_get_str($view, $tl)
	    $if $tl
		push @codelist, $tl
	    $else
		$error=1
    $else
	$l=~s/\$view/$cur_view/g
	my $tl=res_get_str($view, $l)
	$if $tl
	    push @codelist, $tl
	$else
	    $error=1
    $if !$error
	MyDef::compileutil::parseblock(\@codelist)

subcode:: support_subs
    $sub create_view
	my ($view, $level, $parent_view)=@_
	my $name=$view->{_name}
	$call collect_view_attr, $view
	my $view_type="UIView"
	$if $view->{class}
	    $view_type=$view->{class}

	my $cur_view
	$if $view->{id}
	    $cur_view=$view->{id}
	$else
	    my $idx=1
	    $while $view_id_hash{"$name$idx"}
		$idx++
	    $cur_view="$name$idx"
	    $view_id_hash{$cur_view}=1
	# ----
	$call check_need_viewclass
	# ----
	func_add_var("frame$level", "CGRect")
	$view->{frame}="frame$level"
	my $parent_frame
	my $plevel=$level-1
	$parent_frame="frame".$plevel
	$if $x=~/-(.*)/
	    $x="$parent_frame.size.width-$1-$w"
	$if $y=~/-(.*)/
	    $y="$parent_frame.size.height-$1-$h"
	$if $w=~/-(.*)/
	    $w="$parent_frame.size.width-$1-$x"
	$if $h=~/-(.*)/
	    $h="$parent_frame.size.height-$1-$y"
	push @$out, "frame$level=CGRectMake($x, $y, $w, $h);"

	func_add_var($cur_view, "$view_type *")
	$if $view->{create}
	    my $l=$view->{create}
	    $call run_view_custom
	    $if $error
		die "$name create [$l] missing variables\n"
	$else
	    push @$out, "$cur_view=[[$view_type alloc] initWithFrame:frame$level];"
	# -- set text, color, etc.
	$while my ($k, $l)=each %$view
	    $if $k=~/^do_(\w+)/
		$call run_view_custom

	# ---- actions
	$if $view->{property}
	    my $proplist=$view->{proplist}
	    my $initlist=$view->{initlist}
	    my @plist=split /,/, $view->{property}
	    $foreach my $p in @plist
		my $init;
		$if $p=~/(.*)=(.*)/
		    ($p, $init)=($1, $2)
		my ($type, $name)=get_name_type($p)
		$if $p=~/(\S.*)\s+(\S+)/
		    $proplist->{$2}=$1
		$else
		    $p=~s/^\s+//
		    $p=~s/\s+$//
		    $proplist->{$p}=get_c_type($p)
		$if defined $init
		    push @$initlist, "$name = $init;"
	$if $view->{action}
	    my $actionlist=$view->{actionlist}
	    my $target=$actionlist->{_target}
	    my @alist=split /,/, $view->{action}
	    $foreach $a in @alist
		$if $a=~/(\w+):\s*(\w+)/
		    push @$out, "[$cur_view addTarget:$target action:\@selector($2:) forControlEvents:$1];"
		    $actionlist->{$2}="event"
		$elif $view->{default_event}
		    push @$out, "[$cur_view addTarget:$target action:\@selector($a:) forControlEvents:$view->{default_event}];"
		    $actionlist->{$a}="event"
		$else
		    push @$out, "[$cur_view addTarget:$target action:\@selector($a:)];"
		    $actionlist->{$a}="event"
	# ----
	$if $parent_view
	    push @$out, "[$parent_view addSubview:$cur_view];";
	push @$out, "NEWLINE"

	# ----
	my $list=$view->{_list}
	$foreach my $v in @$list
	    $v->{actionlist}=$view->{actionlist}
	    create_view($v, $level+1, $cur_view)

	# ---- add view class ----
	$if $need_view and !$view_hash{$name}
	    $view_hash{$name}="view_$name"
	    $call process_view_class_view

	return $cur_view

    $sub res_get_str
	my ($view, $l)=@_
	my @tlist=split /(\$\w+)/, $l
	my $i=0
	$foreach my $t in @tlist
	    $if $t=~/\$(\w+)/
		$if $view->{$1}
		    $tlist[$i]=$view->{$1}
		$else
		    #print STDERR "res_get_str: missing [$1]\n"
		    return undef
	    $i++
	return join("", @tlist)



