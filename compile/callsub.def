subcode: parse_call_sub
    $param=~s/\s*$//;
    $if $func eq "\$map"
        map_sub($param, $func);
    $elif $func =~ "^\$call-(PRINT|template)"
        special_sub($param, $1)
    $elif $func =~ /^\$call/
        call_sub($param)
    $elif $func eq "\&call"
        my $subblock=grabblock($block, \$lindex)
        my $blk = {source=>$subblock, name=>"BLOCK", cur_file=>$cur_file, cur_line=>$cur_line, parsed_counter=>0}
        call_back($param, $blk)

    $elif $func =~ /^\&call(\d+)/
        my $n=$1
        my @sub_blocks
        $for $i=0:$n
            my $subblock=grabblock($block, \$lindex)
            my $blk = {source=>$subblock, name=>"BLOCK$i", cur_file=>$cur_file, cur_line=>$cur_line, parsed_counter=>0}
            push @sub_blocks, $blk
            $if $i<$n-1
                $if $block->[$lindex]=~/.*:\s*$/
                    $lindex++
                $else
                    my $blkno = $i+1
                    $call warn, &call$n missing block $blkno - $block->[$lindex]
        my $multi_blk = {blocks=>\@sub_blocks, name=>"MULTIBLOCK", parsed_counter=>0}
        multi_call_back($param, $multi_blk)

    $elif $func eq "\$nest"
        my $subblock=grabblock($block, \$lindex)
        my @tlist = MyDef::utils::proper_split($param)
        my $codename=shift @tlist
        my $param_0 = shift @tlist

        my @t_block
        my $n = @tlist
        $foreach $t in @tlist
            push @t_block, "&call $codename, $t"
            push @t_block, "SOURCE_INDENT"
        $foreach $l in @$subblock
            push @t_block, $l
        $for $i=0:$n
            push @t_block, "SOURCE_DEDENT"

        call_back("$codename, $param_0", \@t_block)

#---------------------------------------- 
fncode: call_sub($param)
    $call call_sub_frame, normal

fncode: map_sub($param)
    $call call_sub_frame, map

fncode: call_back($param, $sub_blk)
    $call call_sub_frame, callback

fncode: multi_call_back($param, $sub_blks)
    $call call_sub_frame, multi_callback

fncode: list_sub($codelib)
    &call parseblock_with_macro
        $call call_sub_list_setup_macro

fncode: special_sub($param, $mode)
    $if $param=~/^(@)?(\w+)(.*)/
        my $codename=$1
        my $codelib=get_def_attr("codes", $codename)
        $if $codelib
            modepush($mode)
            parseblock($codelib)
            modepop()

#---------------------------------------- 
subcode: call_sub_frame(type)
    $call load_codelib
    $if $codelib
        $if $codelib->{type} eq "perl"
            $param=~s/^\s*,\s*//
            $(if:type=callback)
                &call perl_block_call
                    $f_parse->("\$eval $codename, $param")
            $(else)
                $f_parse->("\$eval $codename, $param")
        $elif $codelib->{type} eq "template"
            modepush("template")
            parseblock($codelib)
            modepop()
        $else
            $call split_param
            &call call_sub_block
                $(if:type=callback)
                    $call call_sub_back, $sub_blk
                $(elif:type=multi_callback)
                    $call call_sub_back, $sub_blks
                $(elif:type=map)
                    $call call_sub_map
                $(else)
                    $call call_sub_normal
    # ---------------------------------------- 
    subcode: call_sub_normal
        &call parseblock_with_macro
            $call call_sub_normal_setup_macro

    subcode: call_sub_back(subblock)
        $global @callback_block_stack
        push @callback_block_stack, $(subblock)

        &call parseblock_with_macro
            $call call_sub_normal_setup_macro
        $if $(subblock)->{parsed_counter}==0
            $call warn, Callback missing BLOCK?

        pop @callback_block_stack

    subcode: call_sub_map
        $if 1+@pre_plist!=$n_param
            warn " Code $codename parameter mismatch.\n";
        $call @map_subcode_list
        $foreach $item in @plist
            &call parseblock_with_macro
                # instead of call_sub_normal_setup_macro
                $macro->{$codeparams->[$n_pre]}=$item
                $if $n_pre
                    $for $i=0:$n_pre
                        $macro->{$codeparams->[$i]}=$pre_plist[$i];
        # ---------
        subcode: map_subcode_list
            # collect all subcode name with certain prefix
            $if $plist[0]=~/^subcode:(.*)/
                my $prefix=$1
                @plist=()
                my $codes=$MyDef::def->{codes}
                $foreach $k in sort(keys(%$codes))
                    $if $k=~/^$prefix(\w+)/
                        push @plist, $1

    # -----------------------
    subcode: perl_block_call
        #---- e.g. html/code.def --
        $named_blocks{last_grab}=$sub_blk->{source}
        BLOCK
        $named_blocks{last_grab}=undef
    # ---------------------------------
    subcode: load_codelib
        my ($codename, $attr, $codelib)
        $if $param=~/^(@)?(\w+)(.*)/
            ($codename, $attr, $param)=($2, $1, $3)
            $param=~s/^\s*,\s*//
            $codelib=get_def_attr("codes", $codename)
            $call @check_codelib
        $else
            warn "    call_sub [$param] parse failure\n"

        # -----------------
        subcode: check_codelib
            $if !$codelib
                set_current_macro("notfound", 1)
                $if !$attr or $attr ne '@'
                    $print [$cur_file:$cur_line] Code $codename not found!
            $else
                set_current_macro("notfound", 0)
                $(if:type!=callback)
                    $if $codelib->{recurse} and $codelib->{recurse}>5
                        $if $codelib->{allow_recurse} < $codelib->{recurse}
                            die "Recursive subcode: $codename [$codelib->{recurse}]\n"
    # ----------------------
    subcode: split_param
        my $codeparams=$codelib->{params};
        my $n_param = @$codeparams
        $(if:type=map)
            $call split_param_map
        $(else)
            $call split_param_call

        subcode: split_param_call
            my ($pline, @plist)
            $param=~s/^\s*,?\s*//;
            $pline=$param
            $if $n_param==1 and $codeparams->[0]=~/^@/
                push @plist, $param
            $else
                @plist=MyDef::utils::smart_split($param, $n_param)

            my @pre_plist
            my $n_pre=0


        subcode: split_param_map
            my (@pre_plist, $pline, @plist);
            $if $param=~/^\(([^\)]*)\)/
                $param=$';
                @pre_plist=MyDef::utils::proper_split($1)
            $param=~s/^\s*,?\s*//;
            $pline=$param;
            @plist=MyDef::utils::proper_split($param)
            my $n_pre=@pre_plist;

    # ---------------------------------------- 
    subcode: call_sub_block
        $global @callsub_stack
        $codelib->{recurse}++
        push @callsub_stack, $codename
        modepush($codelib->{type})

        BLOCK

        modepop()
        pop @callsub_stack
        $codelib->{recurse}--

#-------------------
subcode: parseblock_with_macro
    my $macro={};
    # $call call_sub_normal_setup_macro
    BLOCK
    push @$deflist, $macro;
    parseblock($codelib);
    pop @$deflist;

subcode: call_sub_list_setup_macro
    $call @sub_macro
    $call @sub_codes

    subcode: sub_macro
        $if $codelib->{macros}
            $foreach %{$codelib->{macros}}
                $macro->{$k}=$v
    subcode: sub_codes
        $if $codelib->{codes}
            $macro->{"codes"}=$codelib->{codes}

subcode: call_sub_normal_setup_macro
    $call @plist_macro
    $call param_macro
    $macro->{recurse_level}=$codelib->{recurse}
    $call call_sub_list_setup_macro
    $call @debug

    # ---------------------------------------- 
    subcode: plist_macro
        $if 1==$n_param && $codeparams->[0] eq "\@plist"
            $macro->{np}=$#plist+1
            my $i=0
            $foreach $p in @plist
                $i++
                $macro->{"p$i"}=$p

    subcode: param_macro
        $call @check_last_slurp
        $call pre_plist
        $call normal_plist

        # ---------------------
        subcode: check_last_slurp
            $if $n_pre+@plist!=$n_param
                my $n2=@plist;
                my $n3=$n_param;
                $if $codeparams->[$n3-1]=~/^\@(\w+)/ and $n2>$n3-$n_pre
                    # Last single param slurp, we work with original pline to preserve any ',' and space ----------
                    # will not work with ' | ' seperated list
                    my $n0=$n3-$n_pre-1;
                    # $print check_last_slurp: pline[$pline], n0=$n0, n_param=$n_param, nlist=$n2
                    $for $i=0:$n0
                        $pline=~s/^[^,]*,//
                    $pline=~s/^\s*//
                    $plist[$n0]=$pline
                $else
                    my $param=join(', ', @$codeparams)
                    warn "    [$cur_file:$cur_line] Code $codename parameter mismatch ($n_pre + $n2) != $n3. [pline:$pline]($param)\n";

        subcode: pre_plist
            $for $i=0:$n_pre
                $macro->{$codeparams->[$i]}=$pre_plist[$i];

        subcode: normal_plist
            $for $j=0:$n_param-$n_pre
                my $p=$codeparams->[$n_pre+$j];
                $if $p=~/^\@(\w+)/
                    $p=$1
                $if $plist[$j]=~/q"(.*)"/
                    $macro->{$p}=$1;
                $else
                    $macro->{$p}=$plist[$j];

    subcode: debug
        $if $debug eq "macro"
            print "Code $codename: "
            $while my ($k, $v)=each %$macro
                print "$k=$v, "
            print "\n"


#---------------------------------------- 
fncode: eval_sub($codename)
    $global %eval_sub_cache, %eval_sub_error
    $if $eval_sub_cache{$codename}
        return $eval_sub_cache{$codename}
    $else
        my $codelib=get_def_attr("codes", $codename);
        $if !$codelib
            warn "    eval_sub: Code $codename not found\n"
        my $t= eval_sub_string($codelib)
        $eval_sub_cache{$codename}=$t
        return $t

fncode: eval_sub_string($codelib)
    require MyDef::output_perl
    my $save_out=$out
    my @save_interface=get_interface()

    set_interface(MyDef::output_perl::get_interface())
    $out=[]
    $f_setout->($out)

    list_sub($codelib)
    # parse_code($codelib)
    my @t
    $f_dumpout->(\@t, $out, "eval")

    set_interface(@save_interface)
    $out=$save_out
    $f_setout->($out)

    my $t=join("", @t)
    return $t

