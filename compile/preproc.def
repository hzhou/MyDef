
subcode: parse_preproc
    $if $preproc=~/^for:\s*(\S+)\s+in\s+(.*)/
	my $vname=$1;
	my $vparam=$2;
	my @tlist;
	$if $vparam=~/(\d+)\.\.(\d+)/
	    for(my $i=$1;$i<=$2; $i++){
		push @tlist, $i
	    }
	$else
	    expand_macro_recurse(\$vparam)
	    @tlist=split /,\s*/, $vparam;

	my $subblock=grabblock($block, \$lindex);
	$foreach my $t in @tlist
	    my $macro={$vname=>$t};
	    push @$deflist, $macro;
	    parseblock({source=>$subblock, name=>"\${for}"})
	    pop @$deflist;
    $elsif $preproc=~/^foreach:p/
	my $subblock=grabblock($block, \$lindex);
	my $plist=$deflist->[-1]->{plist}
	$if $plist
	    my @plist=split /,\s*/, $plist
	    $foreach $p in @plist
		my $macro={"p"=>$p};
		push @$deflist, $macro;
		parseblock({source=>$subblock, name=>"\${foreach}"})
		pop @$deflist;
    $elsif $preproc=~/^if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if testcondition($1)
	    parseblock({source=>$subblock, name=>"\${if:}"})
	    $context="switch_off";
	$else
	    $context="switch_on";
    $elsif $preproc=~/^els?e?if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    $if testcondition($1)
		#foreach my $t(@$subblock){ print "\t[$t]\n"; }
		parseblock({source=>$subblock, name=>"\${elif:}"})
		$context="switch_off";
	    $else
		$context="switch_on";
    $elsif $preproc=~/^else/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    parseblock({source=>$subblock, name=>"\${else}"})
	    undef $context;
    $elsif $preproc=~/^ifeach:\s*(.*)/
	my $cond=$1
	my $subblock=grabblock($block, \$lindex);
	my $plist=$deflist->[-1]->{plist}
	undef $context
	my $cond_var="p"
	$if $cond=~/^(\w+)/
	    $cond_var=$1
	$if $plist
	    my @plist=split /,\s*/, $plist
	    $foreach $p in @plist
		my $macro={$cond_var=>$p};
		push @$deflist, $macro;
		$if testcondition($cond)
		    parseblock({source=>$subblock, name=>"\${ifeach:}"})
		    $context="switch_off";
		pop @$deflist;
	$if !$context
	    $context="switch_on";
    $call @preproc_elifs
    $elsif $preproc=~/^allow_recurse:(\d+)/
	my $code=$block_stack[-1]->{code}
	$if $code->{allow_recurse}
	    $deflist->[-1]->{recurse}=$code->{recurse}
	$else
	    $code->{allow_recurse}=$1
	    $deflist->[-1]->{recurse}=0
    $elsif $preproc=~/^block:\s*(\w+)/
	my $name=$1;
	my $subblock=grabblock($block, \$lindex);
	&call with_named_block, $name
	    parseblock({source=>$subblock, name=>"block:$name"})
    $else
	goto NormalParse

# --------------------------------
subcode:: support_subs
    $sub test_op($a, $test)
	$if $test=~/^:(\d+)/
	    $test=$'
	    $a=substr($a, 0, $1);
	$if $test=~/(~|=|!=|<|>)(.*)/
	    my ($op, $b)=($1, $2)
	    $if $op eq "="
		if($a eq $b){ return 1;}
	    $elsif $op eq "!="
		if($a ne $b){ return 1;}
	    $elsif $op eq ">"
		if($a > $b){ return 1;}
	    $elsif $op eq "<"
		if($a < $b){ return 1;}
	    $elsif $op eq "~"
		if($a=~/^$b/){ return 1;}
	    $else
		return 0
	$else
	    return defined $a

    $sub testcondition
	my ($cond)=@_;
	$if !$cond
	    return 0;
	$call @testcondition_elifs
	$elif $cond=~/^\s*!(.*)/
	    return !testcondition($1)
	$elsif $cond=~/ or /
	    my @nlist=split / or /, $cond
	    $foreach $n in @nlist
		$if testcondition($n)
		    return 1;
	    return 0;
	$elsif $cond=~/,/
	    my @nlist=split /,/, $cond;
	    $foreach $n in @nlist
		$if !testcondition($n)
		    return 0;
	    return 1;
	$elsif $cond=~/^\s*(\w+)\.(\w+)/
	    $if $1 eq "fields"
		$if $MyDef::def->{fields}->{$2}
		    return 1;
	    $else
		my $t=get_def($1);
		$if $t
		    $if $MyDef::def->{fields}->{$t}->{$2}
			return 1;
	$elsif $cond=~/^\s*(\w+)(.*)/
	    my $t=get_def($1);
	    return test_op($t, $2)
	$else
	    return 0
	return 0

