subcode: parse_preproc
    expand_macro_recurse(\$preproc)
    # $print "parse_preproc: $preproc"
    $if $preproc=~/^for:\s*(\S+)\s+in\s+(.*)/
	my $vname=$1;
	my $vparam=$2;
	my @tlist;
	$if $vparam=~/(\d+)\.\.(\d+)/
	    $for my $i=$1;$i<=$2;$i++
		push @tlist, $i
	$else
	    @tlist=split /,\s*/, $vparam;

	my $subblock=grabblock($block, \$lindex);
	$foreach my $t in @tlist
	    my $macro={$vname=>$t};
	    push @$deflist, $macro;
	    parseblock({source=>$subblock, name=>"\${for}"})
	    pop @$deflist;
    $elsif $preproc=~/^foreach:p/
	my $subblock=grabblock($block, \$lindex);
	my $plist=$deflist->[-1]->{plist}
	$if $plist
	    my @plist=MyDef::utils::proper_split($plist)
	    $foreach $p in @plist
		my $macro={"p"=>$p};
		push @$deflist, $macro;
		parseblock({source=>$subblock, name=>"\${foreach}"})
		pop @$deflist;
	$else
	    warn "[$cur_file:$cur_line]\$(foreach:p) missing \$(plist)\n"
    $elsif $preproc=~/^if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$call parse_preproc_if
    $elsif $preproc=~/^els?e?if:\s*(.*)/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    $call parse_preproc_if
    $elsif $preproc=~/^else/
	my $subblock=grabblock($block, \$lindex);
	$if $context eq "switch_on"
	    parseblock({source=>$subblock, name=>"\${else}"})
	    undef $context;
    $elsif $preproc=~/^ifeach:\s*(.*)/
	my $cond=$1
	my $subblock=grabblock($block, \$lindex);
	my $plist=$deflist->[-1]->{plist}
	undef $context
	my $cond_var="p"
	$if $cond=~/^(\w+)/
	    $cond_var=$1
	$if $plist
	    my @plist=split /,\s*/, $plist
	    $foreach $p in @plist
		my $macro={$cond_var=>$p};
		push @$deflist, $macro;
		$if testcondition($cond)
		    parseblock({source=>$subblock, name=>"\${ifeach:}"})
		    $context="switch_off";
		pop @$deflist;
	$if !$context
	    $context="switch_on";
    $call @preproc_elifs
    $elif $preproc=~/^index_name:(\w+)/
	$global %index_name_hash
	$if !$index_name_hash{$1}
	    $index_name_hash{$1}=1
	$else
	    $index_name_hash{$1}+=1
	$deflist->[-1]->{index_name}="$1_$index_name_hash{$1}"
    $elsif $preproc=~/^allow_recurse:(\d+)/
	my $code=$block_stack[-1]->{code}
	$if $code->{allow_recurse}
	    $deflist->[-1]->{recurse}=$code->{recurse}
	$else
	    $code->{allow_recurse}=$1
	    $deflist->[-1]->{recurse}=0
    $elsif $preproc=~/^block:\s*(\w+)/
	my $name=$1;
	my $subblock=grabblock($block, \$lindex);
	&call with_named_block, $name
	    parseblock({source=>$subblock, name=>"block:$name"})
    $else
	goto NormalParse

#---------------------------------------- 
subcode: parse_preproc_if
    $if testcondition($1)
	parseblock({source=>$subblock, name=>"\${if:}"})
	$context="switch_off";
    $else
	$context="switch_on";
    $if $debug eq "preproc"
	$print parse_preproc_if: ($1) -> $context

#---------------------------------------- 
subcode:: support_subs
    $sub test_op($a, $test)
	$if $debug eq "preproc"
	    $print "preproc test_op: $a: $test"
	$if $test=~/^:(\d+)/
	    $test=$'
	    $a=substr($a, 0, $1);
	$elif $test=~/\s*(~|=|!=|<|>)(.*)/
	    my ($op, $b)=($1, $2)
	    $if $op eq "="
		if($a eq $b){ return 1;}
	    $elsif $op eq "!="
		if($a ne $b){ return 1;}
	    $elsif $op eq ">"
		if($a > $b){ return 1;}
	    $elsif $op eq "<"
		if($a < $b){ return 1;}
	    $elsif $op eq "~"
		if($a=~/^$b/){ return 1;}
	    $else
		return 0
	$else
	    return defined $a

    $sub test_in($a, $test)
	my @tlist=split /,\s*/, $test
	$foreach $t in @tlist
	    $if $t=~/(\S)-(\S)/
		$if ord($a)>=ord($1) and ord($a)<=ord($2)
		    return 1
	    $elif $a eq $t
		return 1
	return 0

    $sub testcondition($cond)
	$if $debug eq "preproc"
	    $print "preproc testcondition: $cond"
	$if !$cond
	    return 0;
	$call @testcondition_elifs
	$elif $cond=~/^\s*!(.*)/
	    return !testcondition($1)
	$elsif $cond=~/ or /
	    my @nlist=split / or /, $cond
	    $foreach $n in @nlist
		$if testcondition($n)
		    return 1;
	    return 0;
	$elsif $cond=~/^([01])$/
	    return $1
	$elsif $cond=~/^hascode:(.*)/
	    $if $MyDef::def->{codes}->{$1} or $MyDef::page->{codes}->{$1}
		return 1
	$elsif $cond=~/^(string|number):(.*)/
	    my $test=$1
	    my $t=get_def($2)
	    $if $test eq "string" and $t=~/^['"]/
		return 1
	    $elif $test eq "number" and $t=~/^\d+/
		return 1
	$elif $cond=~/^(\w+)\s+in\s+(.*)/
	    my $t=get_def($1);
	    return test_in($t, $2)
	$elsif $cond=~/,/
	    my @nlist=split /,/, $cond;
	    $foreach $n in @nlist
		$if !testcondition($n)
		    return 0;
	    return 1;
	$elsif $cond=~/^\s*(\w+)\.(\w+)/
	    $if $1 eq "fields"
		$if $MyDef::def->{fields}->{$2}
		    return 1;
	    $else
		my $t=get_def($1);
		$if $t
		    $if $MyDef::def->{fields}->{$t}->{$2}
			return 1;
	$elsif $cond=~/^\s*(\w+)(.*)/
	    my $t=get_def($1);
	    $if !$2
		return defined $t
	    $else
		$if !defined $t
		    return test_op($1, $2)
		$else
		    return test_op($t, $2)
	$else
	    return 0
	return 0

