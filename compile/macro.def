
# -------------------------------------------------------
#  $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];

subcode: strip_quote(v)
    $if $(v)=~/^["'](.*)["']$/
        $(v)=$1

subcode:: preproc_elifs
    $elif $preproc=~/^set:\s*(\w+)$/
        my $name=$1
        $call set_macro_join
    $elif $preproc=~/^set:\s*(\w+)\)/
        my $name=$1
        $if $l=~/^\$\(set:\s*\w+\)(.*)/
            $tail=$1
        $call set_macro_join
    $elif $preproc=~/^set:\s*(.*)/
        # immediate macros
        set_macro($deflist->[-1], $1)
    $elif $preproc=~/^set([012]):\s*(.*)/
        # standard macros: def, macros, page
        set_macro($deflist->[$1], $2)
    $elif $preproc=~/^setmacro:\s*(.*)/
        # standard macros: def, macros, page
        set_macro($deflist->[2], $1)
    $elif $preproc=~/autoinc:\s*(\w+)/
        my $page=$deflist->[2]
        $page->{$1}++
    $elif $preproc=~/^enuminc:\s*(\w+)/
        my $page=$deflist->[2]
        $if !$page->{$1}
            my $key = $1
            my $base = "_enumbase_"
            $if $key=~/^([^_]+)_/
                $base = $1
            $page->{$base}++
            $page->{$key}=$page->{$base}
    $elif $preproc=~/^export:\s*(.*)/
        my $t=$1;
        $if $t=~/^\w+,/
            my @plist=split /,\s*/, $t
            $foreach $p in @plist
                set_macro($deflist->[-2], $p)
        $else
            set_macro($deflist->[-2], $t)
    $elif $preproc=~/^mset:\s*(.*)/
        my @plist=split /,\s*/, $1
        $foreach $p in @plist
            set_macro($deflist->[-1], $p)
    $elif $preproc=~/^mexport:\s*(.*)/
        my @plist=split /,\s*/, $1
        $foreach $p in @plist
            set_macro($deflist->[-2], $p)
    $elif $preproc=~/^reset:\s*(\w+)([\.\+\-])?=(.*)/
        my ($v, $op, $d)=($1, $2, $3, $4)
        expand_macro(\$d)
        my $i=$#$deflist;
        $while $i>0 and !defined $deflist->[$i]->{$v}
            $i--
        $if $i==0
            $i=-1
        $if $op
            $deflist->[$i]->{$v}=calc_op($deflist->[$i]->{$v}, $op, $d)
        $else
            $deflist->[$i]->{$v}=$d;
    $elif $preproc=~/^unset:\s*(\w+)/
        $foreach $m in @$deflist
            delete $m->{$1}
    $elif $preproc=~/^eval:\s*(\w+)=(.*)/
        my ($t1,$t2)=($1,$2)
        expand_macro(\$t2)
        $deflist->[-1]->{$t1}=eval($t2)
    $elif $preproc=~/^split:\s*(\w+)$/
        my $p="\$($1)"
        expand_macro(\$p)
        my @tlist=MyDef::utils::proper_split($p)
        my $n=@tlist
        $deflist->[-1]->{p_n}=$n
        $for $i=1:$n+1
            $deflist->[-1]->{"p_$i"}=$tlist[$i-1]
    $elif $preproc=~/^split:([^:]+):\s*(\w+)/
        my $p="\$($2)"
        expand_macro(\$p)
        my @tlist=split /$1/, $p
        my $n=@tlist
        $deflist->[-1]->{p_n}=$n
        $for $i=1:$n+1
            $deflist->[-1]->{"p_$i"}=$tlist[$i-1]

#---------------------------------------- 
#- $(set:name) join, sep, pattern, listitem1, ...
subcode: set_macro_join
    $if !$tail
        $deflist->[-1]->{$name}=""
    $else
        $tail=~s/^\s+//
        my @tlist=MyDef::utils::proper_split($tail)
        my $verb=shift @tlist
        $if $verb eq "join"
            my $sep=shift @tlist
            my $pat=shift @tlist
            $map strip_quote, $sep, $pat
            my $subblock=grabblock($block, \$lindex)
            my @out_list
            $if $pat
                $call @join_pattern
            $else
                $call @join_direct
            $deflist->[-1]->{$name}= join($sep, @out_list)
    # ----------
    subcode: join_pattern
        $foreach $t in @$subblock
            $if $t!~/^SOURCE:/
                push @tlist, MyDef::utils::proper_split($t)
        $foreach $t2 in @tlist
            my $t3=$pat
            $t3=~s/\*/$t2/g
            push @out_list, $t3
    # ----------
    subcode: join_direct
        $foreach $t in @$subblock
            $if $t!~/^SOURCE:/
                expand_macro(\$t)
                push @out_list, $t

#---------------------------------------- 
subcode:: support_subs
    $sub calc_op($v, $op, $d)
        $if $op eq "."
            return $v . $d
        my $ret=get_numeric($v)
        $if $op eq "+"
            $ret+=get_numeric($d)
        $elif $op eq "-"
            $ret-=get_numeric($d)
        $if $v=~/^0x/
            return sprintf("0x%lx", $ret)
        $else
            return $ret

    $sub get_numeric($v)
        $if $v=~/0x(.*)/
            return hex($v)
        $else
            return $v

    $sub set_macro($m, $p)
        $if $debug eq "macro"
            print "set_macro: [$p]\n";
        $if $p=~/(\w+)([\+\-\*\/\.])=(\d+)/
            my ($t1, $op, $num)=($1, $2, $3)
            $if $op eq "+"
                $m->{$t1}+=$num
            $elif $op eq "*"
                $m->{$t1}*=$num
            $elif $op eq "."
                $m->{$t1}.=$num
            $elif $op eq "/"
                $m->{$t1}/=$num
            $elif $op eq "-"
                $m->{$t1}/=$num
        $elif $p=~/(\S+?)=(.*)/
            my ($t1, $t2)=($1, $2)
            $if $t1=~/\$\(.*\)/
                expand_macro(\$t1)
            $if $t2=~/\$\(.*\)/
                expand_macro(\$t2)
            $m->{$t1}=$t2
        $else
            my $t=get_def($p)
            $if defined $t
                $m->{$p}=$t
            $else
                $call warn,  set_macro parse error: [$p]

    $sub set_current_macro($name, $val)
        $deflist->[-1]->{$name}=$val

    $sub export_macro($i, $name, $val)
        $deflist->[$i]->{$name}=$val

    $sub get_current_macro($name)
        return $deflist->[-1]->{$name}

# ------------------------------------------------------
fncode: expand_macro($lref)
    #- a hack -- $.property 
    $$lref=~s/(?<=\$)\.(?=\w)/(this)/g

    #- if literal $(word) is needed 
    #-     * use literal bypass: [$: literal source ...]
    #-     * encode $ (if supported):  &#36;  \x24  \044
    #-     $(\W...) is safe though
    $while $$lref=~/\$\(\w/
        my $t=$$lref
        $$lref=MyDef::utils::expand_macro($t, \&get_macro)
        $if $t eq $$lref
            last

fncode: get_macro($s, $nowarn)
    $if $s=~/^((rep|perl|map|or|and|sym)\b.+)/
        my $t=$1
        $if $t=~/^rep\[(.*?)\](\d+):(.*)/
            $if $2>1
                return "$3$1" x ($2-1) . $3
            $else
                die "Illegal rep macro in \"$s\"!\n"
        $elif $t=~/^perl:(.*)/
            my $outdir=".";
            $if $MyDef::var->{output_dir}
                $outdir=$MyDef::var->{output_dir};
            my $defname=$MyDef::def->{defname}
            my $t=$1
            $t=~s/,/ /g
            $if open In, "perl $outdir/perl-$defname.pl $t|"
                my $t=<In>
                close In
                return $t
            $else
                die "Failed perl $outdir/perl-$defname.pl\n"
        $elif $t=~/^map\s+(.*):(.*):(.*)/
            my ($pat, $sep)=($1, $3)
            my @tlist=split /\|/, $2
            my @segs
            $foreach $t in @tlist
                my $p=$pat
                $p=~s/\$1/$t/g
                push @segs, $p
            return join(" $sep ", @segs)
        $elif $t =~ /^(or|and):\s*(.*?):\s*(.*)/
            my $sep=" $1 "
            my $pat=$2
            my @tlist=split /,\s*/, $3
            my @segs
            $foreach $t in @tlist
                my $tt=$pat
                $tt=~s/\*/$t/g
                push @segs, $tt
            return join($sep, @segs)
        $elif $t =~ /^sym:(.+)/
            return MyDef::utils::string_symbol_name($1)
        $else
            warn " [$cur_file:$cur_line] syntax error: [$s]\n"
            return undef
    $elif $s=~/^(\w+):(.*)/
        #---- all kinds of annotations --------
        my $p=$2;
        my $t=get_macro_word($1, $nowarn)
        $if $t
            $if $p=~/(\d+)-(\d+)/
                #-- substr, e.g. $(macro:0-3) ----
                my $s=substr($t, $1, $2-$1+1);
                $print $t:$1-$2 -> [$s]
                return $s
            $elif $p=~/(\d+):(\d+|word|number|strip)/
                #-- substr with regex predicate ----
                my $s=substr($t, $1)
                $if $2 eq "word"
                    $if $s=~/^\s*(\w+)/
                        $s=$1
                $elif $2 eq "number"
                    $if $s=~/^\s*([+-]?\d+)/
                        $s=$1
                $elif $2 ne "strip"
                    $s=substr($s, 0, $2)
                return $s
            $elif $p eq "len"
                #-- strlen, e.g. $(macro:len)------
                return length($t)
            $elif $p eq "strlen"
                #-- literal strlen -----
                $if $t=~/^".*"$/
                    return eval "length($t)"
                $else
                    return length($t)
            $elif $p eq "strip"
                return substr($t, 1, -1)
            $elif $p=~/list:(.*)/
                my $idx=$1
                my @tlist=MyDef::utils::proper_split($t)
                $if $idx eq "n"
                    return scalar(@tlist)
                $elif $idx=~/(\d+)/
                    return $tlist[$1]
                $elif $idx=~/(.*)\*(.*)/
                    $foreach $t in @tlist
                        $t = "$1$t$2"
                    return join(", ", @tlist)
            $else
                #--INLINE macro -- $(macro:p1,p2,p3)
                my @plist
                @plist=MyDef::utils::proper_split($p)
                my $i=1;
                $foreach $pp in @plist
                    $t=~s/\$$i/$pp/g
                    $i++
                return $t
    $elif $s=~/^([mg])([\|&]+):(.*)/
        my ($m, $sep, $t)=($1, $2, $3)
        my @tlist
        $if $t=~/^(.*==\s*)(.*)$/
            my ($pre, $t)=($1, $2)
            my @t = split /,\s*/, $t
            $foreach $tt in @t
                push @tlist, "$pre$tt"
        $else
            $print failed to parse multiplex macro [$sep][$t]
        $if $m eq "g"
            return '('.join(" $sep ", @tlist).')'
        $else
            return join(" $sep ", @tlist)
    $elif $s=~/^(.+)/
        #---- straight macro ----
        return get_macro_word($1)

fncode: get_macro_word($name, $nowarn) 
    $for $j=$#$deflist:-1:-1
        my $macros=$deflist->[$j]
        $if exists($macros->{$name})
            return $macros->{$name}
    $if !$nowarn
        $print get_macro_word $name [$nowarn]
        warn "[$cur_file:$cur_line] Macro $name not defined\n"
    return undef
