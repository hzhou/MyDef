
# -------------------------------------------------------
#  $deflist=[$MyDef::def, $MyDef::def->{macros}, $page];

subcode:: preproc_elifs
    $elif $preproc=~/^set:\s*(.*)/
	# immediate macros
	set_macro($deflist->[-1], $1)
    $elif $preproc=~/^set([012]):\s*(.*)/
	# standard macros: def, macros, page
	set_macro($deflist->[$1], $2)
    $elif $preproc=~/^setmacro:\s*(.*)/
	# standard macros: def, macros, page
	set_macro($deflist->[2], $1)
    $elif $preproc=~/autoinc:\s*(\w+)/
	my $page=$deflist->[2]
	$page->{$1}++
    $elif $preproc=~/^export:\s*(.*)/
	my $t=$1;
	$if $t=~/^\w+,/
	    my @plist=split /,\s*/, $t
	    $foreach $p in @plist
		set_macro($deflist->[-2], $p)
	$else
	    set_macro($deflist->[-2], $t)
    $elif $preproc=~/^mset:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-1], $p)
    $elif $preproc=~/^mexport:\s*(.*)/
	my @plist=split /,\s*/, $1
	$foreach $p in @plist
	    set_macro($deflist->[-2], $p)
    $elif $preproc=~/^preset:([^:]+):(.*)/
	my $preset=$1;
	my $t=$2;
	foreach my $tt(split /,/, $t){
	    $deflist->[-1]->{$tt}="$preset$tt";
	}
    $elif $preproc=~/^reset:\s*(\w+)([+])?=(.*)/
	my ($v, $op, $d)=($1, $2, $3, $4)
	expand_macro_recurse(\$d)
	my $i=$#$deflist;
	$while $i>0 and !defined $deflist->[$i]->{$v}
	    $i--;
	$if $op
	    $deflist->[$i]->{$v}=calc_op($deflist->[$i]->{$v}, $op, $d)
	$else
	    $deflist->[$i]->{$v}=$d;
    $elif $preproc=~/^unset:\s*(\w+)/
	my $v=$1
	my $i=$#$deflist;
	$while $i>0 and !defined $deflist->[$i]->{$v}
	    $i--;
	delete $deflist->[$i]->{$v}
    $elif $preproc=~/^eval:\s*(\w+)=(.*)/
	my ($t1,$t2)=($1,$2)
	expand_macro_recurse(\$t2)
	$deflist->[-1]->{$t1}=eval($t2)
    $elif $preproc=~/^split:\s*(\w+)/
	my $p="\$($1)"
	expand_macro_recurse(\$p)
	my @tlist=MyDef::utils::proper_split($p)
	my $n=@tlist
	$deflist->[-1]->{p_n}=$n
	$for $i=1:$n+1
	    $deflist->[-1]->{"p_$i"}=$tlist[$i-1]

subcode:: support_subs
    $sub calc_op($v, $op, $d)
	my $ret=get_numeric($v)
	$if $op eq "+"
	    $ret+=get_numeric($d)
	$elif $op eq "-"
	    $ret-=get_numeric($d)
	$if $v=~/^0x/
	    return sprintf("0x%lx", $ret)
	$else
	    return $ret

    $sub get_numeric($v)
	$if $v=~/0x(.*)/
	    return hex($v)
	$else
	    return $v


    $sub set_macro($m, $p)
	$if $debug eq "macro"
	    print "set_macro: [$p]\n";
	$if $p=~/(\w+)\+=(\d+)/
	    my ($t1, $t2)=($1, $2)
	    $m->{$t1}+=$t2
	$elif $p=~/(\S+?)=(.*)/
	    my ($t1, $t2)=($1, $2)
	    $if $t1=~/\$\(.*\)/
		expand_macro_recurse(\$t1)
	    $if $t2=~/\$\(.*\)/
	        expand_macro_recurse(\$t2, 1)
	    $m->{$t1}=$t2
	$elif my $t=get_def($p)
	    $m->{$p}=$t
	$else
	    warn "[$cur_file:$cur_line] compileutil::set_macro parse error: [$p]\n"

    $sub set_current_macro($name, $val)
	$deflist->[-1]->{$name}=$val

    $sub export_macro($i, $name, $val)
	$deflist->[$i]->{$name}=$val

    $sub get_current_macro($name)
	return $deflist->[-1]->{$name}

# ------------------------------------------------------
subcode: expand_macro_seg
    $if $s=~/^\$\((\w+)\.(\w+)\)/
	my $t=$macros->{$1};
	$if $t
	    my $tt=$MyDef::def->{fields}->{$t};
	    $if $tt
		$if $tt->{$2}
		    $segs[$j]=$tt->{$2};
		$elsif $2 eq "title"
		    $segs[$j]=$t;
		$else
		    $segs[$j]="";
		$updated++;
	    $else
		$if $2 eq "title"
		    $segs[$j]=$t;
		    $updated++;
    $elif $s=~/^\$\(rep\[(.*?)\](\d+):(.*)\)/
	$if $2>1
	    $segs[$j]="$3$1" x ($2-1) . $3
	    $updated++;
	$else
	    die "Illegal rep macro in \"$$lref\"!\n"
    $elif $s=~/^\$\(perl:(.*)\)/
	my $outdir=".";
	$if $MyDef::var->{output_dir}
	    $outdir=$MyDef::var->{output_dir};
	my $defname=$MyDef::def->{defname}
	my $t=$1
	$t=~s/,/ /g
	$if open In, "perl $outdir/perl-$defname.pl $t|"
	    my $t=<In>
	    $segs[$j]=$t
	    close In
	$else
	    die "Failed perl $outdir/perl-$defname.pl\n"
	$updated++;
    $elif $s=~/^\$\((\w+):(.*)\)/
	#---- all kinds of annotations --------
	my $t=$macros->{$1};
	my $p=$2;
	$if $t
	    $updated++;
	    $if $p=~/(\d+)-(\d+)/
		#-- substr, e.g. $(macro:0-3) ----
		$segs[$j]=substr($t, $1, $2-$1+1);
	    $elif $p=~/(\d+):(\d+|word|number|strip)/
		#-- substr with regex predicate ----
		my $s=substr($t, $1)
		$if $2 eq "word"
		    $if $s=~/^\s*(\w+)/
			$s=$1
		$elif $2 eq "number"
		    $if $s=~/^\s*([+-]?\d+)/
			$s=$1
		$elif $2 ne "strip"
		    $s=substr($s, 0, $2)
		$segs[$j]=$s
	    $elif $p eq "len"
		#-- strlen, e.g. $(macro:len)------
		$segs[$j]=length($t)
	    $elif $p eq "strlen"
		#-- literal strlen -----
		$if $t=~/^".*"$/
		    $segs[$j]=eval "length($t)"
		$else
		    $segs[$j]=length($t)
	    $elif $p eq "strip"
		$segs[$j]=substr($t, 1, -1)
	    $elif $p=~/list:(.*)/
		my $idx=$1
		my @tlist=MyDef::utils::proper_split($t)
		$if $idx eq "n"
		    $segs[$j]=@tlist
		$elif $idx=~/(\d+)/
		    $segs[$j]=$tlist[$1]
	    $else
		#--INLINE macro -- $(macro:p1,p2,p3)
		my @plist=MyDef::utils::proper_split($p)
		my $i=1;
		$foreach $pp in @plist
		    $t=~s/\$$i/$pp/g
		    $i++
		$segs[$j]=$t
    $elsif $s=~/^\$\((.+)\)/
	$if exists($macros->{$1})
	    my $t=$macros->{$1};
	    $if $t eq $s
		die "Looping macro $1 in \"$$lref\" [$t]=[$s]!\n";
	    $segs[$j]=$t;
	    $updated++;
	$else
	    # warn "Undefined macro $s\n"

subcode:: support_subs
    $sub expand_macro
	my ($lref, $macros)=@_;
	my $hasmacro=0
	my $updated=0
	$if  $$lref=~/\$\(\w[^()]*\)/
	    my @segs=split /(\$\(\w[^()]*\))/, $$lref;
	    my $j=0;
	    $foreach my $s in  @segs
		$call expand_macro_seg
		$j++;
	    $if $updated
		$$lref=join '', @segs;
	    $else
		$hasmacro=1;
	return ($hasmacro, $updated)

    $sub expand_macro_recurse($lref, $nowarn)
	my ($hasmacro, $updated)
	$$lref=~s/\$\.(?=\w)/\$(this)/g
	$updated=1
	$while $updated
	    $for $j=$#$deflist:-1:-1
		($hasmacro, $updated)=expand_macro($lref, $deflist->[$j]);
		$if $updated or !$hasmacro
		    last;
	$if $hasmacro and !$nowarn
	    $while $$lref=~/(\$\([^()]+\))/g
		$if substr($`, -1) ne "\\"
		    warn "[$cur_file:$cur_line] Macro $1 not defined in $$lref\n"
	return !$hasmacro

    $sub get_macro($name)
	my $t='$'."($name)"
	my $ret=expand_macro_recurse(\$t, 1)
	$if $ret
	    return $t
	$else
	    return undef
